[
    {
        "input": "\n\nclass Solution(object):\n    def largeGroupPositions(self, S):\n        \n        if not S:\n            return []\n        \n        result = []\n        count = 1\n        prevChar = S[0]\n        index_i = 0\n        for index in range(1,len(S)):\n            if S[index] == prevChar:\n                count += 1\n            else:\n                if count >= 3:\n                    result.append([index_i, index-1])\n                \n                count = 1\n                prevChar = S[index]\n                index_i = index\n                \n        if count >= 3:\n            result.append([index_i, len(S)-1])\n        return result\n",
        "output": "struct Solution;\n\nstruct Group {\n    c: char,\n    start: usize,\n    end: usize,\n}\n\nimpl Solution {\n    fn large_group_positions(s: String) -> Vec<Vec<i32>> {\n        let mut prev: Option<Group> = None;\n        let mut groups: Vec<Group> = vec![];\n        for (i, c) in s.chars().enumerate() {\n            if let Some(prev_group) = prev {\n                if prev_group.c == c {\n                    prev = Some(Group {\n                        c,\n                        start: prev_group.start,\n                        end: i,\n                    });\n                } else {\n                    groups.push(prev_group);\n                    prev = Some(Group {\n                        c,\n                        start: i,\n                        end: i,\n                    });\n                }\n            } else {\n                prev = Some(Group {\n                    c,\n                    start: i,\n                    end: i,\n                });\n            }\n        }\n        if let Some(prev_group) = prev {\n            groups.push(prev_group);\n        }\n\n        groups\n            .iter()\n            .filter_map(|g| {\n                let start = g.start;\n                let end = g.end;\n                if end - start > 1 {\n                    Some(vec![start as i32, end as i32])\n                } else {\n                    None\n                }\n            })\n            .collect()\n    }\n}\n\n#[test]\nfn test() {\n    let s = \"abbxxxxzzy\".to_string();\n    let res: Vec<Vec<i32>> = vec_vec_i32![[3, 6]];\n    assert_eq!(Solution::large_group_positions(s), res);\n    let s = \"abc\".to_string();\n    let res: Vec<Vec<i32>> = vec![];\n    assert_eq!(Solution::large_group_positions(s), res);\n    let s = \"abcdddeeeeaabbbcd\".to_string();\n    let res: Vec<Vec<i32>> = vec_vec_i32![[3, 5], [6, 9], [12, 14]];\n    assert_eq!(Solution::large_group_positions(s), res);\n}\n"
    },
    {
        "input": "\nclass Solution(object):\n    def maskPII(self, S):\n        \n        if '@' in S:\n            S = S.lower()\n            firstChar = S[0]\n            asterix = S.find('@')\n            return S[0] + \"*****\" + S[asterix-1:]\n        else:\n            S = S.replace('+', \"\")\n            S = S.replace('(', '')\n            S = S.replace('-', '')\n            S = S.replace(')', '')\n            S = S.replace(' ', '')\n            \n            if len(S) == 10:\n                return \"***-***-\" + S[-4:]\n            else:\n                countryCode = len(S) - 10\n                result = \"+\"\n                for index in range(countryCode):\n                    result += \"*\"\n                return result + \"-***-***-\" + S[-4:]\n",
        "output": "struct Solution;\n\nimpl Solution {\n    fn mask_pii(s: String) -> String {\n        if let Some(i) = s.find('@') {\n            let s = s.to_lowercase();\n            format!(\"{}*****{}\", &s[0..1], &s[i - 1..])\n        } else {\n            let digits: String = s.chars().filter(|&c| ('0'..='9').contains(&c)).collect();\n            let n = digits.len();\n            match digits.len() {\n                13 => format!(\"+***-***-***-{}\", &digits[n - 4..]),\n                12 => format!(\"+**-***-***-{}\", &digits[n - 4..]),\n                11 => format!(\"+*-***-***-{}\", &digits[n - 4..]),\n                _ => format!(\"***-***-{}\", &digits[n - 4..]),\n            }\n        }\n    }\n}\n\n#[test]\nfn test() {\n    let s = \"LeetCode@LeetCode.com\".to_string();\n    let res = \"l*****e@leetcode.com\".to_string();\n    assert_eq!(Solution::mask_pii(s), res);\n    let s = \"AB@qq.com\".to_string();\n    let res = \"a*****b@qq.com\".to_string();\n    assert_eq!(Solution::mask_pii(s), res);\n    let s = \"1(234)567-890\".to_string();\n    let res = \"***-***-7890\".to_string();\n    assert_eq!(Solution::mask_pii(s), res);\n    let s = \"86-(10)12345678\".to_string();\n    let res = \"+**-***-***-5678\".to_string();\n    assert_eq!(Solution::mask_pii(s), res);\n}\n"
    },
    {
        "input": "\n\n\n\n\n\n\n\n\nclass Solution(object):\n    def invertTree(self, root):\n        \n\n        if not root:\n        \treturn\n\n        leftTree = self.invertTree(root.left)\n        rightTree = self.invertTree(root.right)\n        root.left = rightTree\n        root.right = leftTree\n        return root\n\n\n\n\n\n\n\n\n\nclass Solution(object):\n    def invertTree(self, root):\n        \n        if not root:\n        \treturn None\n        \n        queue = [root]\n        while queue:\n        \tnode = queue.pop(0)\n        \tnode.left, node.right = node.right, node.left\n        \tif node.left:\n        \t\tqueue.append(node.left)\n        \tif node.right:\n        \t\tqueue.append(node.right)\n\n        return root",
        "output": "struct Solution;\nuse rustgym_util::*;\n\nimpl Solution {\n    fn invert_tree(root: TreeLink) -> TreeLink {\n        if let Some(node) = &root {\n            let mut node = node.borrow_mut();\n            let left = node.left.take();\n            let right = node.right.take();\n            node.right = Self::invert_tree(left);\n            node.left = Self::invert_tree(right);\n        }\n        root\n    }\n}\n\n#[test]\nfn test() {\n    let input = tree!(\n        4,\n        tree!(2, tree!(1), tree!(3)),\n        tree!(7, tree!(6), tree!(9))\n    );\n    let output = tree!(\n        4,\n        tree!(7, tree!(9), tree!(6)),\n        tree!(2, tree!(3), tree!(1))\n    );\n    assert_eq!(Solution::invert_tree(input), output);\n}\n"
    },
    {
        "input": "import heapq\n\nclass f(object):\n\tdef __init__(self, x, h, s):\n\t\tself.x = x\n\t\tself.h = h\n\t\tself.s = s\n\n\tdef __lt__(self, other):\n\t\tif self.x != other.x:\n\t\t\treturn self.x < other.x\n\t\telse:\n\t\t\tif self.s and other.s:\n\t\t\t\treturn self.h > other.h\n\t\t\telif not self.s and not other.s:\n\t\t\t\treturn self.h < other.h\n\t\t\telse:\n\t\t\t\treturn self.s > other.s\n            \nclass Solution(object):\n    def getSkyline(self, buildings):\n        \n        if len(buildings) == 0:\n            return []\n        \n        building_list = []\n        for x in range(len(buildings)):\n            building_list.append(f(buildings[x][0], buildings[x][2], 1))\n            building_list.append(f(buildings[x][1], buildings[x][2], 0))\n            \n        building_list = sorted(building_list)\n        for buil in building_list:\n            print buil.x, buil.h, buil.s\n        heap = [0]\n        result = []\n        curr_max = heap[0]\n        \n        for building in building_list:\n            heapq._heapify_max(heap)\n            \n            if building.s:\n                heap.append(building.h)\n                heapq._heapify_max(heap)\n                new_max = heap[0]\n                \n                if curr_max != new_max:\n                    result.append([building.x, building.h])\n                    curr_max = new_max\n            else:\n                heap.remove(building.h)\n                heapq._heapify_max(heap)\n                new_max = heap[0]\n                \n                if new_max != curr_max:\n                    result.append([building.x, new_max])\n                    curr_max = new_max\n                    \n        return result\n                \n            \n            \n        ",
        "output": "struct Solution;\n\nuse std::cmp::Ordering::*;\nuse std::collections::VecDeque;\n\nimpl Solution {\n    fn get_skyline(buildings: Vec<Vec<i32>>) -> Vec<Vec<i32>> {\n        if buildings.is_empty() {\n            return vec![];\n        }\n        let mut queue: VecDeque<Vec<Vec<i32>>> = buildings\n            .into_iter()\n            .map(|x| vec![vec![x[0], x[2]], vec![x[1], 0]])\n            .collect();\n        while queue.len() > 1 {\n            let a = queue.pop_front().unwrap();\n            let b = queue.pop_front().unwrap();\n            let c = Self::merge(a, b);\n            queue.push_back(c);\n        }\n        queue.pop_front().unwrap()\n    }\n\n    fn merge(a: Vec<Vec<i32>>, b: Vec<Vec<i32>>) -> Vec<Vec<i32>> {\n        let mut i = 0;\n        let mut j = 0;\n        let mut res = vec![];\n        let mut prev_h = 0;\n        let mut l = 0;\n        let mut r = 0;\n        let mut x;\n        while i < a.len() && j < b.len() {\n            match a[i][0].cmp(&b[j][0]) {\n                Equal => {\n                    x = a[i][0];\n                    l = a[i][1];\n                    r = b[j][1];\n                    i += 1;\n                    j += 1;\n                }\n                Less => {\n                    x = a[i][0];\n                    l = a[i][1];\n                    i += 1;\n                }\n                Greater => {\n                    x = b[j][0];\n                    r = b[j][1];\n                    j += 1;\n                }\n            }\n            let h = l.max(r);\n            if h != prev_h {\n                res.push(vec![x, h]);\n                prev_h = h;\n            }\n        }\n        while i < a.len() {\n            let x = a[i][0];\n            let h = a[i][1];\n            i += 1;\n            if h != prev_h {\n                res.push(vec![x, h]);\n                prev_h = h;\n            }\n        }\n        while j < b.len() {\n            let x = b[j][0];\n            let h = b[j][1];\n            j += 1;\n            if h != prev_h {\n                res.push(vec![x, h]);\n                prev_h = h;\n            }\n        }\n        res\n    }\n}\n\n#[test]\nfn test() {\n    let buildings = vec_vec_i32![\n        [2, 9, 10],\n        [3, 7, 15],\n        [5, 12, 12],\n        [15, 20, 10],\n        [19, 24, 8]\n    ];\n    let res = vec![\n        [2, 10],\n        [3, 15],\n        [7, 12],\n        [12, 0],\n        [15, 10],\n        [20, 8],\n        [24, 0],\n    ];\n    assert_eq!(Solution::get_skyline(buildings), res);\n}\n"
    },
    {
        "input": "\n\n\n\n\n\n\n\n\nclass Solution(object):\n    def lowestCommonAncestor(self, root, p, q):\n        \n        \n        if not root:\n        \treturn None\n\n        if root == p or root == q:\n        \treturn root\n\n        l = self.lowestCommonAncestor(root.left, p, q)\n        r = self.lowestCommonAncestor(root.right, p, q)\n\n        if l and r:\n        \treturn root\n        return l if l else r",
        "output": "struct Solution;\nuse rustgym_util::*;\n\ntrait Preorder {\n    fn preorder(&self, p: i32, q: i32, lca: &mut TreeLink) -> (bool, bool);\n}\n\nimpl Preorder for TreeLink {\n    fn preorder(&self, p: i32, q: i32, lca: &mut TreeLink) -> (bool, bool) {\n        if let Some(node) = self {\n            let node = node.borrow();\n            let l = node.left.preorder(p, q, lca);\n            let r = node.right.preorder(p, q, lca);\n            let res = (l.0 || r.0 || node.val == p, l.1 || r.1 || node.val == q);\n            if lca.is_none() && res.0 && res.1 {\n                *lca = tree!(node.val);\n            }\n            res\n        } else {\n            (false, false)\n        }\n    }\n}\n\nimpl Solution {\n    fn lowest_common_ancestor(root: TreeLink, p: TreeLink, q: TreeLink) -> TreeLink {\n        let p = p.as_ref().unwrap().borrow().val;\n        let q = q.as_ref().unwrap().borrow().val;\n        let mut res = None;\n        root.preorder(p, q, &mut res);\n        res\n    }\n}\n\n#[test]\nfn test() {\n    let root = tree!(\n        3,\n        tree!(5, tree!(6), tree!(2, tree!(7), tree!(4))),\n        tree!(1, tree!(0), tree!(8))\n    );\n    let p = tree!(5);\n    let q = tree!(1);\n    let res = tree!(3);\n    assert_eq!(Solution::lowest_common_ancestor(root, p, q), res);\n    let root = tree!(\n        3,\n        tree!(5, tree!(6), tree!(2, tree!(7), tree!(4))),\n        tree!(1, tree!(0), tree!(8))\n    );\n    let p = tree!(5);\n    let q = tree!(4);\n    let res = tree!(5);\n    assert_eq!(Solution::lowest_common_ancestor(root, p, q), res);\n    let root = tree!(1, tree!(2), None);\n    let p = tree!(1);\n    let q = tree!(2);\n    let res = tree!(1);\n    assert_eq!(Solution::lowest_common_ancestor(root, p, q), res);\n}\n"
    },
    {
        "input": "\n\n\nclass Solution(object):\n\tdef dfs(curr, parent, length):\n\t\tif not curr:\n\t\t\treturn length\n\t\tif parent:\n\t\t\tlength = length + 1 if curr.val == parent.val + 1\n\t\telse:\n\t\t\tlength = 1\n\n\t\treturn max(length, max(dfs(curr.left, curr, length), dfs(curr.right, curr, length)))\n\n\tdef longestConsecutive(TreeNode root):\n\t\tif not root:\n\t\t\treturn 0\n\n\t\treturn dfs(root, null, 0)\n",
        "output": "struct Solution;\nuse rustgym_util::*;\n\ntrait Postorder {\n    fn postorder(&self, max: &mut usize) -> Option<(i32, usize)>;\n}\n\nimpl Postorder for TreeLink {\n    fn postorder(&self, max: &mut usize) -> Option<(i32, usize)> {\n        if let Some(node) = self {\n            let node = node.borrow();\n            let val = node.val;\n            let mut length = 1;\n            if let Some(left) = node.left.postorder(max) {\n                if val + 1 == left.0 {\n                    length = length.max(left.1 + 1);\n                }\n            }\n            if let Some(right) = node.right.postorder(max) {\n                if val + 1 == right.0 {\n                    length = length.max(right.1 + 1);\n                }\n            }\n            *max = (*max).max(length);\n            Some((val, length))\n        } else {\n            None\n        }\n    }\n}\n\nimpl Solution {\n    fn longest_consecutive(root: TreeLink) -> i32 {\n        let mut res = 0;\n        root.postorder(&mut res);\n        res as i32\n    }\n}\n\n#[test]\nfn test() {\n    let root = tree!(1, None, tree!(3, tree!(2), tree!(4, None, tree!(5))));\n    let res = 3;\n    assert_eq!(Solution::longest_consecutive(root), res);\n    let root = tree!(2, None, tree!(3, tree!(2, tree!(1), None), None));\n    let res = 2;\n    assert_eq!(Solution::longest_consecutive(root), res);\n}\n"
    },
    {
        "input": "\n\n\n\n\n\n\n\n\nclass Solution:\n    def minMeetingRooms(self, intervals):\n    \tif not intervals or len(intervals) == 0:\n    \t\treturn 0\n\n    \timport heapq\n\n    \tsorted_intervals = sorted(intervals, key=lambda it:(it.start, it.end))\n    \theap, result = [], 0\n\n    \tfor interval in sorted_intervals:\n    \t\tstart, end = interval.start, interval.end\n\n    \t\twhile heap and heap[0] <= start:\n    \t\t\theapq.heappop(heap)\n\n    \t\theapq.heappush(heap, end)\n\n    \t\tresult = max(result, len(heap))\n    \treturn result",
        "output": "struct Solution;\n\nuse std::cmp::Ordering;\n\nimpl Solution {\n    fn min_meeting_rooms(intervals: Vec<Vec<i32>>) -> i32 {\n        let mut v: Vec<(i32, i32)> = vec![];\n        for i in intervals {\n            v.push((i[0], 1));\n            v.push((i[1], -1));\n        }\n        v.sort_unstable_by(|a, b| match a.0.cmp(&b.0) {\n            Ordering::Equal => a.1.cmp(&b.1),\n            x => x,\n        });\n        let mut rooms = 0;\n        let mut max = 0;\n        for x in v {\n            rooms += x.1;\n            max = i32::max(rooms, max);\n        }\n        max\n    }\n}\n\n#[test]\nfn test() {\n    let intervals: Vec<Vec<i32>> = vec_vec_i32![[0, 30], [5, 10], [15, 20]];\n    assert_eq!(Solution::min_meeting_rooms(intervals), 2);\n    let intervals: Vec<Vec<i32>> = vec_vec_i32![[7, 10], [2, 4]];\n    assert_eq!(Solution::min_meeting_rooms(intervals), 1);\n    let intervals: Vec<Vec<i32>> = vec_vec_i32![[13, 15], [1, 13]];\n    assert_eq!(Solution::min_meeting_rooms(intervals), 1);\n}\n"
    },
    {
        "input": "\n\n\n\n\n\nclass Solution(object):\n    def isPalindrome(self, head):\n        \n        rev = None\n        slow, fast = head, head.next\n        while fast and fast.next:\n        \tfast = fast.next.next\n        \ttemp = slow\n        \tslow = slow.next\n        \ttemp.next = rev\n        \trev = temp\n\n        if fast:\n        \tslow = slow.next\n\n        while rev and rev.val == slow.val:\n        \trev = rev.next\n        \tslow = slow.next\n        return not rev",
        "output": "struct Solution;\nuse rustgym_util::*;\n\n#[derive(PartialEq, Eq, Clone, Debug)]\nstruct List {\n    head: ListLink,\n}\n\nimpl List {\n    fn new(head: ListLink) -> Self {\n        List { head }\n    }\n\n    fn pop(&mut self) -> Option<i32> {\n        if let Some(node) = self.head.take() {\n            self.head = node.next;\n            Some(node.val)\n        } else {\n            None\n        }\n    }\n\n    fn into_iter(self) -> IntoIter {\n        IntoIter { list: self }\n    }\n}\n\nstruct IntoIter {\n    list: List,\n}\n\nimpl Iterator for IntoIter {\n    type Item = i32;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        self.list.pop()\n    }\n}\n\nimpl Solution {\n    fn is_palindrome(head: ListLink) -> bool {\n        let list = List::new(head);\n        let vec: Vec<i32> = list.into_iter().collect();\n        for (i, &v) in vec.iter().rev().enumerate() {\n            if v != vec[i] {\n                return false;\n            }\n        }\n        true\n    }\n}\n\n#[test]\nfn test() {\n    let head = list!(1, 2, 3);\n    assert_eq!(Solution::is_palindrome(head), false);\n}\n"
    },
    {
        "input": "class TrieNode(object):\n    def __init__(self):\n        self.value, self.links = None, [None]*26\n\nclass Trie(object):\n    def __init__(self):\n        self.root = TrieNode()\n        return\n\n    def insert(self, word):\n        if word:\n            curr = self.root\n            for ch in word:\n                offset = ord(ch)-ord('a')\n                if curr.links[offset] == None:\n                    curr.links[offset] = TrieNode()\n                curr = curr.links[offset]\n            curr.value = word\n        return\n        \nclass Solution(object):\n    def helper(self, x, y, board, trie_node, result):\n        if trie_node.value:\n            result.add(trie_node.value) \n        for x1,y1 in ((x+1,y), (x-1,y), (x, y+1), (x, y-1)):\n            if 0<=x1<len(board) and 0<=y1<len(board[0]) and board[x1][y1] != -1 and trie_node.links[ord(board[x1][y1])-ord('a')]:\n                ch, board[x1][y1] = board[x1][y1], -1\n                self.helper(x1, y1, board, trie_node.links[ord(ch)-ord('a')], result)\n                board[x1][y1] = ch\n        return\n    \n    def findWords(self, board, words):\n        \n        trie = Trie()\n        for word in words:\n            trie.insert(word)\n        result = set([])\n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                if trie.root.links[ord(board[i][j])-ord('a')]: \n                    ch, board[i][j] = board[i][j], -1\n                    self.helper(i, j, board, trie.root.links[ord(ch)-ord('a')], result)\n                    board[i][j] = ch\n        return [x for x in result]    ",
        "output": "struct Solution;\nuse std::collections::HashMap;\n\n#[derive(Default)]\nstruct Trie {\n    children: HashMap<char, Trie>,\n    end: Option<String>,\n}\n\nimpl Trie {\n    fn insert(&mut self, word: String) {\n        let mut link = self;\n        for c in word.chars() {\n            link = link.children.entry(c).or_default();\n        }\n        link.end = Some(word);\n    }\n}\n\nimpl Solution {\n    fn find_words(mut board: Vec<Vec<char>>, words: Vec<String>) -> Vec<String> {\n        let mut trie = Trie::default();\n        for word in words {\n            trie.insert(word);\n        }\n        let n = board.len();\n        let m = board[0].len();\n        let mut res: Vec<String> = vec![];\n        for i in 0..n {\n            for j in 0..m {\n                Self::dfs(i, j, &mut board, &mut res, &mut trie, n, m);\n            }\n        }\n        res.into_iter().collect()\n    }\n\n    fn dfs(\n        i: usize,\n        j: usize,\n        board: &mut Vec<Vec<char>>,\n        all: &mut Vec<String>,\n        trie: &mut Trie,\n        n: usize,\n        m: usize,\n    ) {\n        let c = board[i][j];\n        if let Some(trie) = trie.children.get_mut(&c) {\n            board[i][j] = ' ';\n            if trie.end.is_some() {\n                all.push(trie.end.take().unwrap());\n            }\n            if i + 1 < n {\n                Self::dfs(i + 1, j, board, all, trie, n, m);\n            }\n            if j + 1 < m {\n                Self::dfs(i, j + 1, board, all, trie, n, m);\n            }\n            if i > 0 {\n                Self::dfs(i - 1, j, board, all, trie, n, m);\n            }\n            if j > 0 {\n                Self::dfs(i, j - 1, board, all, trie, n, m);\n            }\n            board[i][j] = c;\n        }\n    }\n}\n\n#[test]\nfn test() {\n    let board = vec_vec_char![\n        ['o', 'a', 'a', 'n'],\n        ['e', 't', 'a', 'e'],\n        ['i', 'h', 'k', 'r'],\n        ['i', 'f', 'l', 'v']\n    ];\n    let words = vec_string![\"oath\", \"pea\", \"eat\", \"rain\"];\n    let mut res = vec_string![\"eat\", \"oath\"];\n    let mut ans = Solution::find_words(board, words);\n    ans.sort();\n    res.sort();\n    assert_eq!(ans, res);\n}\n"
    },
    {
        "input": "class Solution(object):\n    def gameOfLife(self, board):\n        \n        index = []\n        \n        def around(i, j, board):\n            count = 0\n            for k in range(i-1, i+2):\n                for l in range(j-1, j+2):\n                    if 0<=k < len(board) and 0 <= l < len(board[0]):\n                        if board[k][l] == 1:\n                            count += 1\n                            \n            return count-1 if board[i][j] == 1 else count\n        \n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                count = around(i, j, board)\n                if board[i][j] == 1:\n                    if count > 3 or count < 2:\n                        index.append([i, j, 0])\n                else:\n                    if count == 3:\n                        index.append([i, j, 1])\n                    \n        while index:\n            i, j, value = index.pop()\n            board[i][j] =value\n            \n        ",
        "output": "struct Solution;\n\n#[derive(Copy, Clone)]\nenum State {\n    Dead = 0,\n    Live = 1,\n    LiveToDead = 2,\n    DeadToLive = 3,\n    LiveToLive = 4,\n    DeadToDead = 5,\n    Unknown = 6,\n}\n\nimpl State {\n    fn from_i32(x: i32) -> State {\n        match x {\n            0 => State::Dead,\n            1 => State::Live,\n            2 => State::LiveToDead,\n            3 => State::DeadToLive,\n            4 => State::LiveToLive,\n            5 => State::DeadToDead,\n            _ => State::Unknown,\n        }\n    }\n\n    fn to_i32(self) -> i32 {\n        self as i32\n    }\n\n    fn to_live(self) -> i32 {\n        match self {\n            State::LiveToDead | State::Live | State::LiveToLive => 1,\n            _ => 0,\n        }\n    }\n\n    fn next(self, neighbors: i32) -> State {\n        match self {\n            State::Live => match neighbors {\n                0 | 1 => State::LiveToDead,\n                2 | 3 => State::LiveToLive,\n                _ => State::LiveToDead,\n            },\n            State::Dead => match neighbors {\n                3 => State::DeadToLive,\n                _ => State::DeadToDead,\n            },\n            State::LiveToDead => State::Dead,\n            State::DeadToLive => State::Live,\n            State::LiveToLive => State::Live,\n            State::DeadToDead => State::Dead,\n            State::Unknown => State::Unknown,\n        }\n    }\n}\n\nimpl Solution {\n    fn game_of_life(board: &mut Vec<Vec<i32>>) {\n        let n = board.len();\n        let m = board[0].len();\n        for i in 0..n {\n            for j in 0..m {\n                let mut neighbors = 0;\n                if i > 0 {\n                    neighbors += State::from_i32(board[i - 1][j]).to_live();\n                }\n                if j > 0 {\n                    neighbors += State::from_i32(board[i][j - 1]).to_live();\n                }\n                if i + 1 < n {\n                    neighbors += State::from_i32(board[i + 1][j]).to_live();\n                }\n                if j + 1 < m {\n                    neighbors += State::from_i32(board[i][j + 1]).to_live();\n                }\n                if i > 0 && j > 0 {\n                    neighbors += State::from_i32(board[i - 1][j - 1]).to_live();\n                }\n                if i + 1 < n && j > 0 {\n                    neighbors += State::from_i32(board[i + 1][j - 1]).to_live();\n                }\n                if i + 1 < n && j + 1 < m {\n                    neighbors += State::from_i32(board[i + 1][j + 1]).to_live();\n                }\n                if i > 0 && j + 1 < m {\n                    neighbors += State::from_i32(board[i - 1][j + 1]).to_live();\n                }\n                let current: State = State::from_i32(board[i][j]);\n                board[i][j] = current.next(neighbors).to_i32();\n            }\n        }\n        for i in 0..n {\n            for j in 0..m {\n                board[i][j] = State::from_i32(board[i][j]).next(0).to_i32()\n            }\n        }\n    }\n}\n\n#[test]\nfn test() {\n    let mut board: Vec<Vec<i32>> = vec_vec_i32![[0, 1, 0], [0, 0, 1], [1, 1, 1], [0, 0, 0]];\n    let res: Vec<Vec<i32>> = vec_vec_i32![[0, 0, 0], [1, 0, 1], [0, 1, 1], [0, 1, 0]];\n    Solution::game_of_life(&mut board);\n    assert_eq!(board, res);\n}\n"
    },
    {
        "input": "\n\nclass Solution(object):\n    def canFinish(self, numCourses, prerequisites):\n        \n\n        graph = [[] for _ in range(numCourses)]\n        visited = [False for _ in range(numCourses)]\n        stack = [False for _ in range(numCourses)]\n\n        for pair in prerequisites:\n            x, y = pair\n            graph[x].append(y)\n\n        for course in range(numCourses):\n        \tif visited[course] == False:\n        \t\tif self.dfs(graph, visited, stack, course):\n        \t\t\treturn False \n        return True\n\n    def dfs(self, graph, visited, stack, course):\n    \tvisited[course] = True\n    \tstack[course] = True\n\n    \tfor neigh in graph[course]:\n    \t\tif visited[neigh] == False:\n    \t\t\tif self.dfs(graph, visited, stack, neigh):\n    \t\t\t\treturn True\n\n    \t\telif stack[neigh]:\n    \t\t\treturn True\n    \tstack[course] = False\n    \treturn False\n        ",
        "output": "struct Solution;\n\nimpl Solution {\n    fn can_finish(num_courses: i32, prerequisites: Vec<Vec<i32>>) -> bool {\n        let n = num_courses as usize;\n        let mut indegrees: Vec<i32> = vec![0; n];\n        let mut edges: Vec<Vec<usize>> = vec![vec![]; n];\n        let mut queue: Vec<usize> = vec![];\n        let mut res: Vec<usize> = vec![];\n        for e in prerequisites {\n            let u = e[1] as usize;\n            let v = e[0] as usize;\n            indegrees[v] += 1;\n            edges[u].push(v);\n        }\n        for u in 0..n {\n            let indegree = indegrees[u];\n            if indegree == 0 {\n                queue.push(u);\n            }\n        }\n        while let Some(u) = queue.pop() {\n            res.push(u);\n            while let Some(v) = edges[u].pop() {\n                indegrees[v] -= 1;\n                if indegrees[v] == 0 {\n                    queue.push(v);\n                }\n            }\n        }\n        res.len() == n\n    }\n}\n\n#[test]\nfn test() {\n    let num_courses = 2;\n    let prerequisites: Vec<Vec<i32>> = vec_vec_i32![[1, 0]];\n    let res = true;\n    assert_eq!(Solution::can_finish(num_courses, prerequisites), res);\n    let num_courses = 2;\n    let prerequisites: Vec<Vec<i32>> = vec_vec_i32![[1, 0], [0, 1]];\n    let res = false;\n    assert_eq!(Solution::can_finish(num_courses, prerequisites), res);\n}\n"
    },
    {
        "input": "\nimport heapq\nclass MedianFinder(object):\n\n    def __init__(self):\n        \n        self.max_heap = []\n        self.min_heap = []\n        \n\n    def addNum(self, num):\n        \n        if not self.max_heap or num > -self.max_heap[0]:\n        \theapq.heappush(self.min_heap, num)\n\n        \tif len(self.min_heap) > len(self.max_heap) + 1:\n        \t\theapq.heappush(self.max_heap, -heapq.heapop(self.min_heap))\n\t\telse:\n\t\t\theapq.heappush(self.max_heap, -num)\n\t\t\tif len(self.max_heap) > len(self.min_heap):\n\t\t\t\theapq.heappush(self.min_heap, -heapq.heapop(self.max_heap))        \n\n    def findMedian(self):\n        \n        print self.max_heap, self.min_heap\n        if len(self.max_heap) == len(self.min_heap):\n        \treturn (-self.max_heap[0]+self.min_heap[0] )/2.0\n        else:\n        \treturn self.min_heap[0]\n        \n\n\n\n\n\n",
        "output": "use std::cmp::Reverse;\nuse std::collections::BinaryHeap;\n\n#[derive(Default)]\nstruct MedianFinder {\n    lo: BinaryHeap<i32>,\n    hi: BinaryHeap<Reverse<i32>>,\n}\n\nimpl MedianFinder {\n    fn new() -> Self {\n        MedianFinder::default()\n    }\n\n    fn add_num(&mut self, num: i32) {\n        self.hi.push(Reverse(num));\n        let smallest = self.hi.pop().unwrap().0;\n        self.lo.push(smallest);\n        if self.lo.len() > self.hi.len() + 1 {\n            self.hi.push(Reverse(self.lo.pop().unwrap()));\n        }\n    }\n\n    fn find_median(&self) -> f64 {\n        if (self.lo.len() + self.hi.len()) % 2 == 0 {\n            (*self.lo.peek().unwrap() + self.hi.peek().unwrap().0) as f64 / 2.0\n        } else {\n            *self.lo.peek().unwrap() as f64\n        }\n    }\n}\n\n#[test]\nfn test() {\n    use assert_approx_eq::assert_approx_eq;\n    let mut obj = MedianFinder::new();\n    obj.add_num(1);\n    obj.add_num(2);\n    assert_approx_eq!(obj.find_median(), 1.5);\n    obj.add_num(3);\n    assert_approx_eq!(obj.find_median(), 2.0);\n}\n"
    },
    {
        "input": "\n\n\n\n\n\n\n\n\nclass Solution(object):\n    def kthSmallest(self, root, k):\n        \n        \n        if not root:\n        \treturn 0\n\n        stack = [root]\n        count, curr = 0, root\n\n\n        while stack:\n        \tif curr.left:\n        \t\tstack.append(curr.left)\n        \t\tcurr = curr.left\n        \telse:\n        \t\tval = stack.pop()\n        \t\tcount += 1\n        \t\tif count == k:\n        \t\t\treturn val.val\n\n        \t\tif val.right:\n        \t\t\tstack.append(val.right)\n        \t\t\tcurr = val.right\n        return float('-inf')",
        "output": "struct Solution;\nuse rustgym_util::*;\n\ntrait Inorder {\n    fn inorder(&self, count: &mut usize, res: &mut i32, k: usize);\n}\n\nimpl Inorder for TreeLink {\n    fn inorder(&self, count: &mut usize, res: &mut i32, k: usize) {\n        if let Some(node) = self {\n            let node = node.borrow();\n            let left = &node.left;\n            let right = &node.right;\n            left.inorder(count, res, k);\n            *count += 1;\n            if *count == k {\n                *res = node.val;\n            }\n            right.inorder(count, res, k);\n        }\n    }\n}\n\nimpl Solution {\n    fn kth_smallest(root: TreeLink, k: i32) -> i32 {\n        let mut count = 0;\n        let mut res = 0;\n        root.inorder(&mut count, &mut res, k as usize);\n        res\n    }\n}\n\n#[test]\nfn test() {\n    let root = tree!(3, tree!(1, None, tree!(2)), tree!(4));\n    let k = 1;\n    let res = 1;\n    assert_eq!(Solution::kth_smallest(root, k), res);\n    let root = tree!(5, tree!(3, tree!(2, tree!(1), None), tree!(4)), tree!(6));\n    let k = 3;\n    let res = 3;\n    assert_eq!(Solution::kth_smallest(root, k), res);\n}\n"
    },
    {
        "input": "\n\nclass Solution(object):\n    def missingNumber(self, nums):\n        \n        if not nums:\n        \treturn 0\n        totalSum, n = sum(nums), len(nums)\n        expectedSum = (n*(n+1))/2\n        return expectedSum - totalSum",
        "output": "struct Solution;\n\nimpl Solution {\n    fn missing_number(nums: Vec<i32>) -> i32 {\n        let mut xor: i32 = 0;\n        let n = nums.len();\n        for n in 0..=n {\n            xor ^= n as i32;\n        }\n        for n in nums {\n            xor ^= n;\n        }\n        xor\n    }\n}\n\n#[test]\nfn test() {\n    let nums = vec![9, 6, 4, 2, 3, 5, 7, 0, 1];\n    assert_eq!(Solution::missing_number(nums), 8);\n}\n"
    },
    {
        "input": "\n\n\n\n\n\n\n\n\nclass Solution(object):\n    def inorderSuccessor(self, root, p):\n        \n\n\t\tif not root or not p:\n\t\t\treturn None\n\n\t\tif p.right:\n\t\t\tp = p.right\n\t\t\twhile p.left:\n\t\t\t\tp = p.left\n\t\t\treturn p\n\n\t\tsuccessor = None\n\t\twhile root and root != p:\n\t\t\tif root.val > p.val:\n\t\t\t\tsuccessor = root\n\t\t\t\troot = root.left\n\t\t\telse:\n\t\t\t\troot = root.right\n\t\treturn successor",
        "output": "struct Solution;\nuse rustgym_util::*;\n\ntrait Inorder {\n    fn inorder(&self, p: i32, successor: &mut TreeLink);\n}\n\nimpl Inorder for TreeLink {\n    fn inorder(&self, p: i32, successor: &mut TreeLink) {\n        if let Some(node) = self {\n            let node = node.borrow();\n            node.left.inorder(p, successor);\n            if successor.is_none() && node.val > p {\n                *successor = tree!(node.val);\n            }\n            node.right.inorder(p, successor);\n        }\n    }\n}\n\nimpl Solution {\n    fn inorder_successor(root: TreeLink, p: TreeLink) -> TreeLink {\n        let p = p.as_ref().unwrap().borrow().val;\n        let mut res = None;\n        root.inorder(p, &mut res);\n        res\n    }\n}\n\n#[test]\nfn test() {\n    let root = tree!(2, tree!(1), tree!(3));\n    let p = tree!(1);\n    let res = tree!(2);\n    assert_eq!(Solution::inorder_successor(root, p), res);\n    let root = tree!(5, tree!(3, tree!(2, tree!(1), None), tree!(4)), tree!(6));\n    let p = tree!(6);\n    let res = None;\n    assert_eq!(Solution::inorder_successor(root, p), res);\n}\n"
    },
    {
        "input": "\n\nclass Solution(object):\n    def findOrder(self, numCourses, prerequisites):\n        \n        graph = [[] for _ in range(numCourses)]\n        visited = [False for _ in range(numCourses)]\n        stack = [False for _ in range(numCourses)]\n\n        for pair in prerequisites:\n            x, y = pair\n            graph[x].append(y)\n\n        result = []\n        for course in range(numCourses):\n        \tif visited[course] == False:\n        \t\tif self.dfs(graph, visited, stack, course, result):\n        \t\t\treturn []\n        return result\n\n    def dfs(self, graph, visited, stack, course, result):\n    \tvisited[course] = True\n    \tstack[course] = True\n\n    \tfor neigh in graph[course]:\n    \t\tif visited[neigh] == False:\n    \t\t\tif self.dfs(graph, visited, stack, neigh, result):\n    \t\t\t\treturn True\n\n    \t\telif stack[neigh]:\n    \t\t\treturn True\n    \tstack[course] = False\n    \tresult.append(course)\n    \treturn False",
        "output": "struct Solution;\n\nuse std::collections::VecDeque;\n\nimpl Solution {\n    fn find_order(num_courses: i32, prerequisites: Vec<Vec<i32>>) -> Vec<i32> {\n        let mut res = vec![];\n        let n = num_courses as usize;\n        let mut edges: Vec<Vec<usize>> = vec![vec![]; n];\n        let mut indegrees: Vec<usize> = vec![0; n];\n        let mut queue: VecDeque<usize> = VecDeque::new();\n        for e in prerequisites {\n            let u = e[1] as usize;\n            let v = e[0] as usize;\n            edges[u].push(v);\n            indegrees[v] += 1;\n        }\n        for u in 0..n {\n            if indegrees[u] == 0 {\n                queue.push_back(u);\n            }\n        }\n        while let Some(u) = queue.pop_front() {\n            res.push(u);\n            for &v in &edges[u] {\n                indegrees[v] -= 1;\n                if indegrees[v] == 0 {\n                    queue.push_back(v);\n                }\n            }\n        }\n        if res.len() == n {\n            res.into_iter().map(|v| v as i32).collect()\n        } else {\n            vec![]\n        }\n    }\n}\n\n#[test]\nfn test() {\n    let num_courses = 2;\n    let prerequisites: Vec<Vec<i32>> = vec_vec_i32![[1, 0]];\n    let res = vec![0, 1];\n    assert_eq!(Solution::find_order(num_courses, prerequisites), res);\n    let num_courses = 4;\n    let prerequisites: Vec<Vec<i32>> = vec_vec_i32![[1, 0], [2, 0], [3, 1], [3, 2]];\n    let res = vec![0, 1, 2, 3];\n    assert_eq!(Solution::find_order(num_courses, prerequisites), res);\n}\n"
    },
    {
        "input": "\n\nclass Solution(object):\n    def findKthLargest(self, nums, k):\n        \n        heap = []\n        import heapq\n        for num in nums:\n        \theapq.heappush(heap, -(num))\n\n        result = 0\n        for _ in range(k):\n        \tresult = heapq.heappop(heap)\n\n        return -(result)\n",
        "output": "struct Solution;\nuse std::cmp::Ordering::*;\n\ntrait Partition {\n    fn partition(&mut self, l: usize, r: usize) -> usize;\n}\n\nimpl Partition for Vec<i32> {\n    fn partition(&mut self, l: usize, r: usize) -> usize {\n        self.swap((l + r) / 2, r);\n        let mut j = l;\n        let pivot = self[r];\n        for i in l..r {\n            if self[i] <= pivot {\n                self.swap(i, j);\n                j += 1;\n            }\n        }\n        self.swap(j, r);\n        j\n    }\n}\n\nimpl Solution {\n    fn find_kth_largest(mut nums: Vec<i32>, k: i32) -> i32 {\n        let n = nums.len();\n        let mut l = 0;\n        let mut r = n - 1;\n        let k = n - k as usize;\n        while l < r {\n            let m = nums.partition(l, r);\n            match m.cmp(&k) {\n                Less => {\n                    l = m + 1;\n                }\n                Greater => {\n                    r = m - 1;\n                }\n                Equal => {\n                    break;\n                }\n            }\n        }\n        nums[k]\n    }\n}\n\n#[test]\nfn test() {\n    let nums = vec![3, 2, 1, 5, 6, 4];\n    let k = 2;\n    let res = 5;\n    assert_eq!(Solution::find_kth_largest(nums, k), res);\n}\n"
    },
    {
        "input": "\n\n\n\n\n\n\n\n\nclass Solution(object):\n    def lowestCommonAncestor(self, root, p, q):\n        \n        if not root:\n        \treturn None\n        \n        if root.val > p.val and root.val > q.val:\n        \treturn self.lowestCommonAncestor(root.left, p, q)\n        elif root.val < p.val and root.val < q.val:\n        \treturn self.lowestCommonAncestor(root.right, p, q)\n        else:\n        \treturn root",
        "output": "struct Solution;\nuse rustgym_util::*;\n\nimpl Solution {\n    fn lowest_common_ancestor(mut root: TreeLink, p: TreeLink, q: TreeLink) -> TreeLink {\n        let p_val = p.unwrap().borrow().val;\n        let q_val = q.unwrap().borrow().val;\n        while let Some(node) = root.clone() {\n            let mut node = node.borrow_mut();\n            let val = node.val;\n            if val > p_val && val > q_val {\n                root = node.left.take();\n                continue;\n            }\n            if val < p_val && val < q_val {\n                root = node.right.take();\n                continue;\n            }\n            node.left.take();\n            node.right.take();\n            break;\n        }\n        root\n    }\n}\n\n#[test]\nfn test() {\n    let root = tree!(\n        6,\n        tree!(2, tree!(0), tree!(4, tree!(3), tree!(5))),\n        tree!(8, tree!(7), tree!(9))\n    );\n    let p = tree!(2);\n    let q = tree!(8);\n    let res = tree!(6);\n    assert_eq!(Solution::lowest_common_ancestor(root, p, q), res);\n    let root = tree!(\n        6,\n        tree!(2, tree!(0), tree!(4, tree!(3), tree!(5))),\n        tree!(8, tree!(7), tree!(9))\n    );\n    let p = tree!(2);\n    let q = tree!(4);\n    let res = tree!(2);\n    assert_eq!(Solution::lowest_common_ancestor(root, p, q), res);\n    let root = tree!(2, tree!(1), None);\n    let p = tree!(2);\n    let q = tree!(1);\n    let res = tree!(2);\n    assert_eq!(Solution::lowest_common_ancestor(root, p, q), res);\n}\n"
    },
    {
        "input": "\n\nclass Solution(object):\n    def moveZeroes(self, nums):\n        \n        zeroIndex = 0\n        for index in range(len(nums)):\n            if nums[index] != 0:\n                nums[zeroIndex] = nums[index]\n                zeroIndex += 1\n                \n        for index in range(zeroIndex, len(nums)):\n            nums[index] = 0",
        "output": "struct Solution;\n\nimpl Solution {\n    fn move_zeroes(nums: &mut Vec<i32>) {\n        let mut j = 0;\n        for i in 0..nums.len() {\n            let x = nums[i];\n            if x != 0 {\n                nums[i] = 0;\n                nums[j] = x;\n                j += 1;\n            }\n        }\n    }\n}\n\n#[test]\nfn test() {\n    let mut nums = vec![0, 1, 0, 3, 12];\n    Solution::move_zeroes(&mut nums);\n    assert_eq!(nums, vec![1, 3, 12, 0, 0]);\n}\n"
    },
    {
        "input": "\n\n\n\n\n\n\n\n\nclass Solution(object):\n    def binaryTreePaths(self, root):\n        \n        if not root:\n            return []\n        \n        paths = []\n        def dfs(root, curr):\n            if root.left is None and root.right is None:\n                paths.append(curr + str(root.val))\n                return\n                \n            if root.left:\n                dfs(root.left, curr + str(root.val) + '->')\n            if root.right:\n                dfs(root.right, curr + str(root.val) + '->')\n            \n        curr = \"\"\n        dfs(root, curr)\n        return paths",
        "output": "struct Solution;\nuse rustgym_util::*;\n\nstruct Path {\n    stack: Vec<i32>,\n}\n\nimpl ToString for Path {\n    fn to_string(&self) -> String {\n        let s: Vec<String> = self.stack.iter().map(|x| x.to_string()).collect();\n        s.join(\"->\")\n    }\n}\n\ntrait Preorder {\n    fn preorder(&self, path: &mut Path, v: &mut Vec<String>);\n}\n\nimpl Preorder for TreeLink {\n    fn preorder(&self, path: &mut Path, v: &mut Vec<String>) {\n        if let Some(node) = self {\n            let node = node.borrow();\n            path.stack.push(node.val);\n            if node.left.is_none() && node.right.is_none() {\n                v.push(path.to_string());\n            }\n            if node.left.is_some() {\n                node.left.preorder(path, v);\n            }\n            if node.right.is_some() {\n                node.right.preorder(path, v);\n            }\n            path.stack.pop();\n        }\n    }\n}\n\nimpl Solution {\n    fn binary_tree_paths(root: TreeLink) -> Vec<String> {\n        let mut path = Path { stack: vec![] };\n        let mut res = vec![];\n        root.preorder(&mut path, &mut res);\n        res\n    }\n}\n\n#[test]\nfn test() {\n    let root = tree!(1, tree!(2, None, tree!(5)), tree!(3));\n    let paths: Vec<String> = vec_string![\"1->2->5\", \"1->3\"];\n    assert_eq!(Solution::binary_tree_paths(root), paths);\n}\n"
    },
    {
        "input": "\n\nclass Solution(object):\n\tdef __init__(self, v1, v2):\n\t\tself.v1 = v1\n\t\tself.v2 = v2\n\t\tself.index_v1 = 0\n\t\tself.index_v2 = 0\n\n\tdef next(self):\n\t\tresult = -1\n\t\tif self.index_v1 != len(self.v1) and self.index_v1 <= self.index_v2:\n\t\t\tresult = self.v1[self.index_v1]\n\t\t\tself.index_v1 += 1\n\t\telse:\n\t\t\tresult = self.v2[self.index_v2]\n\t\t\tself.index_v2 += 1\n\n\t\treturn result\n\n\tdef hasNext(self):\n\t\treturn self.index_v1 < len(self.v1) or self.index_v2 < len(self.v2)\n\n\nsolution = Solution([1, 2], [3, 4, 5, 6])\nwhile solution.hasNext():\n\tprint solution.next()",
        "output": "use std::collections::VecDeque;\nuse std::iter::FromIterator;\n\n#[derive(Debug)]\nstruct ZigzagIterator {\n    queues: VecDeque<VecDeque<i32>>,\n}\n\nimpl<'a> ZigzagIterator {\n    fn new(v1: Vec<i32>, v2: Vec<i32>) -> Self {\n        let mut queues = VecDeque::new();\n        if !v1.is_empty() {\n            queues.push_back(VecDeque::from_iter(v1));\n        }\n        if !v2.is_empty() {\n            queues.push_back(VecDeque::from_iter(v2));\n        }\n        ZigzagIterator { queues }\n    }\n\n    fn next(&mut self) -> i32 {\n        let mut first = self.queues.pop_front().unwrap();\n        let res = first.pop_front().unwrap();\n        if !first.is_empty() {\n            self.queues.push_back(first);\n        }\n        res\n    }\n\n    fn has_next(&self) -> bool {\n        !self.queues.is_empty()\n    }\n}\n\n#[test]\nfn test() {\n    let v1 = vec![1, 2];\n    let v2 = vec![3, 4, 5, 6];\n    let res = vec![1, 3, 2, 4, 5, 6];\n    let mut obj = ZigzagIterator::new(v1, v2);\n    let mut ans = vec![];\n    while obj.has_next() {\n        ans.push(obj.next());\n    }\n    assert_eq!(ans, res);\n}\n"
    },
    {
        "input": "\n\n\n\n\n\n\n\n\nclass Codec:\n\n    def serialize(self, root):\n        \n        \n        def preorder(root):\n            if root:\n                seralizeTree.append(str(root.val) + ',')\n                preorder(root.left)\n                preorder(root.right)\n            else:\n                seralizeTree.append('\n                \n        seralizeTree = []\n        preorder(root)\n        return ''.join(seralizeTree)\n        \n\n    def deserialize(self, data):\n        \n        \n        def buildTree(preorder):\n            value = preorder.pop(0)\n            if value == '\n                return None\n            \n            node = TreeNode(int(value))\n            node.left = buildTree(preorder)\n            node.right = buildTree(preorder)\n            return node\n            \n        preorder = data.split(',')[:-1]\n        return buildTree(preorder)\n        \n\n\n\n",
        "output": "use rustgym_util::*;\nuse std::iter::Peekable;\nuse std::vec::IntoIter;\n\nstruct Codec;\n\nenum Tok {\n    Op(char),\n    Num(i32),\n}\n\nimpl Codec {\n    fn new() -> Self {\n        Codec {}\n    }\n\n    fn serialize(&self, root: TreeLink) -> String {\n        let mut res = \"\".to_string();\n        Self::serialize_tree(&root, &mut res);\n        res\n    }\n\n    fn serialize_tree(root: &TreeLink, s: &mut String) {\n        s.push('(');\n        if let Some(node) = root {\n            let node = node.borrow();\n            *s += &format!(\"{}\", node.val);\n            Self::serialize_tree(&node.left, s);\n            Self::serialize_tree(&node.right, s);\n        }\n        s.push(')');\n    }\n\n    fn deserialize(&self, data: String) -> TreeLink {\n        let tokens = Self::parse_tokens(data);\n        let mut it = tokens.into_iter().peekable();\n        Self::parse_tree(&mut it)\n    }\n\n    fn parse_tokens(data: String) -> Vec<Tok> {\n        let mut it = data.chars().peekable();\n        let mut res = vec![];\n        while let Some(c) = it.next() {\n            if c == '(' || c == ')' {\n                res.push(Tok::Op(c));\n            } else {\n                let mut sign = 1;\n                let mut x = 0;\n                if c == '-' {\n                    sign = -1;\n                } else {\n                    x = (c as u8 - b'0') as i32;\n                }\n                while let Some('0'..='9') = it.peek() {\n                    x *= 10;\n                    x += (it.next().unwrap() as u8 - b'0') as i32;\n                }\n                res.push(Tok::Num(sign * x));\n            }\n        }\n        res\n    }\n\n    fn parse_tree(it: &mut Peekable<IntoIter<Tok>>) -> TreeLink {\n        let mut res = None;\n        it.next();\n        match it.peek() {\n            Some(&Tok::Num(x)) => {\n                it.next();\n                res = tree!(x, Self::parse_tree(it), Self::parse_tree(it))\n            }\n            Some(Tok::Op(')')) => {}\n            _ => panic!(),\n        }\n        it.next();\n        res\n    }\n}\n\n#[test]\nfn test() {\n    let codec = Codec::new();\n    let root = tree!(1, tree!(2), tree!(3, tree!(4), tree!(5)));\n    let res = tree!(1, tree!(2), tree!(3, tree!(4), tree!(5)));\n    assert_eq!(codec.deserialize(codec.serialize(root)), res);\n}\n"
    },
    {
        "input": "class Solution(object):\n    def numIslands(self, grid):\n        \n        if not grid:\n        \treturn 0\n\n        count = 0\n        for row in range(len(grid)):\n        \tfor col in range(len(grid[0])):\n        \t\tif grid[row][col] == '1':\n        \t\t\tcount +=1\n        \t\t\tself.merge(grid, row, col)\n\n        return count\n\n    def merge(self, grid, row, col):\n    \tif 0 > row or row >= len(grid) or col < 0 or col >= len(grid[0]):\n    \t\treturn\n\n    \tif grid[row][col] != '1':\n    \t\treturn \n\n    \tgrid[row][col] = '\n    \tself.merge(grid, row+1, col)\n    \tself.merge(grid, row-1, col)\n    \tself.merge(grid, row, col+1)\n    \tself.merge(grid, row, col-1)\n",
        "output": "struct Solution;\n\nstruct UnionFind {\n    parent: Vec<usize>,\n    n: usize,\n}\n\nimpl UnionFind {\n    fn new(n: usize) -> Self {\n        let parent = (0..n).collect();\n        UnionFind { parent, n }\n    }\n\n    fn find(&mut self, i: usize) -> usize {\n        let j = self.parent[i];\n        if i == j {\n            i\n        } else {\n            let k = self.find(j);\n            self.parent[i] = k;\n            k\n        }\n    }\n\n    fn union(&mut self, mut i: usize, mut j: usize) {\n        i = self.find(i);\n        j = self.find(j);\n        if i != j {\n            self.parent[i] = j;\n            self.n -= 1;\n        }\n    }\n}\n\nimpl Solution {\n    fn num_islands(grid: Vec<Vec<char>>) -> i32 {\n        let n = grid.len();\n        if n == 0 {\n            return 0;\n        }\n        let m = grid[0].len();\n        let mut uf = UnionFind::new(n * m + 1);\n        for i in 0..n {\n            for j in 0..m {\n                let land = grid[i][j];\n                if land == '1' {\n                    if j > 0 && grid[i][j - 1] == '1' {\n                        uf.union(i * m + j, i * m + j - 1);\n                    }\n                    if i > 0 && grid[i - 1][j] == '1' {\n                        uf.union(i * m + j, (i - 1) * m + j);\n                    }\n                } else {\n                    uf.union(i * m + j, n * m);\n                }\n            }\n        }\n        (uf.n - 1) as i32\n    }\n}\n\n#[test]\nfn test() {\n    let grid: Vec<Vec<char>> = vec_vec_char![\n        ['1', '1', '1', '1', '0'],\n        ['1', '1', '0', '1', '0'],\n        ['1', '1', '0', '0', '0'],\n        ['0', '0', '0', '0', '0']\n    ];\n    assert_eq!(Solution::num_islands(grid), 1);\n    let grid: Vec<Vec<char>> = vec_vec_char![\n        ['1', '1', '0', '0', '0'],\n        ['1', '1', '0', '0', '0'],\n        ['0', '0', '1', '0', '0'],\n        ['0', '0', '0', '1', '1']\n    ];\n    assert_eq!(Solution::num_islands(grid), 3);\n}\n"
    },
    {
        "input": "\n\n\n\n\n\n\n\nclass Solution(object):\n    def reverseList(self, head):\n        \n        if not head:\n        \treturn None\n\n        prev, curr = None, head\n        while curr:\n        \ttemp = curr.next\n        \tcurr.next = prev\n        \tprev = curr\n        \tcurr = temp\n        return prev",
        "output": "struct Solution;\nuse rustgym_util::*;\n\nimpl Solution {\n    fn reverse_list(head: ListLink) -> ListLink {\n        let mut p = head;\n        let mut prev = None;\n        while let Some(mut node) = p {\n            p = node.next;\n            node.next = prev;\n            prev = Some(node);\n        }\n        prev\n    }\n}\n\n#[test]\nfn test() {\n    let head = list!();\n    let res = list!();\n    assert_eq!(Solution::reverse_list(head), res);\n    let head = list!(1);\n    let res = list!(1);\n    assert_eq!(Solution::reverse_list(head), res);\n    let head = list!(1, 2);\n    let res = list!(2, 1);\n    assert_eq!(Solution::reverse_list(head), res);\n    let head = list!(1, 2, 3);\n    let res = list!(3, 2, 1);\n    assert_eq!(Solution::reverse_list(head), res);\n}\n"
    },
    {
        "input": "\n\nclass Solution(object):\n    def productExceptSelf(self, nums):\n        \n        if not nums:\n        \treturn []\n\n        dp = [1]*len(nums)\n\n        for index in range(1,len(nums)):\n        \tdp[index] = dp[index-1]*nums[index-1]\n        print dp\n        right = 1\n        for index in range(len(nums)-1, -1, -1):\n        \tdp[index] *= right\n        \tright *= nums[index]\n        return dp",
        "output": "struct Solution;\n\nimpl Solution {\n    fn product_except_self(nums: Vec<i32>) -> Vec<i32> {\n        let n = nums.len();\n        let mut res: Vec<i32> = vec![1; n];\n        let mut product = 1;\n        for i in 0..n {\n            res[i] *= product;\n            product *= nums[i];\n        }\n        product = 1;\n        for i in (0..n).rev() {\n            res[i] *= product;\n            product *= nums[i];\n        }\n        res\n    }\n}\n\n#[test]\nfn test() {\n    let nums = vec![1, 2, 3, 4];\n    let res = vec![24, 12, 8, 6];\n    assert_eq!(Solution::product_except_self(nums), res);\n}\n"
    },
    {
        "input": "\n\nclass Solution(object):\n    def numSquares(self, n):\n        \n        mapping = {}\n        squares = [num*num for num in range(1, int(pow(n, 0.5)) + 1)]\n        for square in squares:\n        \tmapping[square] = 1\n\n        for val in range(1, n+1):\n        \tif val not in mapping:\n        \t\tmapping[val] = float('inf')\n        \t\tfor square in squares:\n        \t\t\tif square < val:\n        \t\t\t\tmapping[val] = min(mapping[val], mapping[square] + mapping[val-square])\n        return mapping[n]",
        "output": "struct Solution;\n\nimpl Solution {\n    fn num_squares(n: i32) -> i32 {\n        let n = n as usize;\n        let mut dp = vec![std::usize::MAX; n + 1];\n        dp[0] = 0;\n        for i in 1..=n {\n            let mut j = 1;\n            while j * j <= i {\n                dp[i] = dp[i].min(dp[i - j * j] + 1);\n                j += 1;\n            }\n        }\n        dp[n] as i32\n    }\n}\n\n#[test]\nfn test() {\n    let n = 12;\n    let res = 3;\n    assert_eq!(Solution::num_squares(n), res);\n    let n = 13;\n    let res = 2;\n    assert_eq!(Solution::num_squares(n), res);\n}\n"
    },
    {
        "input": "\n\nclass Solution(object):\n    def searchMatrix(self, matrix, target):\n        \n        \n        if not matrix:\n        \treturn False\n\n        left, right = 0, len(matrix[0])-1\n        while left < len(matrix) and right >= 0:\n        \tif matrix[left][right] == target:\n        \t\treturn True\n        \telif matrix[left][right] < target:\n        \t\tleft += 1\n        \telse:\n        \t\tright -= 1\n        return False",
        "output": "struct Solution;\n\nuse std::cmp::Ordering::*;\n\nimpl Solution {\n    fn search_matrix(matrix: Vec<Vec<i32>>, target: i32) -> bool {\n        let n = matrix.len();\n        if n == 0 {\n            return false;\n        }\n        let m = matrix[0].len();\n        if m == 0 {\n            return false;\n        }\n        let mut i = 0;\n        let mut j = m - 1;\n        loop {\n            match matrix[i][j].cmp(&target) {\n                Equal => {\n                    break true;\n                }\n                Greater => {\n                    if j > 0 {\n                        j -= 1;\n                    } else {\n                        break false;\n                    }\n                }\n                Less => {\n                    if i + 1 < n {\n                        i += 1;\n                    } else {\n                        break false;\n                    }\n                }\n            }\n        }\n    }\n}\n\n#[test]\nfn test() {\n    let matrix = vec_vec_i32![\n        [1, 4, 7, 11, 15],\n        [2, 5, 8, 12, 19],\n        [3, 6, 9, 16, 22],\n        [10, 13, 14, 17, 24],\n        [18, 21, 23, 26, 30]\n    ];\n    let target = 5;\n    let res = true;\n    assert_eq!(Solution::search_matrix(matrix, target), res);\n    let matrix = vec_vec_i32![\n        [1, 4, 7, 11, 15],\n        [2, 5, 8, 12, 19],\n        [3, 6, 9, 16, 22],\n        [10, 13, 14, 17, 24],\n        [18, 21, 23, 26, 30]\n    ];\n    let target = 20;\n    let res = false;\n    assert_eq!(Solution::search_matrix(matrix, target), res);\n}\n"
    },
    {
        "input": "from collections import deque\nclass Solution(object):\n    def maxSlidingWindow(self, nums, k):\n        \n        if len(nums) == 0:\n            return []\n        q = deque()\n        for i in range(k):\n            while q and nums[i] >= nums[q[-1]]:\n                q.pop()\n            q.append(i)\n            \n        result = []\n        for i in range(k, len(nums)):\n            result.append(nums[q[0]])\n            \n            while q and q[0] <= i-k:\n                q.popleft()\n            while q and nums[i] >= nums[q[-1]]:\n                q.pop()\n                \n            q.append(i)\n            \n        result.append(nums[q[0]])\n        return result \n        ",
        "output": "struct Solution;\nuse std::collections::VecDeque;\n\nimpl Solution {\n    fn max_sliding_window(nums: Vec<i32>, k: i32) -> Vec<i32> {\n        let k = k as usize;\n        let n = nums.len();\n        let mut queue: VecDeque<usize> = VecDeque::new();\n        let mut res = vec![];\n        for i in 0..n {\n            let n = queue.len();\n            for _ in 0..n {\n                let j = queue.pop_front().unwrap();\n                if i - j < k && nums[j] >= nums[i] {\n                    queue.push_back(j);\n                }\n            }\n            queue.push_back(i);\n            if i + 1 >= k {\n                res.push(nums[*queue.front().unwrap()]);\n            }\n        }\n        res\n    }\n}\n\n#[test]\nfn test() {\n    let nums = vec![1, 3, -1, -3, 5, 3, 6, 7];\n    let k = 3;\n    let res = vec![3, 3, 5, 5, 6, 7];\n    assert_eq!(Solution::max_sliding_window(nums, k), res);\n}\n"
    },
    {
        "input": "\n\nclass Solution(object):\n    def findDuplicate(self, nums):\n        \n        slow, fast = nums[0], nums[0]\n        while True:\n        \tslow = nums[slow]\n        \tfast = nums[nums[fast]]\n        \tif slow == fast:\n        \t\tbreak\n\n        num1= nums[0]\n        num2 = slow\n        while num1 != num2:\n        \tnum1 = nums[num1]\n        \tnum2 = nums[num2]\n        return num2",
        "output": "struct Solution;\n\nimpl Solution {\n    fn find_duplicate(nums: Vec<i32>) -> i32 {\n        let n = (nums.len() - 1) as i32;\n        let mut low = 1;\n        let mut high = n;\n        while low < high {\n            let mid = low + (high - low) / 2;\n            let mut count = 0;\n            for &x in &nums {\n                if x <= mid {\n                    count += 1;\n                }\n            }\n            if count <= mid {\n                low = mid + 1;\n            } else {\n                high = mid;\n            }\n        }\n        low\n    }\n}\n\n#[test]\nfn test() {\n    let nums = vec![1, 3, 4, 2, 2];\n    let res = 2;\n    assert_eq!(Solution::find_duplicate(nums), res);\n    let nums = vec![3, 1, 3, 4, 2];\n    let res = 3;\n    assert_eq!(Solution::find_duplicate(nums), res);\n}\n"
    },
    {
        "input": "class Solution(object):\n    def countPrimes(self, n):\n        \n        if n < 2:\n            return 0\n        \n        A = [0] * (n + 1)\n        count = 0\n        \n        for pointer1 in range(2, n):\n            if A[pointer1] == 0:\n                count += 1\n                pointer2 = pointer1\n                while (pointer2 + pointer1 < n):\n                    pointer2 += pointer1\n                    A[pointer2] = 1\n                    \n        return count\n        ",
        "output": "struct Solution;\nuse rustgym_util::*;\n\nimpl Solution {\n    fn remove_elements(mut head: ListLink, val: i32) -> ListLink {\n        let mut p = &mut head;\n        while p.is_some() {\n            if p.as_ref().unwrap().val == val {\n                *p = p.take().unwrap().next.take();\n            } else {\n                p = &mut p.as_mut().unwrap().next;\n            }\n        }\n        head\n    }\n}\n\n#[test]\nfn test() {\n    let input = list!(1, 2, 6, 3, 4, 5, 6);\n    let output = list!(1, 2, 3, 4, 5);\n    assert_eq!(Solution::remove_elements(input, 6), output);\n}\n"
    },
    {
        "input": "\nclass TreeNode(object):\n\tself.word = False\n\tself.children = {}\n\nclass Trie(object):\n\n    def __init__(self):\n        \n        self.root = TreeNode()\n\n    def insert(self, word):\n        \n        node = self.root\n        for char in word:\n        \tif char not in node.children:\n        \t\tnode.children[char] = TreeNode()\n        \tnode = node.children[char]\n        node.word = True\n\n    def search(self, word):\n        \n        node = self.root\n        for char in word:\n        \tif char not in node.children:\n        \t\treturn False\n        \tnode = node.children[char]\n        return node.word \n        \n\n    def startsWith(self, prefix):\n        \n        node = self.root\n        for char in prefix:\n        \tif char not in node.children:\n        \t\treturn False\n        \tnode = node.children[char]\n        return True\n        \n\n\n\n\n\n\n",
        "output": "use std::collections::HashMap;\n\n#[derive(PartialEq, Eq, Clone, Debug, Default)]\nstruct Trie {\n    children: HashMap<char, Trie>,\n    end: bool,\n}\n\nimpl Trie {\n    fn new() -> Self {\n        Self::default()\n    }\n\n    fn insert(&mut self, word: String) {\n        let mut link = self;\n        for c in word.chars() {\n            link = link.children.entry(c).or_default();\n        }\n        link.end = true;\n    }\n\n    fn search(&self, word: String) -> bool {\n        let mut link = self;\n        for c in word.chars() {\n            if let Some(child) = link.children.get(&c) {\n                link = child;\n            } else {\n                return false;\n            }\n        }\n        link.end\n    }\n    fn starts_with(&self, word: String) -> bool {\n        let mut link = self;\n        for c in word.chars() {\n            if let Some(child) = link.children.get(&c) {\n                link = child;\n            } else {\n                return false;\n            }\n        }\n        true\n    }\n}\n\n#[test]\nfn test() {\n    let mut trie = Trie::new();\n    let word = \"apple\".to_string();\n    trie.insert(word);\n    let word = \"apple\".to_string();\n    assert_eq!(trie.search(word), true);\n    let word = \"app\".to_string();\n    assert_eq!(trie.search(word), false);\n    let word = \"app\".to_string();\n    assert_eq!(trie.starts_with(word), true);\n    let word = \"app\".to_string();\n    trie.insert(word);\n    let word = \"app\".to_string();\n    assert_eq!(trie.search(word), true);\n}\n"
    },
    {
        "input": "\n\nclass Solution(object):\n    def findJudge(self, N, trust):\n        \n        if not trust:\n            return 1\n        mapping = {}\n        unique = set()\n        for truste_list in trust:\n            unique.add(truste_list[0])\n            if truste_list[1] in mapping:\n                mapping[truste_list[1]] += 1\n            else:\n                mapping[truste_list[1]] = 1\n            \n        unique_set = len(unique)\n        for key, value in mapping.items():\n            if value == unique_set:\n                return key\n        return -1\n        ",
        "output": "struct Solution;\n\nimpl Solution {\n    fn find_judge(n: i32, trust: Vec<Vec<i32>>) -> i32 {\n        let n = n as usize;\n        let mut degree = vec![0; n];\n        for edge in trust {\n            let u = (edge[0] - 1) as usize;\n            let v = (edge[1] - 1) as usize;\n            degree[v] += 1;\n            degree[u] -= 1;\n        }\n        for i in 0..n {\n            if degree[i] as usize == n - 1 {\n                return (i + 1) as i32;\n            }\n        }\n        -1\n    }\n}\n\n#[test]\nfn test() {\n    let n = 2;\n    let trust = vec_vec_i32![[1, 2]];\n    let res = 2;\n    assert_eq!(Solution::find_judge(n, trust), res);\n    let n = 3;\n    let trust = vec_vec_i32![[1, 3], [2, 3]];\n    let res = 3;\n    assert_eq!(Solution::find_judge(n, trust), res);\n    let n = 3;\n    let trust = vec_vec_i32![[1, 3], [2, 3], [3, 1]];\n    let res = -1;\n    assert_eq!(Solution::find_judge(n, trust), res);\n    let n = 3;\n    let trust = vec_vec_i32![[1, 2], [2, 3]];\n    let res = -1;\n    assert_eq!(Solution::find_judge(n, trust), res);\n    let n = 4;\n    let trust = vec_vec_i32![[1, 3], [1, 4], [2, 3], [2, 4], [4, 3]];\n    let res = 3;\n    assert_eq!(Solution::find_judge(n, trust), res);\n}\n"
    },
    {
        "input": "\n\nclass Solution:\n    def mincostTickets(self, days: 'List[int]', costs: 'List[int]') -> 'int':\n        def get_days_ago(day, ago):\n            for i in range(len(days)):\n                if days[i] > days[day-1] - ago:\n                    return i\n        out = [0] * (len(days) + 1)\n        for i in range(1, len(days) + 1):\n            out[i] = min(out[i-1] + costs[0], out[get_days_ago(i,7)] + costs[1], out[get_days_ago(i,30)] + costs[2])\n        return out[-1]\n",
        "output": "struct Solution;\n\nimpl Solution {\n    fn mincost_tickets(days: Vec<i32>, costs: Vec<i32>) -> i32 {\n        let n = days.len();\n        let mut dp: Vec<i32> = vec![];\n        let pass = vec![1, 7, 30];\n        for i in 0..n {\n            let mut mins = costs.clone();\n            for k in 0..3 {\n                for j in (0..i).rev() {\n                    if days[i] - days[j] >= pass[k] {\n                        mins[k] += dp[j];\n                        break;\n                    }\n                }\n            }\n            dp.push(*mins.iter().min().unwrap());\n        }\n        dp[n - 1]\n    }\n}\n\n#[test]\nfn test() {\n    let days = vec![1, 4, 6, 7, 8, 20];\n    let costs = vec![2, 7, 15];\n    let res = 11;\n    assert_eq!(Solution::mincost_tickets(days, costs), res);\n    let days = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 30, 31];\n    let costs = vec![2, 7, 15];\n    let res = 17;\n    assert_eq!(Solution::mincost_tickets(days, costs), res);\n}\n"
    },
    {
        "input": "\n\nclass Solution(object):\n    def sumEvenAfterQueries(self, A, queries):\n        \n        result = 0\n        for val in A:\n            if val%2 == 0:\n                result += val\n        \n        f_result = []\n        for val_index in queries:\n            val, index = val_index[0], val_index[1]\n            prev_val = A[index]\n            if prev_val%2 == 0:\n                result -= prev_val\n            new_val = prev_val + val\n            if new_val %2 == 0:\n                result += new_val\n            A[index] = new_val\n            f_result.append(result)\n        return f_result\n ",
        "output": "struct Solution;\n\nimpl Solution {\n    fn sum_even_after_queries(mut a: Vec<i32>, queries: Vec<Vec<i32>>) -> Vec<i32> {\n        let mut sum = a.iter().filter(|&x| x % 2 == 0).sum();\n        let mut res: Vec<i32> = vec![];\n        for query in queries {\n            let v = query[0];\n            let i = query[1] as usize;\n            let x = a[i];\n            let y = a[i] + v;\n            if x % 2 == 0 {\n                sum -= x;\n            }\n            if y % 2 == 0 {\n                sum += y;\n            }\n            a[i] = y;\n            res.push(sum);\n        }\n        res\n    }\n}\n\n#[test]\nfn test() {\n    let a = vec![1, 2, 3, 4];\n    let queries: Vec<Vec<i32>> = vec_vec_i32![[1, 0], [-3, 1], [-4, 0], [2, 3]];\n    let res = vec![8, 6, 2, 4];\n    assert_eq!(Solution::sum_even_after_queries(a, queries), res);\n}\n"
    },
    {
        "input": "\n\nclass Solution(object):\n    def sortedSquares(self, A):\n        \n        N = len(A)\n        j = 0\n        while j <N and A[j] < 0:\n            j += 1\n        i = j-1\n        result = []\n        while i >= 0 and j < N:\n            if A[i]**2 < A[j]**2:\n                result.append(A[i]**2)\n                i -= 1\n            else:\n                result.append(A[j]**2)\n                j += 1\n        while i>= 0:\n            result.append(A[i]**2)\n            i -= 1\n            \n        while j < N:\n            result.append(A[j]**2)\n            j += 1\n                \n        return result\n",
        "output": "struct Solution;\n\nimpl Solution {\n    fn sorted_squares(a: Vec<i32>) -> Vec<i32> {\n        let mut squared: Vec<i32> = a.iter().map(|a| a * a).collect();\n        squared.sort_unstable();\n        squared\n    }\n}\n\n#[test]\nfn test() {\n    assert_eq!(\n        Solution::sorted_squares(vec![-4, -1, 0, 3, 10]),\n        vec![0, 1, 9, 16, 100]\n    );\n    assert_eq!(\n        Solution::sorted_squares(vec![-7, -3, 2, 3, 11]),\n        vec![4, 9, 9, 49, 121]\n    );\n}\n"
    },
    {
        "input": "\n\n\n\n\n\n\n\nclass Solution(object):\n        \n    def insertIntoMaxTree(self, root, val):\n        \n        new_node = TreeNode(val)\n        if not root:\n            return new_node\n        \n        if root.val < val:\n            new_node.left = root\n            return new_node\n        \n        nrwwt = root\n        start, prev = root.right, root\n    \n        while start:\n            if(start.val > val):\n                prev = start\n                start = start.right\n            else:\n                break\n            \n\n        prev.right = new_node\n        if not start:\n            new_node.right = start\n        else:\n            new_node.left = start\n        \n        return root\n        \n",
        "output": "struct Solution;\nuse rustgym_util::*;\n\ntrait Postorder {\n    fn insert(self, val: i32) -> Self;\n}\n\nimpl Postorder for TreeLink {\n    fn insert(self, val: i32) -> Self {\n        if let Some(node) = self {\n            let node_val = node.borrow().val;\n            if node_val < val {\n                tree!(val, Some(node), None)\n            } else {\n                let right = node.borrow_mut().right.take();\n                node.borrow_mut().right = right.insert(val);\n                Some(node)\n            }\n        } else {\n            tree!(val)\n        }\n    }\n}\n\nimpl Solution {\n    fn insert_into_max_tree(root: TreeLink, val: i32) -> TreeLink {\n        root.insert(val)\n    }\n}\n\n#[test]\nfn test() {\n    let root = tree!(4, tree!(1), tree!(3, tree!(2), None));\n    let val = 5;\n    let res = tree!(5, tree!(4, tree!(1), tree!(3, tree!(2), None)), None);\n    assert_eq!(Solution::insert_into_max_tree(root, val), res);\n    let root = tree!(5, tree!(2, None, tree!(1)), tree!(4));\n    let val = 3;\n    let res = tree!(5, tree!(2, None, tree!(1)), tree!(4, None, tree!(3)));\n    assert_eq!(Solution::insert_into_max_tree(root, val), res);\n    let root = tree!(5, tree!(2, None, tree!(1)), tree!(3));\n    let val = 4;\n    let res = tree!(5, tree!(2, None, tree!(1)), tree!(4, tree!(3), None));\n    assert_eq!(Solution::insert_into_max_tree(root, val), res);\n}\n"
    },
    {
        "input": "\n\nclass Solution:\n    def minKBitFlips(self, a: 'List[int]', k: 'int') -> 'int':\n        from collections import deque\n        q = deque()\n        res = 0\n        for i in range(len(a)):\n            if len(q) % 2 != 0:\n                if a[i] == 1:\n                    res += 1\n                    q.append(i+k-1)\n            else:\n                if a[i] == 0:\n                    res += 1\n                    q.append(i+k-1)\n            if q and q[0] == i: q.popleft()\n            if q and q[-1] >= len(a): return -1\n        return res    ",
        "output": "struct Solution;\n\nuse std::collections::VecDeque;\n\nimpl Solution {\n    fn min_k_bit_flips(a: Vec<i32>, k: i32) -> i32 {\n        let n = a.len();\n        let k = k as usize;\n        let mut queue: VecDeque<usize> = VecDeque::new();\n        let mut res = 0;\n        for i in 0..n {\n            if let Some(&j) = queue.front() {\n                if j + k == i {\n                    queue.pop_front().unwrap();\n                }\n            }\n            if i + k <= n {\n                if (queue.len() as i32 + a[i]) % 2 == 0 {\n                    queue.push_back(i);\n                    res += 1;\n                }\n            } else {\n                if (queue.len() as i32 + a[i]) % 2 == 0 {\n                    return -1;\n                }\n            }\n        }\n        res\n    }\n}\n\n#[test]\nfn test() {\n    let a = vec![0, 1, 0];\n    let k = 1;\n    let res = 2;\n    assert_eq!(Solution::min_k_bit_flips(a, k), res);\n    let a = vec![1, 1, 0];\n    let k = 2;\n    let res = -1;\n    assert_eq!(Solution::min_k_bit_flips(a, k), res);\n    let a = vec![0, 0, 0, 1, 0, 1, 1, 0];\n    let k = 3;\n    let res = 3;\n    assert_eq!(Solution::min_k_bit_flips(a, k), res);\n}\n"
    },
    {
        "input": "\n\nclass Solution(object):\n    def strWithout3a3b(self, A, B):\n        \n        \n        result = ''\n        if A > B:\n            while B > 0 and A > 0:\n                if A-B >= 3:\n                    if A > 1:\n                        result += 'aab'\n                        A -= 2\n                    else:\n                        result += 'ab'\n                        A -= 1\n                    B -= 1\n                else:\n                    result += 'ab'\n                    A -= 1\n                    B -= 1\n            if A > 0:\n                result += 'a'*A\n            if B > 0:\n                result += 'b'*B\n        else:\n            while B > 0 and A > 0:\n                if B-A >= 3:\n                    if B > 1:\n                        result += 'bba'\n                        B -= 2\n                    else:\n                        result += 'ba'\n                        B -= 1\n                    A -= 1\n                else:\n                    result += 'ba'\n                    A -= 1\n                    B -= 1\n            if A > 0:\n                result += 'a'*A\n            if B > 0:\n                result += 'b'*B\n                \n        return result\n",
        "output": "struct Solution;\n\nimpl Solution {\n    fn str_without3a3b(mut a: i32, mut b: i32) -> String {\n        if a == b {\n            let mut res = \"\".to_string();\n            for _ in 0..a {\n                res += \"ab\";\n            }\n            return res;\n        }\n        if a > b {\n            let mut res = \"\".to_string();\n            while a > 0 {\n                res += \"a\";\n                a -= 1;\n                if a > b {\n                    res += \"a\";\n                    a -= 1;\n                }\n                if b > 0 {\n                    res += \"b\";\n                    b -= 1;\n                }\n            }\n            return res;\n        }\n        if b > a {\n            let mut res = \"\".to_string();\n            while b > 0 {\n                res += \"b\";\n                b -= 1;\n                if b > a {\n                    res += \"b\";\n                    b -= 1;\n                }\n                if a > 0 {\n                    res += \"a\";\n                    a -= 1;\n                }\n            }\n            return res;\n        }\n        \"\".to_string()\n    }\n}\n\n#[test]\nfn test() {\n    let a = 1;\n    let b = 2;\n    let res = \"bab\".to_string();\n    assert_eq!(Solution::str_without3a3b(a, b), res);\n}\n"
    },
    {
        "input": "\n\nimport bisect\nclass TimeMap(object):\n\n    def __init__(self):\n        \n        self.time_dict = {}\n        self.key_map = {}\n        \n\n    def set(self, key, value, timestamp):\n        \n        if key in self.time_dict:\n            self.time_dict[key].append(timestamp)\n            self.key_map[key].append(value)\n        else:\n            self.time_dict[key] = [timestamp]\n            self.key_map[key] = [value]\n        \n        \n        \n\n    def get(self, key, timestamp):\n        \n        if key in self.time_dict:\n            t_values = self.time_dict[key]\n            index = bisect.bisect_right(t_values, timestamp)\n            if index-1 == len(t_values) or index == 0:\n                return ''\n\n            return self.key_map[key][index-1]\n        \n\n\n\n\n\n",
        "output": "use std::collections::HashMap;\n\ntype Pair = (i32, String);\n\n#[derive(Default)]\nstruct TimeMap {\n    map: HashMap<String, Vec<Pair>>,\n}\n\nimpl TimeMap {\n    fn new() -> Self {\n        TimeMap {\n            map: HashMap::new(),\n        }\n    }\n    fn set(&mut self, key: String, value: String, timestamp: i32) {\n        self.map.entry(key).or_default().push((timestamp, value));\n    }\n    fn get(&mut self, key: String, timestamp: i32) -> String {\n        let values = self.map.entry(key).or_default();\n        match values.binary_search_by_key(&timestamp, |v| v.0) {\n            Ok(i) => values[i].1.to_string(),\n            Err(i) => {\n                if i > 0 {\n                    values[i - 1].1.to_string()\n                } else {\n                    \"\".to_string()\n                }\n            }\n        }\n    }\n}\n\n#[test]\nfn test() {\n    let mut kv: TimeMap = TimeMap::new();\n    kv.set(\"foo\".to_string(), \"bar\".to_string(), 1);\n    assert_eq!(kv.get(\"foo\".to_string(), 1), \"bar\".to_string());\n    assert_eq!(kv.get(\"foo\".to_string(), 3), \"bar\".to_string());\n    kv.set(\"foo\".to_string(), \"bar2\".to_string(), 4);\n    assert_eq!(kv.get(\"foo\".to_string(), 4), \"bar2\".to_string());\n    assert_eq!(kv.get(\"foo\".to_string(), 5), \"bar2\".to_string());\n}\n"
    },
    {
        "input": "\n\n\n\n\n\n\n\nclass Solution(object):\n    def smallestFromLeaf(self, root):\n        \n        self.result = \"~\"\n        \n        def dfs(node, A):\n            if node:\n                A.append(chr(node.val + ord('a')))\n                if not node.left and not node.right:\n                    self.result = min(self.result, \"\".join(reversed(A)))\n\n                dfs(node.left, A)\n                dfs(node.right, A)\n                A.pop()\n        dfs(root, [])\n        return self.result\n",
        "output": "struct Solution;\nuse rustgym_util::*;\n\ntrait Preorder {\n    fn preorder(&self, cur: &mut Vec<char>, min: &mut String);\n}\n\nimpl Preorder for TreeLink {\n    fn preorder(&self, cur: &mut Vec<char>, min: &mut String) {\n        if let Some(node) = self {\n            let node = node.borrow();\n            let val = (node.val as u8 + b'a') as char;\n            cur.push(val);\n            if node.left.is_none() && node.right.is_none() {\n                let s: String = cur.iter().rev().copied().collect();\n                if min.is_empty() {\n                    *min = s;\n                } else {\n                    if s < *min {\n                        *min = s;\n                    }\n                }\n            }\n            node.left.preorder(cur, min);\n            node.right.preorder(cur, min);\n            cur.pop();\n        }\n    }\n}\n\nimpl Solution {\n    fn smallest_from_leaf(root: TreeLink) -> String {\n        let mut cur: Vec<char> = vec![];\n        let mut res: String = \"\".to_string();\n        root.preorder(&mut cur, &mut res);\n        res\n    }\n}\n\n#[test]\nfn test() {\n    let root = tree!(\n        0,\n        tree!(1, tree!(3), tree!(4)),\n        tree!(2, tree!(3), tree!(4))\n    );\n    let res = \"dba\".to_string();\n    assert_eq!(Solution::smallest_from_leaf(root), res);\n    let root = tree!(\n        25,\n        tree!(1, tree!(1), tree!(3)),\n        tree!(3, tree!(0), tree!(2))\n    );\n    let res = \"adz\".to_string();\n    assert_eq!(Solution::smallest_from_leaf(root), res);\n    let root = tree!(\n        2,\n        tree!(2, None, tree!(1, tree!(0), None)),\n        tree!(1, tree!(0), None)\n    );\n    let res = \"abc\".to_string();\n    assert_eq!(Solution::smallest_from_leaf(root), res);\n}\n"
    },
    {
        "input": "\n\nclass Solution(object):\n    def minFlipsMonoIncr(self, S):\n        \n        ones = [0]\n        for char in S:\n            ones.append(ones[-1] + int(char))\n        \n        result = float('inf')\n        for index in range(len(ones)):\n            zeroes = len(S) - index - (ones[-1]-ones[index])\n            result = min(zeroes+ones[index], result)\n        return result\n",
        "output": "struct Solution;\n\nimpl Solution {\n    fn min_flips_mono_incr(s: String) -> i32 {\n        let n = s.len();\n        let s: Vec<char> = s.chars().collect();\n        let mut left = vec![0; n];\n        let mut ones = 0;\n        let mut right = vec![0; n];\n        let mut zeros = 0;\n        for i in 0..n {\n            left[i] = ones;\n            if s[i] == '1' {\n                ones += 1;\n            }\n        }\n        for i in (0..n).rev() {\n            right[i] = zeros;\n            if s[i] == '0' {\n                zeros += 1;\n            }\n        }\n        let mut res = std::i32::MAX;\n        for i in 0..n {\n            res = res.min(left[i] + right[i]);\n        }\n        res\n    }\n}\n\n#[test]\nfn test() {\n    let s = \"00110\".to_string();\n    let res = 1;\n    assert_eq!(Solution::min_flips_mono_incr(s), res);\n    let s = \"010110\".to_string();\n    let res = 2;\n    assert_eq!(Solution::min_flips_mono_incr(s), res);\n    let s = \"00011000\".to_string();\n    let res = 2;\n    assert_eq!(Solution::min_flips_mono_incr(s), res);\n}\n"
    },
    {
        "input": "\n\nclass Solution(object):\n    def addToArrayForm(self, A, K):\n        \n        arr_k = []\n        while K >0:\n            digit = K%10\n            K /= 10\n            arr_k.append(digit)\n            \n        arr_k.reverse()\n        if len(arr_k) > len(A):\n            A, arr_k = arr_k, A\n        \n        sum_arr = [0]*len(A)\n        i, j = len(A)-1, len(arr_k)-1\n        k = len(A) -1\n        digit_sum, carry = 0, 0\n        while j >= 0:\n            curr_sum = A[i] + arr_k[j] + carry\n            sum_arr[k] = (curr_sum%10)\n            carry = curr_sum//10\n            i -= 1\n            k -= 1\n            j -= 1\n        \n        while i >= 0:\n            curr_sum = A[i] + carry\n            sum_arr[k] = (curr_sum%10)\n            carry =curr_sum//10\n            i -= 1\n            k -= 1\n            \n        if carry:\n            sum_arr = [carry] + sum_arr\n        return sum_arr        \n",
        "output": "struct Solution;\n\nimpl Solution {\n    fn add_to_array_form(mut a: Vec<i32>, mut k: i32) -> Vec<i32> {\n        let mut i = a.len() - 1;\n        while k > 0 {\n            let sum = a[i] + k;\n            a[i] = sum % 10;\n            k = sum / 10;\n            if i > 0 {\n                i -= 1;\n            } else {\n                a.insert(0, 0);\n            }\n        }\n        if a.len() > 1 && a[0] == 0 {\n            a.remove(0);\n        }\n        a\n    }\n}\n\n#[test]\nfn test() {\n    let a = vec![1, 2, 0, 0];\n    let k = 34;\n    let res = vec![1, 2, 3, 4];\n    assert_eq!(Solution::add_to_array_form(a, k), res);\n    let a = vec![2, 7, 4];\n    let k = 181;\n    let res = vec![4, 5, 5];\n    assert_eq!(Solution::add_to_array_form(a, k), res);\n    let a = vec![2, 1, 5];\n    let k = 806;\n    let res = vec![1, 0, 2, 1];\n    assert_eq!(Solution::add_to_array_form(a, k), res);\n    let a = vec![9, 9, 9, 9, 9, 9, 9, 9, 9, 9];\n    let k = 1;\n    let res = vec![1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n    assert_eq!(Solution::add_to_array_form(a, k), res);\n}\n"
    },
    {
        "input": "\n\nclass Solution(object):\n    def brokenCalc(self, X, Y):\n        \n        if X == Y:\n            return 0\n        if X > Y:\n            return X-Y\n        if(Y%2 == 1):\n            return 1 + self.brokenCalc(X, Y+1)\n        else:\n            return 1 + self.brokenCalc(X, Y/2)\n",
        "output": "struct Solution;\n\nimpl Solution {\n    fn broken_calc(x: i32, mut y: i32) -> i32 {\n        let mut res = 0;\n        while y > x {\n            if y % 2 == 0 {\n                y /= 2;\n            } else {\n                y += 1;\n            }\n            res += 1;\n        }\n        res + x - y\n    }\n}\n\n#[test]\nfn test() {\n    let x = 2;\n    let y = 3;\n    let res = 2;\n    assert_eq!(Solution::broken_calc(x, y), res);\n    let x = 5;\n    let y = 8;\n    let res = 2;\n    assert_eq!(Solution::broken_calc(x, y), res);\n    let x = 3;\n    let y = 10;\n    let res = 3;\n    assert_eq!(Solution::broken_calc(x, y), res);\n    let x = 1024;\n    let y = 1;\n    let res = 1023;\n    assert_eq!(Solution::broken_calc(x, y), res);\n}\n"
    },
    {
        "input": "\n\nclass Solution(object):\n    def valid(self, row, col, row_size, col_size):\n        return row >= 0 and col >= 0 and row < row_size and col < col_size\n    \n    def orangesRotting(self, grid):\n        \n        queue = []\n        for row_index in range(len(grid)):\n        \tfor col_index in range(len(grid[0])):\n        \t\tif grid[row_index][col_index] == 2:\n        \t\t\tqueue.append((row_index, col_index))\n\n        result = 0\n        queue.append((-1, -1))\n        while queue:\n        \tflag = False\n        \tprint queue\n        \twhile(queue[0][0] != -1 and queue[0][1] != -1):\n        \t\t(row, col) = queue[0]\n        \t\tif self.valid(row+1, col, len(grid), len(grid[0])) and grid[row+1][col] == 1 :\n        \t\t\tif not flag:\n        \t\t\t\tresult += 1\n        \t\t\t\tflag =True\n        \t\t\tgrid[row+1][col] = 2\n        \t\t\trow += 1\n        \t\t\tqueue.append((row, col))\n        \t\t\trow -= 1\n        \t\tif self.valid(row-1, col, len(grid), len(grid[0])) and grid[row-1][col] == 1 :\n        \t\t\tif not flag:\n        \t\t\t\tresult += 1\n        \t\t\t\tflag =True\n        \t\t\tgrid[row-1][col] = 2\n        \t\t\trow -= 1\n        \t\t\tqueue.append((row, col))\n        \t\t\trow += 1\n        \t\tif self.valid(row, col+1, len(grid), len(grid[0])) and grid[row][col+1] == 1 :\n        \t\t\tif not flag:\n        \t\t\t\tresult += 1\n        \t\t\t\tflag =True\n        \t\t\tgrid[row][col+1] = 2\n        \t\t\tcol += 1\n        \t\t\tqueue.append((row, col))\n        \t\t\tcol -= 1\n        \t\tif self.valid(row, col-1, len(grid), len(grid[0])) and grid[row][col-1] == 1 :\n        \t\t\tif not flag:\n        \t\t\t\tresult += 1\n        \t\t\t\tflag =True\n        \t\t\tgrid[row][col-1] = 2\n        \t\t\tcol -= 1\n        \t\t\tqueue.append((row, col))\n        \t\t\tcol += 1\n        \t\tqueue.pop(0)\n        \tqueue.pop(0)\n        \tif queue:\n        \t\tqueue.append((-1, -1))\n        for row_index in range(len(grid)):\n        \tfor col_index in range(len(grid[0])):\n        \t\tif grid[row_index][col_index] == 1:\n        \t\t\treturn -1\n        return result\n",
        "output": "struct Solution;\n\nuse std::collections::VecDeque;\n\nstruct Orange {\n    r: usize,\n    c: usize,\n    t: i32,\n}\n\nimpl Solution {\n    fn oranges_rotting(mut grid: Vec<Vec<i32>>) -> i32 {\n        let n = grid.len();\n        let m = grid[0].len();\n        let mut queue: VecDeque<Orange> = VecDeque::new();\n        for i in 0..n {\n            for j in 0..m {\n                if grid[i][j] == 2 {\n                    queue.push_back(Orange { r: i, c: j, t: 0 });\n                }\n            }\n        }\n        let mut res = 0;\n        while let Some(o) = queue.pop_front() {\n            let r = o.r;\n            let c = o.c;\n            let t = o.t;\n            if r > 0 && grid[r - 1][c] == 1 {\n                grid[r - 1][c] = 2;\n                res = i32::max(res, t + 1);\n                queue.push_back(Orange {\n                    r: r - 1,\n                    c,\n                    t: t + 1,\n                });\n            }\n            if r < n - 1 && grid[r + 1][c] == 1 {\n                grid[r + 1][c] = 2;\n                res = i32::max(res, t + 1);\n                queue.push_back(Orange {\n                    r: r + 1,\n                    c,\n                    t: t + 1,\n                });\n            }\n            if c > 0 && grid[r][c - 1] == 1 {\n                grid[r][c - 1] = 2;\n                res = i32::max(res, t + 1);\n                queue.push_back(Orange {\n                    r,\n                    c: c - 1,\n                    t: t + 1,\n                });\n            }\n            if c < m - 1 && grid[r][c + 1] == 1 {\n                grid[r][c + 1] = 2;\n                res = i32::max(res, t + 1);\n                queue.push_back(Orange {\n                    r,\n                    c: c + 1,\n                    t: t + 1,\n                });\n            }\n        }\n        for i in 0..n {\n            for j in 0..m {\n                if grid[i][j] == 1 {\n                    return -1;\n                }\n            }\n        }\n        res\n    }\n}\n\n#[test]\nfn test() {\n    let grid: Vec<Vec<i32>> = vec_vec_i32![[2, 1, 1], [1, 1, 0], [0, 1, 1]];\n    assert_eq!(Solution::oranges_rotting(grid), 4);\n    let grid: Vec<Vec<i32>> = vec_vec_i32![[2, 1, 1], [0, 1, 1], [1, 0, 1]];\n    assert_eq!(Solution::oranges_rotting(grid), -1);\n    let grid: Vec<Vec<i32>> = vec_vec_i32![[0, 2]];\n    assert_eq!(Solution::oranges_rotting(grid), 0);\n}\n"
    },
    {
        "input": "\n\nclass Solution(object):\n    def numRookCaptures(self, board):\n        \n        result = 0\n        rook_index = (0, 0)\n        for row in range(len(board)):\n            for col in range(len(board[0])):\n                if board[row][col] == 'R':\n                    rook_index = (row, col)\n                    break\n               \n        flag = True\n        col = rook_index[1]-1\n        pawn = 0\n        while col >= 0:\n            if board[rook_index[0]][col] == 'B':\n                flag = False\n                break\n            if board[rook_index[0]][col] == 'p':\n                pawn += 1\n                break\n            col -= 1\n        if flag and pawn != 0:\n            result += 1\n            \n        flag = True\n        col = rook_index[1]+1\n        pawn = 0\n        while col < len(board[0]):\n            if board[rook_index[0]][col] == 'B':\n                flag = False\n                break\n            if board[rook_index[0]][col] == 'p':\n                pawn += 1\n                break\n            col += 1\n            \n        if flag and pawn != 0:\n            result += 1\n        \n        flag = True\n        row = rook_index[0]+1\n        pawn = 0\n        while row < len(board):\n            if board[row][rook_index[1]] == 'B':\n                flag = False\n                break\n                \n            if board[row][rook_index[1]] == 'p':\n                pawn += 1\n                break\n            row += 1\n            \n        if flag and pawn != 0:\n            result += 1\n            \n        pawn = 0\n        flag = True\n        row = rook_index[0]-1\n        while row >= 0:\n            if board[row][rook_index[1]] == 'B':\n                flag = False\n                break\n            if board[row][rook_index[1]] == 'p':\n                pawn += 1\n                break\n            row -= 1\n        if flag and pawn != 0:\n            result += 1\n        \n        return result",
        "output": "struct Solution;\n\nstruct Chess {\n    r: usize,\n    c: usize,\n}\n\nenum Direction {\n    Right,\n    Down,\n    Left,\n    Up,\n}\n\nimpl Solution {\n    fn search_rook(board: &[Vec<char>]) -> Chess {\n        for r in 0..8 {\n            for c in 0..8 {\n                if board[r][c] == 'R' {\n                    return Chess { r, c };\n                }\n            }\n        }\n        unreachable!()\n    }\n    fn search_pawn(board: &[Vec<char>], rook: &Chess, direction: Direction) -> bool {\n        let mut r = rook.r;\n        let mut c = rook.c;\n\n        match direction {\n            Direction::Right => {\n                while c + 1 < 8 && board[r][c + 1] != 'B' {\n                    c += 1;\n                    if board[r][c] == 'p' {\n                        return true;\n                    }\n                }\n            }\n            Direction::Down => {\n                while r + 1 < 8 && board[r + 1][c] != 'B' {\n                    r += 1;\n                    if board[r][c] == 'p' {\n                        return true;\n                    }\n                }\n            }\n            Direction::Left => {\n                while c > 0 && board[r][c - 1] != 'B' {\n                    c -= 1;\n                    if board[r][c] == 'p' {\n                        return true;\n                    }\n                }\n            }\n            Direction::Up => {\n                while r > 0 && board[r - 1][c] != 'B' {\n                    r -= 1;\n                    if board[r][c] == 'p' {\n                        return true;\n                    }\n                }\n            }\n        }\n        false\n    }\n    fn num_rook_captures(board: Vec<Vec<char>>) -> i32 {\n        let mut sum = 0;\n        let rook: Chess = Self::search_rook(&board);\n        for direction in vec![\n            Direction::Right,\n            Direction::Down,\n            Direction::Left,\n            Direction::Up,\n        ] {\n            if Self::search_pawn(&board, &rook, direction) {\n                sum += 1;\n            }\n        }\n        sum\n    }\n}\n\n#[test]\nfn test() {\n    let board = vec_vec_char![\n        ['.', '.', '.', '.', '.', '.', '.', '.'],\n        ['.', '.', '.', 'p', '.', '.', '.', '.'],\n        ['.', '.', '.', 'R', '.', '.', '.', 'p'],\n        ['.', '.', '.', '.', '.', '.', '.', '.'],\n        ['.', '.', '.', '.', '.', '.', '.', '.'],\n        ['.', '.', '.', 'p', '.', '.', '.', '.'],\n        ['.', '.', '.', '.', '.', '.', '.', '.'],\n        ['.', '.', '.', '.', '.', '.', '.', '.']\n    ];\n    let res = 3;\n    assert_eq!(Solution::num_rook_captures(board), res);\n    let board = vec_vec_char![\n        ['.', '.', '.', '.', '.', '.', '.', '.'],\n        ['.', 'p', 'p', 'p', 'p', 'p', '.', '.'],\n        ['.', 'p', 'p', 'B', 'p', 'p', '.', '.'],\n        ['.', 'p', 'B', 'R', 'B', 'p', '.', '.'],\n        ['.', 'p', 'p', 'B', 'p', 'p', '.', '.'],\n        ['.', 'p', 'p', 'p', 'p', 'p', '.', '.'],\n        ['.', '.', '.', '.', '.', '.', '.', '.'],\n        ['.', '.', '.', '.', '.', '.', '.', '.']\n    ];\n    let res = 0;\n    assert_eq!(Solution::num_rook_captures(board), res);\n    let board = vec_vec_char![\n        ['.', '.', '.', '.', '.', '.', '.', '.'],\n        ['.', '.', '.', 'p', '.', '.', '.', '.'],\n        ['.', '.', '.', 'p', '.', '.', '.', '.'],\n        ['p', 'p', '.', 'R', '.', 'p', 'B', '.'],\n        ['.', '.', '.', '.', '.', '.', '.', '.'],\n        ['.', '.', '.', 'B', '.', '.', '.', '.'],\n        ['.', '.', '.', 'p', '.', '.', '.', '.'],\n        ['.', '.', '.', '.', '.', '.', '.', '.']\n    ];\n    let res = 3;\n    assert_eq!(Solution::num_rook_captures(board), res);\n}\n"
    },
    {
        "input": "\n\n\n\n\n\n\n\n\nclass Solution(object):\n    def adjacent(self, root, node1, node2):\n            if not root:\n                return False\n            \n            value = False\n            if (root.right and root.left):\n                value = ((root.left.val == node1 and root.right.val == node2) or \n                         (root.left.val == node2 and root.right.val == node1))\n                \n            return (value or\n                   self.adjacent(root.left, node1, node2) or\n                   self.adjacent(root.right, node1, node2))\n        \n    def _level(self, root, node, level):\n            if not root:\n                return 0\n            if root.val == node:\n                return level\n            \n            left_level = self._level(root.left, node, level+1)\n            if left_level != 0:\n                return left_level\n            return self._level(root.right, node, level+1)\n        \n    def isCousins(self, root, x, y):\n        \n        if ((self._level(root, x, 1) == self._level(root, y, 1)) and not self.adjacent(root, x, y)):\n            return True\n        return False\n",
        "output": "struct Solution;\nuse rustgym_util::*;\n\ntrait Preorder {\n    fn preorder(&self, depth: usize, parent: i32, res: &mut Option<(usize, i32)>, v: i32);\n}\n\nimpl Preorder for TreeLink {\n    fn preorder(&self, depth: usize, parent: i32, res: &mut Option<(usize, i32)>, v: i32) {\n        if res.is_some() {\n            return;\n        }\n        if let Some(node) = self {\n            let node = node.borrow();\n            let val = node.val;\n            if v == val {\n                *res = Some((depth, parent));\n            }\n            node.left.preorder(depth + 1, val, res, v);\n            node.right.preorder(depth + 1, val, res, v);\n        }\n    }\n}\n\nimpl Solution {\n    fn is_cousins(root: TreeLink, x: i32, y: i32) -> bool {\n        let mut rx: Option<(usize, i32)> = None;\n        let mut ry: Option<(usize, i32)> = None;\n        root.preorder(0, 0, &mut rx, x);\n        root.preorder(0, 0, &mut ry, y);\n        if let (Some((dx, px)), Some((dy, py))) = (rx, ry) {\n            dx == dy && px != py\n        } else {\n            false\n        }\n    }\n}\n\n#[test]\nfn test() {\n    let root = tree!(1, tree!(2, tree!(4), None), tree!(3));\n    let x = 4;\n    let y = 3;\n    let res = false;\n    assert_eq!(Solution::is_cousins(root, x, y), res);\n    let root = tree!(1, tree!(2, None, tree!(4)), tree!(3, None, tree!(5)));\n    let x = 5;\n    let y = 4;\n    let res = true;\n    assert_eq!(Solution::is_cousins(root, x, y), res);\n    let root = tree!(1, tree!(2, None, tree!(4)), tree!(3));\n    let x = 2;\n    let y = 3;\n    let res = false;\n    assert_eq!(Solution::is_cousins(root, x, y), res);\n}\n"
    },
    {
        "input": "\n\nclass Solution(object):\n    def equationsPossible(self, equations):\n        \n        equal_list, unequal_list = [], []\n        for equation in equations:\n            x, y = equation[0], equation[3]\n            if '==' in equation:\n                if not equal_list:\n                    equal_list.append(x+y)\n                else:\n                    found = False\n                    for index in range(0, len(equal_list)):\n                        val = equal_list[index]\n                        if x in val or y in val:\n                            val = val+x+y\n                            equal_list[index] = val\n                            found = True\n                    if not found:\n                        equal_list.append(x+y)\n            else:\n                if x == y:\n                    return False\n                unequal_list.append([x, y])\n        \n        for val in unequal_list:\n            for equal in equal_list:\n                if val[0] in equal and val[1] in equal:\n                    return False\n        return True\n",
        "output": "struct Solution;\n\nstruct UnionFind {\n    parent: Vec<usize>,\n    n: usize,\n}\n\nimpl UnionFind {\n    fn new(n: usize) -> Self {\n        let parent = (0..n).collect();\n        UnionFind { parent, n }\n    }\n\n    fn find(&mut self, i: usize) -> usize {\n        let j = self.parent[i];\n        if i == j {\n            j\n        } else {\n            let k = self.find(j);\n            self.parent[i] = k;\n            k\n        }\n    }\n\n    fn union(&mut self, i: usize, j: usize) {\n        let i = self.find(i);\n        let j = self.find(j);\n        if i != j {\n            self.parent[i] = j;\n            self.n -= 1;\n        }\n    }\n}\n\nimpl Solution {\n    fn equations_possible(equations: Vec<String>) -> bool {\n        let mut uf = UnionFind::new(26);\n        let mut pairs: Vec<(usize, usize)> = vec![];\n        for equation in equations {\n            let s: Vec<char> = equation.chars().collect();\n            let i = (s[0] as u8 - b'a') as usize;\n            let j = (s[3] as u8 - b'a') as usize;\n            if s[1] == '=' {\n                uf.union(i, j);\n            } else {\n                pairs.push((i, j));\n            }\n        }\n        for pair in pairs {\n            let i = pair.0;\n            let j = pair.1;\n            if uf.find(i) == uf.find(j) {\n                return false;\n            }\n        }\n        true\n    }\n}\n\n#[test]\nfn test() {\n    let equations = vec_string![\"a==b\", \"b!=a\"];\n    let res = false;\n    assert_eq!(Solution::equations_possible(equations), res);\n    let equations = vec_string![\"b==a\", \"a==b\"];\n    let res = true;\n    assert_eq!(Solution::equations_possible(equations), res);\n    let equations = vec_string![\"a==b\", \"b==c\", \"a==c\"];\n    let res = true;\n    assert_eq!(Solution::equations_possible(equations), res);\n    let equations = vec_string![\"a==b\", \"b!=c\", \"c==a\"];\n    let res = false;\n    assert_eq!(Solution::equations_possible(equations), res);\n    let equations = vec_string![\"c==c\", \"b==d\", \"x!=z\"];\n    let res = true;\n    assert_eq!(Solution::equations_possible(equations), res);\n}\n"
    },
    {
        "input": "\n\nclass Solution(object):\n    def bitwiseComplement(self, N):\n        \n        if N == 0:\n            return 1\n        import math\n        bits = (int)(math.floor(math.log(N) /math.log(2))) + 1\n        return ((1 << bits) - 1) ^ N",
        "output": "struct Solution;\n\nimpl Solution {\n    fn bitwise_complement(n: i32) -> i32 {\n        if n == 0 {\n            return 1;\n        }\n        let mut mask = !0;\n        while mask & n != 0 {\n            mask <<= 1;\n        }\n        mask = !mask;\n        mask ^ n\n    }\n}\n\n#[test]\nfn test() {\n    assert_eq!(Solution::bitwise_complement(5), 2);\n    assert_eq!(Solution::bitwise_complement(7), 0);\n    assert_eq!(Solution::bitwise_complement(10), 5);\n    assert_eq!(Solution::bitwise_complement(0), 1);\n}\n"
    },
    {
        "input": "\n\nclass Suffix(object):\n\tdef __init__(self):\n\t\tself.index = 0\n\t\tself.first_rank = -1\n\t\tself.adjacent_rank = -1\n\n\tdef __lt__(self, other):\n\t\tif self.first_rank == other.first_rank:\n\t\t\treturn self.adjacent_rank < other.adjacent_rank\n\t\treturn self.first_rank < other.first_rank\n        \ndef create_suffix_array(s):\n\tN = len(s)\n\tsuffix_array = []\n\n\tfor index, char in enumerate(s):\n\t\tsuffix_obj = Suffix()\n\t\tsuffix_obj.index = index\n\t\tsuffix_obj.first_rank = ord(char)-ord('a')\n\t\tsuffix_obj.adjacent_rank = ord(s[index+1])-ord('a') if (index+1 < N) else -1\n\t\tsuffix_array.append(suffix_obj)\n\n\tsuffix_array.sort()\n\n\tno_char = 4\n\tindex_map = {}\n\twhile no_char < 2*N:\n\t\trank = 0\n\t\tprev_rank, suffix_array[0].first_rank = suffix_array[0].first_rank, rank\n\t\tindex_map[suffix_array[0].index] = 0\n\n\t\tfor index in range(1, N):\n\t\t\tif suffix_array[index].first_rank == prev_rank and suffix_array[index].adjacent_rank == suffix_array[index-1].adjacent_rank:\n\t\t\t\tsuffix_array[index].first_rank = rank\n\t\t\telse:\n\t\t\t\trank += 1\n\t\t\t\tprev_rank, suffix_array[index].first_rank = suffix_array[index].first_rank, rank\n\t\t\tindex_map[suffix_array[index].index] = index\n\n\t\tfor index in range(N):\n\t\t\tadjacent_index = suffix_array[index].index + (no_char/2)\n\t\t\tsuffix_array[index].adjacent_rank = suffix_array[index_map[adjacent_index]] if adjacent_index < N else -1\n\n\t\tsuffix_array.sort()\n\t\tno_char *= 2    \n\n\treturn [suffix.index for suffix in suffix_array]\n\ndef lcp_w_suffix_str(array, s):\n\tN = len(array)\n\n\tlcp_array = [0]*N\n\tinv_suffix = [0]*N\n\n\tfor index in range(N):\n\t\tinv_suffix[array[index]] = index\n\n\tmaxLen = 0\n\n\tfor index in range(N):\n\t\tif inv_suffix[index] == N-1:\n\t\t\tmaxLen = 0\n\t\t\tcontinue\n\n\t\tindex_j = array[inv_suffix[index]+1]\n\t\twhile(index+maxLen < N and index_j+maxLen < N and s[index+maxLen] == s[index_j+maxLen]):\n\t\t\tmaxLen += 1\n\n\t\tlcp_array[inv_suffix[index]] = maxLen\n\n\t\tif maxLen > 0:\n\t\t\tmaxLen -= 1\n\n\treturn lcp_array\n\n\t\t\nclass Solution(object):\n    def longestDupSubstring(self, S):\n        \n        suffix_array = create_suffix_array(S)\n        lcp_array = lcp_w_suffix_str(suffix_array, S)\n        \n        start, end = 0, 0\n\t\t\n        for index in range(len(S)):\n            if lcp_array[index] > end:\n                end = lcp_array[index]\n                start = suffix_array[index]\n            \n        if end == 0:\n            return \"\"\n        \n        return S[start:start+end]\n",
        "output": "struct Solution;\n\nuse std::collections::HashMap;\n\nconst MOD: u64 = 1_000_000_007;\nconst P: u64 = 26;\n\nimpl Solution {\n    fn longest_dup_substring(s: String) -> String {\n        let mut lo = 0;\n        let mut hi = s.len();\n        let mut res = \"\".to_string();\n        let s: Vec<char> = s.chars().collect();\n        let n = s.len();\n        while lo < hi {\n            let mid = (lo + hi + 1) / 2;\n            if let Some(s) = Self::exist(mid, &s, n) {\n                res = s;\n                lo = mid;\n            } else {\n                hi = mid - 1;\n            }\n        }\n        res\n    }\n\n    fn exist(size: usize, s: &[char], n: usize) -> Option<String> {\n        let mut pos: HashMap<u64, usize> = HashMap::new();\n        let mut hash: u64 = 0;\n        let mut pn: u64 = 1;\n        for i in 0..size {\n            hash *= P;\n            hash += (s[i] as u8 - b'a') as u64;\n            hash %= MOD;\n            pn *= P;\n            pn %= MOD;\n        }\n        pos.insert(hash, size);\n        for i in size..n {\n            hash *= P;\n            hash += (s[i] as u8 - b'a') as u64;\n            hash += MOD;\n            hash -= (pn * (s[i - size] as u8 - b'a') as u64) % MOD;\n            hash %= MOD;\n            if let Some(end) = pos.insert(hash, i + 1) {\n                if s[end - size..end] == s[i + 1 - size..=i] {\n                    return Some(s[i + 1 - size..=i].iter().copied().collect::<String>());\n                }\n            }\n        }\n        None\n    }\n}\n\n#[test]\nfn test() {\n    let s = \"banana\".to_string();\n    let res = \"ana\".to_string();\n    assert_eq!(Solution::longest_dup_substring(s), res);\n    let s = \"abcd\".to_string();\n    let res = \"\".to_string();\n    assert_eq!(Solution::longest_dup_substring(s), res);\n    let s = \"ababdaebdabedeabbdddbcebaccececbccccebbcaaabaadcadccddaedaacaeddddeceedeaabbbbcbacdaeeebaabdabdbaebadcbdebaaeddcadebedeabbbcbeadbaacdebceebceeccddbeacdcecbcdbceedaeebdaeeabccccbcccbceabedaedaacdbbdbadcdbdddddcdebbcdbcabbebbeabbdccccbaaccbbcecacaebebecdcdcecdeaccccccdbbdebaaaaaaeaaeecdecedcbabedbabdedbaebeedcecebabedbceecacbdecabcebdcbecedccaeaaadbababdccedebeccecaddeabaebbeeccabeddedbeaadbcdceddceccecddbdbeeddabeddadaaaadbeedbeeeaaaeaadaebdacbdcaaabbacacccddbeaacebeeaabaadcabdbaadeaccaecbeaaabccddabbeacdecadebaecccbabeaceccaaeddedcaecddaacebcaecebebebadaceadcaccdeebbcdebcedaeaedacbeecceeebbdbdbaadeeecabdebbaaebdddeeddabcbaaebeabbbcaaeecddecbbbebecdbbbaecceeaabeeedcdecdcaeacabdcbcedcbbcaeeebaabdbaadcebbccbedbabeaddaecdbdbdccceeccaccbdcdadcccceebdabccaebcddaeeecddddacdbdbeebdabecdaeaadbadbebecbcacbbceeabbceecaabdcabebbcdecedbacbcccddcecccecbacddbeddbbbadcbdadbecceebddeacbeeabcdbbaabeabdbbbcaeeadddaeccbcdabceeabaacbeacdcbdceebeaebcceeebdcdcbeaaeeeadabbecdbadbebbecdceaeeecaaaedeceaddedbedbedbddbcbabeadddeccdaadaaeaeeadebbeabcabbdebabeedeeeccadcddaebbedadcdaebabbecedebadbdeacecdcaebcbdababcecaecbcbcdadacaebdedecaadbaaeeebcbeeedaaebbabbeeadadbacdedcbabdaabddccedbeacbecbcccdeaeeabcaeccdaaaddcdecadddabcaedccbdbbccecacbcdecbdcdcbabbeaacddaeeaabccebaaaebacebdcdcbbbdabadeebbdccabcacaacccccbadbdebecdaccabbecdabdbdaebeeadaeecbadedaebcaedeedcaacabaccbbdaccedaedddacbbbdbcaeedbcbecccdbdeddcdadacccdbcdccebdebeaeacecaaadccbbaaddbeebcbadceaebeccecabdadccddbbcbaebeaeadacaebcbbbdbcdaeadbcbdcedebabbaababaacedcbcbceaaabadbdcddadecdcebeeabaadceecaeccdeeabdbabebdcedceaeddaecedcdbccbbedbeecabaecdbba\".to_string();\n    let res = \"aeeebaabd\".to_string();\n    assert_eq!(Solution::longest_dup_substring(s), res);\n    let s = \"shabhlesyffuflsdxvvvoiqfjacpacgoucvrlshauspzdrmdfsvzinwdfmwrapbzuyrlvulpalqltqshaskpsoiispneszlcgzvygeltuctslqtzeyrkfeyohutbpufxigoeagvrfgkpefythszpzpxjwgklrdbypyarepdeskotoolwnmeibkqpiuvktejvbejgjptzfjpfbjgkorvgzipnjazzvpsjxjscekiqlcqeawsdydpsuqewszlpkgkrtlwxgozdqvyynlcxgnskjjmdhabqxbnnbflsscammppnlwyzycidzbhllvfvheujhnxrfujwmhwiamqplygaujruuptfdjmdqdndyzrmowhctnvxryxtvzzecmeqdfppsjczqtyxlvqwafjozrtnbvshvxshpetqijlzwgevdpwdkycmpsehxtwzxcpzwyxmpawwrddvcbgbgyrldmbeignsotjhgajqhgrttwjesrzxhvtetifyxwiyydzxdqvokkvfbrfihslgmvqrvvqfptdqhqnzujeiilfyxuehhvwamdkkvfllvdjsldijzkjvloojspdbnslxunkujnfbacgcuaiohdytbnqlqmhavajcldohdiirxfahbrgmqerkcrbqidstemvngasvxzdjjqkwixdlkkrewaszqnyiulnwaxfdbyianmcaaoxiyrshxumtggkcrydngowfjijxqczvnvpkiijksvridusfeasawkndjpsxwxaoiydusqwkaqrjgkkzhkpvlbuqbzvpewzodmxkzetnlttdypdxrqgcpmqcsgohyrsrlqctgxzlummuobadnpbxjndtofuihfjedkzakhvixkejjxffbktghzudqmarvmhmthjhqbxwnoexqrovxolfkxdizsdslenejkypyzteigpzjpzkdqfkqtsbbpnlmcjcveartpmmzwtpumbwhcgihjkdjdwlfhfopibwjjsikyqawyvnbfbfaikycrawcbkdhnbwnhyxnddxxctwlywjcisgqfsctzatdgqqauuvgclicdrpjcphysqdjaflpdbmvnhqggixxzcmpsysbwfkzwxzjictnngufpqhcxlbkodyrqlfomlkiefbmcfenugzqnyqqvgpxonmizkpjdlaqyyowjagzkzrzvcrupfyofeftyfvoqorzvxphhdhydnqiyiczfcgzsecxzsoaobwrixcajabjnvtoerzwayjowahrmuixmmkbtchogfizmvbjnpespxngxjxntohzatlpkcmpphmewevpteharnszafbpbexrvnbedieojezdhnyooiivhnhakilvkobxepbksnqrtxxuqhalvtjspyvporalbliiwjciamlhttaydhxoelimuorjnfvebjhcocbkrgbguwdncodskzzoqrzgavsbjcippetltqaxjhkqacwlgmsbxezqubyzeznnsoqegkykzlxohvitbmjcxllbrvgdijyovpjyeaojlyxqwnheyblznwoyikhqiutotpfukyqkvatxotulvlqzfcvskdccuixthzqrwymzccosjmjqjigehcnfphjuuybaxxukconatzseljyirycbhucxmwwftulfwfmyqyprlnsmxzyfmgjctgeunuuexhbrbsaaingqxqrjvpuhbvcmyztmkgenhonajrkzfrqjinjrbmjyinhwvlcmmxvbgvjgfmaoliosmxbonvlzoiqvkxxtoposygcgkcotohcrauivxxvmrghuauadwojxjligrgstczirnvhqpzwgjbvqzlkxltqnqrfxieggnuriytavbnouwhuamdtlspednyckixkhxedjmotiuucewllthhducwgwmgzxsbkqzfnqfynwisvsctyqdoaiypjivtxkxgoyhwhccklbdjoqykaqzljejlizgbehekmkfetvgfstmypmfnyoundudqlorcogbzoznddfalthwpmiewkmvogmzirbprjftbtffjrkrfminnechitfyfaujgtugadqbrskulsjbaunonxolauvsifevpdyurvfocxtkizflcuvltzuhwyhlbxaphifhtgkfktfnnmocpenrlujsuppbbuorvtubuiyszawzftijwhwgdyubjmmodzybiyunksuixnkariubegpdgctbayaynfskkuyhjvegsjwsbppodvhpjdjlzhxixswdncapxyfjspxeqxdfkhockvrzoisikaymoiqzqbjyoscwegfomlnurwboesfiszetebjblaolnovgvfcpnbemwambkhwcgdbhvkoluhjfxlfrfaeedocdilaboesauplmttewlbojkocklhsbzrtzeyhqtmgroupbzlymupmupsvlkzchclujuozzmngjvktzstsvocxrziuxelruwojzaleyrkjkdleavwqxwgjdbtiywqtdtaamrlcjogxufhgvoqpqkgopbtyqchzhexqgecheahjzxapqjdylzjqhzlzssbjmokncxalgasexztnlzfisxxpeerywlrjdohprewwnlwdbtwmfnnxnoolfhqqxzcvoymdbvmaoliedpvwzyvgyrwjguvoqnxrnaeqwvcfrqkwjmlvxovptultyfuxerelpfgctnpdxluqeruxkxqntosggfjqmrnlnkhhilznpycdrnemnktcsmzufpqgiraphzmgfhevzejhavsypohpttnnowfahpxfwmvxgwfuomxemdkzdlzldesmowzmhwoydnsovwykxqyllbmcurlvtwcfwxvvkxfknwwcwfjkzjtonalgijdsulcfagehiptszrcltbbypopdbmdfkyofelmrdmdbceguyxnkheqqtbletpqmjugpckmjyuuvsbqhyzmposwcgscnishluuhnwkyrkujefpgtsqrmcoortgitpdoagdncxlofkqozgngbtmlyyoyodcmcwetdtltupjrtemrjswekkfjvfecmvagyptjjuwsqpjwlxxosqhpssdvjraaicjfwvesyqfbumjjbqytkinpldxopxjzmvpigmberobyzyxwvwmlmbziduqhmbescgkvhgqtalmaxfsjlysmvrizgvrudstiwmaahtqehfbofvqwgqygvseykmgmhgjbxcrtdjqvojvyhohallyewqelzhjeuqmmsqhkluvqsfmxzbqqokehfoqrlqmwpnwojfowqpqebnuggeuvsszgfywceolvabyvbrwatuyherijsdqvpyyhdyradbammmchqkvdbxpbrxzrpfrsiiezvowrfqejibvociujtcwbygvfwojgfnvvwqlqqgipxhrogppzghtnweodaxuqxknnqnajlnsvheiycsvifvoljsncgnunsqcymnyoeeslrjflpprvtksimffvnuvakskdakvmlkpowfpfzdrcfctikhvvbagrvjlzjydnlmspzyynyjjfxnozpjjgjelipswsmfroitqphzsuqgumlnkxksbzhrsvcnfwufofhurmhksvvfjzggbtgrezkrkqmhduyqgwuwxoxaiifemtwrbilftiuhcgpjvqxldrnlzphdffncevlcyrxlpbwuswjfdegexeoooshdfqtqithpfocyowaqeedikssptyvkabhtaeotcwxccgguuotqvypugpcbwzalxwqbjdcokoxjnqhggpbbfeyjiellsikiqqtxpvzmjsfleepjpbxpeicxfcwbpprzgcrjgjaxshewradetsqsvfmcxptmksecfpynqzpctqpogcgokzrkltsbmwxkmynasohpkzjupapngusnvdjfqezqhyikllgkelewwwhhbdjvxdagnnxscjkotbbmhzkqbjwuwidrnvmztikmqjcxmcpgkoudhydmdvberfuvjnhlnfcsbpzmuquvrgogtfwefhqzkmxxgadtvjpxvurxprbsssihviypclwkjfaatzjxtvlzwaacqlwnqetgkldqaqghuihrgxbbpmjfsvaigqrhiiskkfibaeilqptkdsqqfwxeixuxgkiboaqnuaeutjcydnxyxnmattjrrxmthwvyipgazaxgrrjcvdnyxpktsldhluhicyqprxhljyfhawuvoonrwyklcdlmdvsgqrwqqomisksftsfyeifmupvylkjbagzyctuifbsrugqsbrkvskmundmczltpamhmgqespzgrkxebsvubrlmkwyqhjyljnkeqvdxtjxjvzlrubsiiahciwefwsswgssxmvyvgjrobvubcbgjomqajmotbcgqjudneovfbjtjzwqtsovzshmxeqofssukkvcdwlsdtyplrlgwtehnwvhhegtwkwnqqdiajpcaajsylesadaiflruewhrbrogbujbppunsqgytgnyuhnkejhccavaptbydtqhvyatftxcaaljyhhkkadzdhhzawgndunwwgknnbtqaddpszqgummmnomfqmdxqtwjexsbadfdqhnyixjslsaisscocbabivzokkgiinqqzsrtfpzjmxfkqmuzzlelqjtjidjarkwbwlcqrefokrlwdmuzyffdtajnqoimlzzpcgpjjwlqkusefzbgznhexzojxnzxmmedobgvdabtdoiskozrdrjscxwivaekrkyyfynuktmgyziteavdxfctvkfkrmsdwpaywzbkeojeycwdkectydojttisizruilwokhepscqdnjygiakomkhyujaffxjyxqmvkemqihpcdygprdeaxgjbkonfvgtzayfbmgwsskoyxjlknwwtehhhpjllhkcblyaxnbekoidbbyqvdqqsyfcemylmqskpxifcnhmemkkitqtbfwhmyemkzightkjbhlquticivpeeclpamsqoztxvdtcqbsonxyecnhcadtghkjckhrcdfggnqlwurydzbeybqkcfnnbwkciwaqdzgmcrbltvcuftxsqfpxnoombsbeoqxivgtkrjklxatgcorkdrvmngwlekeopgecefzxtprcoajoopxviijxilxfiwuajsbtcctfcqqgzhyjmonwdbyjlnneidyaqhhothzpzaxcthvbxpdcqofaeamxbqjwhunnqwclhcqhagawjsxygorgbuqryzickyplbaivkabbrkibqzqacabbwmnpndaqvbknbqcjuywxjrdbznndomwbbqfgulwczydrhrocebhygriiwxmwtjjyqqiqrjblxuamddlsiocdoysdaacuovljtpgocephnxuugdyggsnhcqiqhulyhlxiwzvhrtbmvjnhacwunckqzhpcthqgsupptdwkfeprbg\".to_string();\n    let res = \"maoli\".to_string();\n    assert_eq!(Solution::longest_dup_substring(s), res);\n    let s = \"baaddcedaabeeebbddcdcdbaedcadbcbedddbbcbcbcdddbdddbdebecedabbdccdabbaaeedcbcacbcdebebaeeecaaddeceabbcaddabeceaceebedcabbcdcdbabdeeeacaceabaaaaeaeabbdecbdebedcedacbecccaeacbadecedbacbcdcebddebabbdddcdbbdccbdaccacaccbaabebcdbeadbdeebddbdddbabbeaeeabbdbcbcaaccdcabaebeadcaddeedcabebcbdbbbcdeeabbbadcbbadddadaddeacdbbbbecdadababacabcceaccdaddbcbbbccbdddacadcddddedeaeabebcdcaccceeecbdcaeebeabedbececeadbdcdcedadbbebedaaeacbedecddcabeddbadaaeceedbbedaadcbdebcbbbdcbeccaadeacdbebaedadadddbebccacecbcecdeeadaebbdbaeeaeebcadcbbedcdddacdeeaaeeeeebdccabbdaecdccaeacbecbdbadccaeeeeaceeabcacebebbccceadebeaeeeeceebaaaecbaccaccbccebeceaecdbbaacaadcecedddbcbacdaecbbddbaedbbbbbeacdeddaecbbdabebaaadceaabdedeadbbdbebbbcedbddaedccedcbebbdbbeaecdaabcdbadbbdbcdcbdeedbcbabebaaaeceebeccddcaaeebbedcdceeeebeaddcdabbcdbebdaabaedbeacccebbccbecaeeacbdaeeccdbdeadcdebbcddaeaebdacdadbecbacbaccdcaddbdcabadcdacadadbdbedadbecacecedccabbceeeeecaeccceedacbaeadacdcddccaeabbcecddddbbabaeeecedbaccabceecbbeedacbbcdddadccedbbcbcadccdddedeceaccdaeedcaebcdadbaededddbebaabdeebacabaaceabdeedabdacbeddadeaeedbddaccaacbababeeaeaecdbdaeabeeedbaeeddbcceecceebabbebebdedbaebbeebddeeccdabaeaecccbeeebacacdbecadabdcdeedeebccababdeeaccbdbbabdecdbdebabdbeeadacbccceebdeddebedbbbcbabdccbddeaceeccbecacdbbaecbbaabebadbbdbababddeccbcebcdbdbcebddaeaedeebacaaaecbdaabdedabcbedadcebbeadbcaadbcdbaeaacddeebcbebbdbecbcdebbcaaaacddebedabdaeeaeeaabbedcdabdceeaaddcbbeadccbcddceedcabbaecabadbadeabdbdcceaedcdbcdaeaebdbdbaacdeccedbaeeabbadaaaecceabceececaacecebabebbdebadeabdaadbbaebeeabebbdbeeccceccdbaceabbbeeecdccebdadeabbeddcdacdbeedbededbbedddabddeacbdbeeedcdeecaebcbabeecadccbedbeaadaebdcabedecdeacaccbeaadabddeadddccccbdcdecebeeceaadbaaabdedadbdccbdeabbdddebebcabbebaaabbbaccecebaecccaadecddbaabeebcabedebdabcbccaeadebabaacddecaccdacaadbbcdbdbdbeddedddebacaeadbaebaddedcebccdbbdcdbcaaaaccdaaceaebdadaceeeabedcacdddeeabecbacdcdbcebabccabecbbeeedbeeccabaeccccceaeaaceebcaacabbbcacdcebabdbcbaeeddaccdeadcbdedeabecdaecadbcbbdbcececbdbcdcbbbbdaacebccbaacbcaaeadbcbeeedaceebaeebadbbcceddbdaedabbdacdeadabeadccadbebcecbcdbaabbecddbaacaccbbbeaeadcebdccbaedaabdadcaebbdcdeaebeecdbbdbaadaedbeecccddacdedcdebbddaeecabebacaacdacdadcecdcaeaeaecbccedabbceebacdedceedeebbbacddacddedbaddaccaebeebeaadbeeeecdcaedadabddebcbcddccadaaadddbdbdccbdebbcededcdabbdbbdbbbedecadbdebebdedeebaadcaebebdececeaabbdaedeebbacecdbcbddeaaabdcbbdbabddabacbdebcbcccebdcccbcddcebdcbededbaadebebedcbebcccdddbabbeecbadcbeeeabbadddbbbcedcebbaabdeceecadaabdeaeabbebabbcedadbddcbedadcaededaedbeaaaeddadddabbeeaddddaaadedccddbcebeadcaebaaeabeeebecccbaddceebceeddabbdddcbeeadbecddebcebebeedcedbeabdbebcccdbbaadbabcbebadbecabbaeccbbeecaeebccdabbdcbadbdacbdccdccebeabceaaecbbeedeaacaddcedccaabaabeaecdadaceacacdcdcadabeacbeeabdcdaeceacdbdccccbbbaebcceaabcbecbabebcaebbbbdeaebbebaeeacbdbaddeaaeacedbdbaedecdbaecbbeddededbadbbadebabecdaadddbadeaabbeaebbaaeeacebcceabaaeabaecbdaeaccbedccceacdaceacceddaccdeddbaccbabdabdbcbeceaadcdaddbadeddbeceacbbebeacecccadcecacbecbacadbaaeaebbabceeddebbcbabbecbdbadcddddcebdabcadbbaeadbeadcceeccbacccbeccbdbaecbbdbeebbebbcbeccebccdcbbabcdaedbaaaaceeebddebdcebaecbadedaaccccabebdadbbcaceabbddeeeebcaebecaaaacaccaacddddcaedcdccbdabbbabbacdabedbbbaecccacadbacbcadabccedcababaedaceebcaccddeecdbcbbcdbbadbbbcccdcbdadbccaacbaeabbaecabccebcddbdbbbccbbcccdebbcabadcaeeecbacadaceeaecddeebeacadeabdabbbcdaeacdebddadbeeedbdbcebedbabbbebeaadabdabebaebaabdcbbceaececabecbdadeecccdebcbecaabbeccaedabbaaddeedaedbdbacdcaccbdbabbdebdebceceddbcddbabeebeecadcabbaedeabebdeeaaebaebaeaaaccbebceedadbcbbbaeceebcaedecbbebddccaadcadccbcababcadacbcabebcbbeecabbeecebeabceddaaeebdbdeeadeeebadbbcaaebcdcdeabaaecababaccaadcdebdeaddcaabaaaaedbadeddecdeaaecaedceabebdcceecdbcbcdaceeacececcadacaebadedebebcbcedcdbcadaddadbbadcebdeacceabaeedecbebbeccbabaaddddacccbddebbcbdedbebcccbbaecceeeccddacccaddecdcbaebdebbbccbdddeadaddacdcebebeedccddedddcbceadbbdddcabddbbbbdbabccbedcacabecabdeccdecebdbbcbdcdcaebbaceededeadcbccdbddbbebeeddbedaeadbdabebdcdbeecdaecbcecedcbeaceacdeebaadeeebaaeecdebeabadbbdbbcbeceebeeecdbdacebdcedbecccabdbaaacbeaecbddcaddbdeeeadeadedabacdeaadaedbdacccbbacadadedecddbcabcebdadeaecbeeaabacaddaeebcbdcabeacbddbecbbbbacbdbbdecebeedbeacdcabcdadcadcbbadaedaddabedbbbbabeddacedbaddcaececbdebeaeeceaecdedccbaadbdabdedbeccaeaddbaaabddbcabcbbbddbedbceddcdbcdbeeebbabbaedcdbdedaccacbddcdbaaadacdaabaeebdcedbdbedeeccaacbdcaaacbacccebcbadeececacbcaaaecccbabecedaebdaebdaecacaebceeddadecedbccdaababccadeeddbbdccecbddbbdacbeaabdaabebdaaebebcbacdccacebccaadaacaacbbaaaaadbdcebabddccebccebdbcbbebeadcbdcbaddcdaceedebdcdabaaeaeccdabadbdeacbaebcbcbadabadacdcebcdeaebddcabccddbababbadddaeaecbedcdeceebdaeebdbbdebabdaeeaedbcbdacdbbcbcaddeaaadcdbcdcacaabecbceabecbccaadaddaaeaccbbacceceddaedcebeccaaabcadaaddeacaebcdbbeeacbaaecddeadddcabbeebecdadbadceadecedccebbbcbdcbbceeedcbdcebaddabbdedceedeeaaabcbcecccadaebdcaeccabaaeebbbbaecbcbccbbacdadebcabbceeddcaebdccaeedcceeddecaaeebeeeadcacbacdaacbbbccdbdecbcaaceddaadacdcecbabdebdececeeecbedacddbaeaecbbcadeecbccccbcedcaddacdeecbaeaadeddcdcbabbabaeadecdcaaaaddbcddbabeeccbdbeaddbeceedbdbdcdcaabebcbacdbedbadbeecbbbdaabcceddcdabbdbdadbdcddeccbebdeaebbbaacceeddcbdadcacdaacebaeccdeacaddcbdbaeadcaaaceadcddeaaedadcadedaedacaaacabcdaaacecdbbabebebdeaadaecdcbbadeeecdbccedeebbddebecadcaeaeacacccecbadedaaeebddaeebbadcedaaadcdbcbcebabeccdddcbdaaadebeddbbdaeaceabecadcdecabdddbcedcdecceacbccbdbcaebbdbaabecedccaaceecbaabbebdeeaceedeadbaacdcebbbabdccaddcecedeebdeadebbacbcadbbcabccddeeccdcbdbcdacecaceddcdbaeececbdcaececdedabcaaaecdccebadedbdbbbdccececaeaebdacaddeacacddccdaccccadbecceaedacaacdabecdbbabecacabdebddcaadeeacccdbabebbbedadebaedeaaeeeaceaabdbccaabeabaaddbeaaadeabaddaabdcebdcebbedadacbeecddbcadbdccbabeeaecdebabdaabbcecdaebecebcaccadceeaaaaeeedbbaddeadacbccadbbeabeedacaddbaadabaebeaeeedbcbeeabebeeeedeaeadeccbbacadadbbceaacaecdcbbbaeacedbabcabddeacadcddaaaddabcccecbbcdaaeaccadbeaabbcdebcebdebdebabdbcdbdceadeccdabbeeaceebaadbdaadbcdeaeadbadcebeeabcbecaeaacbdceccbecadcceeabcabccadcddbdbcaabeadcdbbaeadacbbdddaedbccaadcceaacbaaaacbeaeaebdebdbdeaebcecaceeaebbebcadaadccbccdaedbbdbcceecacddeeadedbedaeddbaccddaecbeaadadcccabbeeabbecebdaacabedceadaebbbbccdccbabbeeebaaedcdecbaeaaaabdabebeacdcecaedbddbbccbcccceaedbeccdcdebaeaccbbdecaeeebcaebbdaacaedeebabecccdcaadecaeadeccedededeaeeddebedcdbeecedaaecdbacdddddeeebebacedabebbbeacbcddaeaeabbbcbcabdabcbdaedabbdbacedbebdcaeebecbacbeaceababecdcdaabaaeadebddeccdaabdececdaeceecabbbeeebceabbbbdebadbcccbcbdbbceeddbbddcbbceeeabbeedbddbdacedddcdabeecbddceabbccbcbededaaaacbeeaecaeccceddebeebeeacdeabbaaedcbedcebcbadaedbaddcaebadadccedeeabdeaeeaeaebaccabbeaebaedccaeadadbeaebbeceddeaecccaaadcabceadbedecddceaaedbeebeacaaebeeadceccddeebcecedaebaedacaedccbaebbedeeacecaceaaddaceaabdaeeeddacecabadabbdebccdccedcdaceeabcdeaeaedbbdeedbdcabecdcaabcaebeeabbbdeedaaecedaabbbaaecadbbbcebaeceaadccdbcaeaddccabcedaabecdeacebabbcdbbbacdbaaeebddeaaedcbccecbdaacaedccbaeaddaddaccccaceecadcadecbcecccabeccabaaceeccbeccbbdddcadbeeaeddcbbbddccacbbccbcdabbbdbbeddaaecddaecaacdcaaadaeccdbdbecededcdcaeadbdbedeeddeccbdbceddabececdaecbacabcedccceebbadeeabddabeceabaeecdaabcedacedbabcbeddddddebaaddecdacbebeadbbebbabeebcecacaebedebedeaeaddbbdbdcbcbcbadcccbddbebcacdebcedbbbacccdbaceacedabdacecdeccaaceaddbbdbeaeadcbadbeccbdccceddbcdbeccabcaaebbdaeccecdbbacbbdccbbededbdeeaeabeedbecadddcbdbcdceedecbaedbbcbabcadbbddabadcdbaeebcaaeeacbbbebbcaecedaebaecdeedcecebeebdabcbecdaecccecbbbbcbacebbaeaadabaadaebabdedcddcbcdddecdaaaaddcdedeceebbaddceeeadbbddaecaadabcedeabbcdddacbccdceeacddebaaacaccdcecbbcabeecdcbaabaececdbdebbcddeeadccddbecebbeaebbcbdddedbecccecacacabbaeababceddcdcaebebaadedddccecbebbbabbbeecddbbabbeeeeceadacadcaadcaedabdcdcacedaddececabbaeaadeebcccbeeeecbcaddacaceceedddabcccddbacbeeecbceeaeddcedaceebacddbcadbbeedaaecbbbecaeadbeaaaddeaeabdceddbbeaceaddaabcbabaecdcbcecdecdaeeeaccacddaaccdbbdeeeceedccbdeeecceaedecbeeaececaecaacbbbdcbcededbbbedbacdddcedbcaaebeaaebaeddeeeddabaddbcbcaeceedebcaacabeecedbacacedddbddcedcddbadadbdaccbbeebdbbaadadbcdeeaaebbacdbdedddcacaebbebbeeecaeacecbaaeccecbcebcdaadeeadcbddcebaeebabeddcddccacbacbceacaccbccbbcdaaebdcbacaebdaabebcaabaaebeddeaeacbcedbccbdebdccadaddacbebceaaabaebbddbcdadbcdcbdeaeecdadcbeabdadecedcdcdcdbeacddeacaaccebacaeddbbcbbdcaedadddebeddbcaeebbcdecbdaaaabcebdedacceadcccbaadedcceeccceabdbcbecccdbcbebcabbbcaebacdbedaaabcddbccadbeddccbeeceaeceacdecadedcabaeecedcbbbcaecdebbacdbdadaedaeacadbebecaaaaebadeedbdcebcecebadebeebddeecbacbadabdcceabebdbaaabaacacbebdddebcaebbbeecbdccbdcabdbddbbbadaceeaeecddcaabadeedeeebbdbbeaecbedbadcbadcecacacdaecbabadcceaadbdcbacbccdeabaabcdbdaaacdaedccbebdcbadccaddbccededeadaddaccaebabcbbdcaedaedccdacbaacecadcdbbaedbcddebadbdaedceebebacdceebeebaadaebeaeabdcbadbbaddbdabaececbaebbcdccedccbadaebdbeecaeedeeceeacdaaccecabeeaedacccccbaacaddacbbcbabbadcccaaabadcabbbadaeeaadacccacedaeecebccabcddeeadacdbaccebdabbaabadbecadadbbadeeebcbddaadececbcebbddebcebbbebccbdbedbdcebacedaeddeddaebcdbdbcbebabdbcbcbbeebaaeeeebcaceacdcdccaedabacddccbbbdabccadbcaaeeeabcbdeccbcbbddbbdaedcddabaccdacebacdccbbecaaeccadabddeaccbeeeecebdeecbceeddadadcacdecacacbddbdacbcdbadbdcddeedcceceecbaeecbcadacbbbabebceaadacceedbdcbcaedbbbaabadbceacccbbbdcbcebecbbabbdababcdbebeedebeabaabeaeaccdcdcecbdebeedbdbaaadbacdadcceeecdbababccbcbdeababbbbbeedbaaaaecccdacdeebdcaadbdcdbcccaabdbbaceceecdddecaeaddccceabadabbedbacdeddeebdceecedbabdcadeaabacaacaacacaeeccdbeebaddddeeececbababdebbadccdbaaedacadaccccceaebecedddebdcdddddeaebecabadecedddaedececddcdcabdcccedceaaececdddbdeddadabdceeaeaacceaedeeccaccedaeacccddabccdacadebcebdbbbbcedeacccdbdcbdcddebbceacbbbcedecabbecbcdcbddcebdebbeeedecbaeacddbcacbcebbbbceabdcceeaeaadeceddcabccbceeaaabebeaedaabecccaeaceacbeddddaaaceaaceceeabebcabededeeaeddedabeaeeaddaadccaeceabaeeadacaceedcbbcecededdecdbaadbecbaeccedaebacbebeecbadcadeadeebcbcbadbecdaebdbccaeaacdcdeadbdbaceacabcbcccbdbdbedeacbbdaebbbcccbeacddadcaeabcaecccbbecadcdddbcdbcbbcbadabaeccedbbcbdbecabcddeacbbeacdcdadecdccdecbdeebadceadbbdabbcedbceabadaaacdddeccbcbddeeceeebbedbcbabdbccdebaaacbbeccccebdbddbacbabbbacacdecbbbcdaacbdcddbabccdeaeeaedeebedbeacddcceecaaadeacdeeeaeaededeadddeddbbacaddbbdbdceceaedceedbaeeadbdbdbeedbadbdacbdecebecaaeebdbadecabbcdeeaccababdcbdaaebdcbbbeabdcbabdecbcbdbcceadabdeabdbbabadcebabeccbbdbabcaeebdaedeebcbacaddeabdbdcbdcbcaecacabbbeaebecbccdacdcdcceeccaeceaedacadecaeaeebbeaebdcbbdcecabbbacebcadbeedeccbaaeebdbeeadceadddeaceadddbbccadccbdbacbddccaceecadbeeddeeecaebbdbeecababcbccccbaedacadcedbbeedabbeaacdeccedeeedaadaddddcebbeeaeaeaecabdbbeaedaaacbecabaaadcdabadddbeaaedbdaaebacbbaaaeaebaedbccbcabaeabcecbeacabecaddeeeaceadcebddccbdcaadcaaacacdeacecbabdaaebdddcdedebacaeadbeecaaebaaacdcebccceddddeceaacaebddaebaeeebddbbabcccadbedcabcdbececacececbcbcebbccbcedbdcecadcbbeebccddaebeeeaddabbcbbbbaaccedcaccbadadcaadbebebaadeaceacbbcacacddcccaababceacdadcaceabcecadeddeacdaacebaabebaebeaceaabddeeccbabbdcacbdacdbdeeacaadddcacbababeeccbbaccccdacdedccdcabbddecacebedaccbbeeabedeadbcadeeaadabceccbeeedbebbbabdbacdadbeabaddceebddebdbabdbdadedcacbbbdbcbbdaacabcadbeddcacacdbcdcbbbbaedbdbcadbbaaedbddbeecabcebbebaedcdcaabdeeccdeeccaeeacabeaaacbdaeabeecaaedabbceebbbdaeeabecdadebcbcddbaaaedceeaeecbeddaaadacdccaacdbbdabaaebccdcbeaedcbeabebaaadadddaadeeededdbebbecaabbdcedebdddaadacbbbcebbccadcbaddccedcedbdebbdddccdcbbbaceaaedbecccceacbeddcebbdeacbeeecbcadcccdabebdbeecbcdaccaacdbdbdabadcabccedcbabeeecceccddcedaaddceaeedcdbebaadcdeaebabaaaedceebccbceaebeeeecbaecbacdcbedabeccaeaeaaddddaaedbebbbbbbabcadcccaabcacacecceeaecddbdabddadccddeaacdbcdceccbebddcabbcbadeccaaddeaebebedacccdceceebaaeceeeddedbaedbbcbaddeddadcbeadbeebdbdebddcacdccccbcceddaabebdcbcabcabaadadabdabadbebebcdcbaedbdeaeeadacacebbeccdeccdadeaacaeccbbbacdecdaebaceadbddcaedabceaebcaaeadaccdabedcedbabbcbbebbeecbaecdcdbadadcebddbdcbeeaccdbcdeeaabdebeaaeedbabcbdbeaaaeededddaedccedeaeecdddabcdededacaabdcccddccacddbdeceadeecbcdcdbadbcdeaeceeadedccceecdabcccccbecedbebcaaccceacbedebeaeaaecdddadeacebbaadcaadbadcbddeddbeedccdeceaebeedbdadbebdbdaceabeeaecebeaaeedabcbbadebbdeeebeaddadaeaacdeacddadcbdaabbddcdedadbebaabccdddcdeeaeecbebdaceadeebceebceddabcadcbcabbaccbcdcadcbeddddcdaddebebcbcdaaddceebcdeeebbccebecdaeeabdadcaadaeeddeeabeaecbccadbbedddbddadeeabdaebbceceabcdebeaeeebebacbdeaeecddddbaecaebeabbcdcdeecdcaeeaeccddbcbedaecebcdddecdbdccbdebeebcebeadaecbbdadbdebcebdadedcedabacdbdbcecebbaedeaceacdacaeaeceaddaceeedeacecaedcecdddaceeadbbdeaccbdbcddeddeebadebdbbedcdebdbcaeaedecdbcecbeceadbdebdadceeadaadcbbcabbeddeccdedcacaebdadeaddccccaedcbcdddbcbededdebcdaebcccaacedbbccdbdccacbdbbedcbcdbedbdbaccaedecdbceadacbdbbcbcdbbbecbcaaceabeccabaabbaddedacbcbbbabcadaabebcbcaeabccdbaaebaedeadcebedaaaabdbcbbdadbbdeadeecbdabcbeceedeeabdcabbaeaeabcebdeddbddaceacbaeabacdacbccbbaeacacbcaeebabadbebdadcacacbbcbabecabaeebbbbbadaabcbcbdaeabedccdebdadcccdabbeebdaeeadbbccddeeababbbbaebeeaaaabdeeeececcbebbacadddbbddbbcadcdaebdcdcacaabdaabcaeedebbbaebcccebccdbbaeeadaaebeeccdbebecebeedecdeaebbcadaccbaddaaabcccaecbdabbbcabbedddcdadebccbbadeabdbdcededbeedaebbdaccedaeaacaacccbdbbdcdbcdcaedbbaabbbecdaddbabababecbbaadecaebbcededbecdcaedbbcceccedcededadbaccdbabaebbacdacebaacbceeaaabcbddcecdaaaedcbdaadcdbcbbacecdbcabcadeaceedabadbbddbaacacceeabaabacbeddebbccbecabeadcecbdbddeaebeabedceababddecbceeeddbbdbbbbeeededaebeebeabbdadeedcaaebdaccecccdaccbcdeaccaabeeaaeeabdccccebacaacdbabdecaecbdecdecbcdccbeaccadaecaeadaaacdeeebbbebbcbbeceacebbbbbdddababcdddddeecebebddedececeaaebcdccbedeadebceeeadcdabebcaaeedeccdabdcbdbdeabaeccbeedcceaccdceabdadecceadcabaaeadceadbbdcaceececdadbdbaababdddedbbdcdabeececaebdeedabdaabcabcdccaebeebacacaedaeabcaaaccaeebbeceabaaaeacaddcceaddbddbcbbbcaedcdceacdebbbceaacacdbeecbcbbdcbaeedeeabcdcbabcccedeadccbbceabdbbeedddacbddcdcbaebebddcbaaebecdabbeaaaddbbbcbeeaddececbeebdaedcdacdcabdeedebaeedbedcecbbbdecddadebcdbaaebecadaeadceadeeaedbcddbedebaaebeeadabeeeadedaadcedcbbbacbadecdeebbedbbdaeaedbaaabbdbbeddaaedcdbdadeebcaeacbbaaeaeaadedcaadddccaaaddcbcbadeeeabbaeeacceaabadecbacbceeadeccaedbaaeeecddddbdabcceadddbaebabbbdbaddcecdaeaeecccbadbdaddceccbcbeaaecacdbabaeccebeebddaceabbcbcaaddbcccdacddcececbbbceccacbbdcaecbebaeaeebceadcacddbaeadadddddbeeccacabecaebaacbaaabbabbaccadcdaaeececdabbcccbaaecaeebddbcbdaccbbbeacaadbddebeddcbbdecaeddbcdbcbdeabdadbcaacebadbaeaedaedecdaccedcedabeabaedbcdeaebabddccabcbadbbdecbcecaaedadacdbcdebeabcdacdbebddcbccadecdbbbebcbeccbadbeeedbbdbdabbbbbbdecbcddadbcebedbdebbadcddebdabddbccedcebbcaeeacacdedccdcebdddaccbbbccabbbeebbdbebdbecedaaabdacddbdedcbabedeabaceccadeedaacddcbbccbcbdcdbabbcdbeeebaabeddcdaebadcecddaadaabecebdbdbbcacaedabadbcecbadcddcebceaebdddeadcbbedcdbedcacbeeadcddeecdbeebbcedbbecceaeeaebacbeeaddbcbbccbeabeabebeeccebcdaacedcabdacdcaabacedcbadcaaabaaaabaeddacacaaeaaabedccebdccacdedbcdadecddabdeadebcdedeabddaebbaaadacadbddeccdbebecacdadbbaadbaedccbeacbaabcbdccddabdbbbbebeacaebecbedebaeadabccdbbcecaeaebcaeeccaceecaaeabdbdbeeadeadcdbddcdaedbccbadaaccccabbcccdedbeeadcabedccddaadedcbcdddedaecbbcbbacbbeabdbebabdaacecbaedbaeacecbcedcbcabdededabeddbdcecbbcaebabdecacdececabcaecdebdaddadbbbaadbecaacbcbebbceccddeeecceecdbeecbadbbadedbbedcdbeceecceddebdabbbcbdceabbadacccbcddedbacadadcdccbbbccbaecbedecedabbbcacdcddcbeccadabebbaccadceadaececcdebcbbadebcbadacdedbdedededbeacaeeecacabbcaeadeacaceaeddaecdecddceccdcecaaecdccaccbbbcbbccabeeabedaebdabaabaadcbcdebabeccdedbbbcadcbcbdaebabdeebbcabacedddbcbdbdbaecaacdadebabaeadbececebeebcdddabbedaeebbecacbeeabddbdcecbeabdcabbdcbebacdabdbbeddecdbbbabacbbbeeccdadcaabbcddebeacaadbecabcaebcedaededeabbccdbadebadabcbcccadeeaacddbedbcbecbbebbeacaaccebecdaabbabcaddceebacaebceebecaaadeedaedaedccdebccbaeaeebacbabecaeaaecbdabaadcbbdabeeebdaabdbbbcaeedceaecbeedededcecebcdaadddeacecbececdecaeeeacebbbcbbabdbbdaecaaacbbdecdbabbaceaabcebcebeddacedecdedabbaadddbaebdcacbcdcdecdeaaeddeaaabbbdcccdccbcbabdcdeaaceecbaedaeeceddbebecdcbbdeeedeebdacbccddbdaecaedbbedaccbecdeaebbdcaceeaccabbadbbebeccceebbdaeccabacaeccbdbcbeebdeadbbeaadadabeabbcdcebaabbbdcdececccbcceaacbcbaeebdeaebcebaeaddabcdddaaddbcecaeaaedaceedaebadbddbadcbbbedecccbabdacbbacecaeebabdebbcdcdedcedadaacbbeeaddaeebcaccdcbdbccebdcaecbeddcbecceabcbdaddacdcddcabcbbabbddcbdddebcbeddbbabbedacceaedbabadcdaaabdcededceddedbccdcddeeeeadcaaccdeddeababcedaaedcdcaccbdbdabcaccceaabddccebadeababeaaccccaaabbbcdacabedbcbeadceecebccbacbdecdbdebbabeeddecdacdacbdaaeccdbeccbdbacbeabcaeedeceeddcedbeebeedacecddecabdabdbdabcadbdacdddcecccbcbcaecacdccecdecabbdadebdaabcacaedecbadbeebecebeacaddaabdeceeeddbdaddbaaebcaaadcaecedbcddcdbccbcddabebdcececdaeebcdccdbacbbaaecdadabdaacdcdbeadcbcecbbebbdbbadbdcebacaedebaeebebbddbccacecddcacebdceeacaeceebeeadcabacacbcbadcdeddecdeecbdacdccacdcceabcbdabeacaacaacbaecdcbadcbbeadebaabacdaecdbeacdacdaaeeedccadaadacdbaeabbedaeadbbbdbeeaeacccebececdbeeebbaeadcceedecebecabadaaeacadbdedbddddcabceccdbdaadceddebdbabeaeadbabbdaceabdbbeaecaecdccecaaceeadeebdeaebdaeaaaadcecdadcaabcdcdaaecbdaebabaeecbbcebeccdaedddcbcdedabeebccacedaddaacecdccabbacbabddccccdbaecaceecaabeeaecccaabbdcaaddcecbeceaaedbdccbecdabbbdabdababaaaacdadbdbebadcebebdbcbbcedecbacecedceaabceaaeedaeabecddaaccdaeaccddeddddebecdedbbcacbbeeababbdaceceaaeadddaddacdecdadbcedcebceeaacbceeeebdbdbcbdebcddabcdabedeebbbddbcadbabdedcdccbecbdceececbcddcbaeeddcceaacaebaddaedebbabcadbbceaeadcaaedaebbbcdedaaebbdbdadedbbbbdabcecdabbebaecbbddebeaecceaabebedecbddcceaecedbadaceccaadcdcbbabacaebecbaccbdadacdedaaacddcaaeeeeedabcbaaecceceeaabbcdedecedbcabbaadcadeabcccaddcecbbaebebceebedaebeddeeeaedabaadcdceddaaadebaabdadaeabbeadbbbaeeadaaadedeeaebbbeccbaeaddaacdbdacaababadccebbbbddcbceabbccccabbccaeaedcccbaeeabddaceabbbecbceaacabaaadaebdaeabcbceeebacdbeccdbaddbbcacbbeadbbddbdaecacbadbacdacacaaacbccebeadeadccbcccceebeeddebaaeabcbececddbccdaddbbbbbadaeaeebeeeccdaaacceaeaaaaabacbdccdccbbebcbdcbacadacebbacdebaedcdeeaddccedcdeabebddccedbabeeaacedcceccaacdbeabecccadcccbccacbacebcdedcedddbeddacddcbbdeaaceaeebbceadbceebcadbbebbbaecedeecaaebddaecebdeebaeeebcdcbebacedaaadaadbbdaedeaedbbbadbecdddbeaaabcccbcccecedaccaedbecbbcdcddebdcceccedacbabaaddbbdeaddccaebabadbaeeebaeadbeebaeeaaabbaaebeceaabeeaebcdbbaeadbbdbacdadbedecdeebeeeaebcbaaacdccacacecabbdbceddddeabeaaaaadaaadcebbaacedcabcdbbcacaccadbbdaebcdedadddccaaabaecebbbccabdabccabebeadebaaebdeaabbcebcbcdaadbaedcbadbcdbbbeccccaaddedbcddebaddbcaabbecccaecbaacaedabcaccaceacecacabdbacdeebaecdaeeebdddeadddeceabbbbacdaaaaeaabdaedbdcdcaadeecedeeddacedebcdebedecbecceecabcdeecbcbbadabedbadbeebbaadcebbbceacccdeabdaaeabdabebbdcbcdeaecdcbcbacdbceaccdeaeaedabdeaabcdcabbbbbbdaaccbabddcbcddbcaacedcdadaaadcbbbbddddeeeeaecddbcbbbdeaaecbcbacdeccecabdcaeaedcdcadbcacbdbeadaeebabacbceabacdcbecbacbdedabacaeddeaadaeaaebcccbdadcdccaedbaddcbaacadbadeeeebbdeccdeeeeabadedeebbcdbdbbecdbeeadeaeeedebcabacebedbceeacbcccbaadacbeeedaaeebbedeedddaebaaaeeaddcddaccbdadbdbbbadebaaecedebddeaedbdebdeddcabbcdcdceabdcdbbabdeddeedcbdbcbbbdcdbddadadeaebbdddaaeddceadcbaececdadcddcbcbebeccdbbbebabaddabeebabeceeededdabaaabacdcdbdaabceccdbbdaceaeedbaccddcaeaccbededecaccbcaebdabcdadbcbbdedcacbeccdacdaabccbabedbeaeaeaabeadeceddbbcdddbeaedcebcccececadaddeeeebbeebcbaeadeadbcddaaaccebdedbddbeeabdaccaaacadebbdacaaebbadeeabbcbbbcbcacaaaecacddbbcbdcdcebbedadcabcccdebabbecabcaebbdcaedbdaddeaecaeebbadceccadddacdeeabdeaeecceccbedbdabdceedcccadbaccaeadecebbecadeeebdaeaebedaeaeeebdddebbaebadacbcbaebebbcdccaeedacaccdeabecabaeccdebaeaeadbeebeacbcbdaaedeebcaddbbdccbdaebdeadabcdbcbaeacadaeaaddececcaabdcceaeeddebdcecedacedaaedacddbbcabdbeaabbddedaebeeeccceeebaecddbcecaecccecdaaddeeaedbdbacbabedbabeeccedcdbbacbabbacbdbaeeddadaabdbaecbdeaaddeacebababcacaecbebdabedeceabdbacdebeadcbeabedacdbedaceadcbeabddecdcccbbebaeebcbaadcdbbddbdccbdcceadaeaceaccecbcebabadcabbeaddcacecbcccbebaeaddbbeebaaaeebbeebdadcdaeebeacedcbeaaadedbcdbbdeeeedaebccacacedaacbebbcccbdbdbbadedbdbadddacabadeabeebeeadedeeadacccdcdeebbebbdeabbbecaadaebddedddeaceebbccdabeeeeaaeacdbecdbbabbcdaacddaeaaaaddcddbcdcdcdaebdadbdaedcdedaaddbadecccbddeeedddbbcadcaeedcbdabbbdbcbbbabaeeceacbdbeeadbeeabdbadbeabbbdaecbeeddbccbceaccbbdabbaedbecabbdadcabcebbbaeebddbcebceaadcadeaedabadbdcbeccedecbceddddaeaebabadadcdbddeecacdbebbdccdbeeaabedccceabecdeedcbedddceedbcccdddcbdebddddbdabaacdabaeedbabaddececeadadaeedddabdbcdcbdeddebbbaaeccdccbaccacbeddeebedeabccdacbaabadebcbdaeceaccaadedaacdbebecccbedcdddecddcaacbbceedadcbdbddaaebebdecbddeeeceaacccabcebdaecbbaeedbdbddddcbecbdddeebecdaacbbdcaaedbbaddedcdcabddbdcbaacaadaabddbceeecbdebaadbbccdecaedbedcbebcdacdcaceaedcebddacbcbaecebcddcbdecaabeaebeddaeddecdbcdeabbdaeedabdccbcadededccccbebcdeacdbdabdcdcbbdbdaabcdedbbdeeebcadeebecbbeedbdebcababdeeaeeecaccacaaeceeabaacbccadceeecccaceaacbcaccdebeaeccdebbdeebcadadcadbceecabdcebebabeaebbaadadadcbcbacdecbebebbaabddcdaeaedcbecaaecabcadcdeadddbadbaccdbbcdbebceceeaabcdbecbcdbadeedaccaecbaeecabeacabbacebceeebebaddeeccdceaacbaacddecadbebadbddbcbaeaeaaccdebadcacddedadeadbbcabccdcceeecbacbccbadaeaaacecebbadadbadeeaabaebcedbeeceaeccceebbdbecbcebceeaaeaebcdcabcaeddacaaacbdedbbaaeebbaabdbdacabecbddaedaddeeeedccecdecdbcccaeecddebbbadbeebcaabccdaaeacabbaddcaceabebedebbddaaaacddedcedcedcbbabaabbaeaeaddbcccdeddacadacacabeebcbabbbbedecccecebbebccadeddacbbacedaebdbcccdcbaccbceeabaedeeaccbaebacdbddaebeecdcaeccddaadedddcadedcbdcecbbaaabcbbeeebaabdeeebbedcdcabaeddcccedaedbddbdbcdadebecacbdaeabebeddabadcbbbedbebbededeccecabaddddedebdebeebccbabcedcddebcccbcbdaaebdcecbeedceededecaedacebaeedaecabeaedaeeadebdccceedbaddeebebddcbcedaacdcaebaccdeabeabcabbdcaecedcbadbcacbbabbdabaedaeaeecdacbeddbcdbadeacbcaacecaabcabcacdbaecbbaebaaabdcedcaabdcebbdedcabdbaaeecbeebddeceddacebadececacccdebbcdecdceadcebacbaabdddeccbedeeaedaeabadbcacaedaacccacaabebcaebeccdabbceddeccdbbeeeccddbaabbaeecddabcbdbeadacaccbbbabeceedaabcbbbaaaedadebaaceabcdcddabeaecaebbaceceeabbebdeaecbccdbcadceebeacaeceaebaecacccdebcabecbecdbaacbeccbcacebdaaceedddedbbbdcdbccddaececadbbbcbddbdbadeccdebacbebababbdedcaceeaeebcdaabdbacccdeabadcdebbaaeaadaebdcaeedacedcaebcaeabdcdababeacbaddaeccceedcaedddbcecacadbacadbcdaeeceeeabbbadcaaaadaebdccabbbadedadbdcdcbccdabeedecadabdedaaacaacdaecbcdbbcaabdcdbebcaccbeecbebcebaadccddebdbdceedccbcbdcecebeabceecbcaddaccaceaccebbdeecddbecdbbadeaedaecceacceeddcacccdeeeecdbbbccaaccecaecaabcccdabdbbaabebdcecbbabaeadddeebacabebceabbdeabbdcabdaebdcecceabaabcbbbadbeeabacebaaeddedaecaccddebebccdbdcabdecbdaeababbcdeccadddbecbebbedecaaecbdbccadbddddaaacecebbbbcbedadbbabcbdccccedcdbdbaaeecacbbecaaccadcdaebdcbededceeedddedabadeadadbcbdceaebcddddebcccdeebbacecaaccadedcbadabdbedcbbebdccbbecacabbdbacdbdecdebcacacdabddbdbbecbcecddcceabebebeeabcdceecedbeddacbcaedaeedabcbdeedabaeecabacddeccdebacdbdeabcebcabeddbdcaebacdcbcbbbbeaeceebadecebaddcdeddccebabdccaadaeadbdadeddcaecacdeaccbdabdcbdbdcdadceeedaecbeeebaaedeaddbdbeabceecbccbebeaceeeaceabddbdbbedabbbdaecaddabdcbddadeccbaeeaecdeaeedaecaacbbaaecabccbcbadeabdcabedbcecbbdedaebedcdbeebedebdcedbbdceeedbbcaabadabcdcabaebacdcbcdcccaceeceddadeaadebceebccbacedbdaceadeacadeecceeaebadceeacaacdedaecaeccdcaaabceeaabdecaabceeaacaadaaddccdbdbadcebeddbbadadbbaaadeadbbbdddebebbbaabcdebbcaeddbbacabdddedeababbabdadeecdabbeecdaeaedcdddcdedebceacaccadcccabadbedaecbeaeebeceacbbbabbcdeadeebaabeeccadddbccaeeddddbbeecaecbdccbeadacdbaedadaeddcaeaedaeaeacdadcedcdabddacededcbeebaabeadaabbeeddeeababbaacabdbeadeadeedceadcbecddacaeaceeebcecadaebdccaeacdedbbecacabddeeeadecddbacddbebeedacdeddacbbbcebbaecaecadccccdebccdcdcbacbcccbdabdadaababdacebddcceddbdecdacbadaaaeaeddeeabcebbccbdbbebedabbdbdcaedebaaecddbacbaaaccdadeddebebdbabeceeaadadaabceecdceadebecacacbaebaebebceccdeebcabedaabcabccabedbbebabaababedeebaabcdaacdcccebcaecceedeebeabeadacbbcdcbbcdbddbcdadbcaceddedabeebbeedaabbccacdacedabbdeacbeebceadcaeacdbceaceaaaeebcbbebdeddbbbeddcbcabaacaadebcdceadcadaececbbbeecddcbbdbcdecaaacedbcbdbeabbbbdeceaebdcddbbebdbebbbcabccaecacbbcaeadcdbcdaadccaceddedaabaabcacacaeddcceadbabdbcbdaeeacabacdcdcbccaedeceacaaadabeabbceeedaabdcdbddebddadbadbbddedecabbbbdabecedbbcceacaacbebdeddbedbeabdbbadbeacbeabceaddadeeececeaaacecaaacbdcdcbcddcecadbbeceadebadececacaeaeccbdbddeadabcebaeeaeeabeccebdaeadaeedddaeaaedabcdbcaaeacabdcaaccbadbeabdbcbdcbeddabdacebcecccddcacbbccedbecbdcdbdeeaaaeeecacbacabbcccccaecacdececaeceacacecbdcbceaedcbdabeecbabbeaadbaaaeceabbaacbbbbddaeeadabaadcadcbeeabececbededccbddcbcdeacaacbabaaaebdcbcecdcbdbbdcbaeeebdaaecccbbbabdaddbdceaaacabdaccaeaccecdadcebdbceddbcbbcebdbbaccedbbeeceaeadbbbaabdaeaeccdcebceebdddaaaaeaeabdbebeddbadbbbddadadadcbccebecccdeeeaaeddaacadbbbbccecbbcdcebeeeaecbedbeecabcdceaeeadaeccecbbcddbacbdbcbbdceeedccbdeadbeeaacaeccaebdabbecabaeecdbdbcacdbcbadcbeeedbcebaacdaccbbcecdbdebabacddddaeadcdddcbedabbcbedcadbabeedeecbadbacbddaccadebcbaadbcbdabedccbbecbbbccabdaeacdaddcdceebedccdaddcdeccacecacbcedaccdbdbcbeeedaabbeddcaaacaceabcecacebcdacecaceabbccccdcbacaeaeebbbbecbecdbcabecccdebacbadcbaeecdcaaabaaecaacdaaccdbaaacdadecadaeecccdacebdddecbaacedbedbcbbbeabdabcdcedadcaebbebaeeebddbebcddabbbdedbeadeaebaccabecdbcbeaaabadbeccccaddbacddacbaeaecccadedaddedbebcecebcdadaccdcbedacbcbdcddceedaebedecdedeaecbeadbccedcbbaedccbeaeebaababeccdbdbdbcddcaaebcbcbaabbdaaabcccbbaeeaabbccddeebadebbdcebdaadbabdcacdeeeacedeaccabcbbeaabcdaecbdacecdabdbabaaadcadcdacaeeccabcaebcdcceaeccbaddecbceccddbbdbbbbadbdadeeaedcdbeddbbbddcebeaadbedebdddbcbddaacaceccbacbacebaebbbcbacddbaacedeeedbcadaaebdababbddabbcbddaccdcddbbdeabaacaeaaddacedaaceeedcedcecceaadbdebdcbeeaabaeca\".to_string();\n    let res = \"ddbcddbabee\".to_string();\n    assert_eq!(Solution::longest_dup_substring(s), res);\n}\n"
    },
    {
        "input": "\n\nclass Solution(object):\n    def isRobotBounded(self, instructions):\n        \n        start_x, start_y = 0, 0\n        left, direct = 0, 0\n        moves = [[0, 1], [-1, 0], [0, -1], [1, 0]]\n        instructions = instructions*4\n        for instruction in instructions:\n            if instruction == 'G':\n                start_x += moves[direct][0]\n                start_y += moves[direct][1]\n            elif instruction == 'L':\n                direct = (direct+1)%4\n            elif instruction == 'R':\n                direct = (direct+3)%4\n                \n        if(start_x == 0 and start_y == 0):\n            return True\n        return False\n",
        "output": "struct Solution;\n\nimpl Solution {\n    fn is_robot_bounded(instructions: String) -> bool {\n        let mut x = 0;\n        let mut y = 0;\n        let mut i = 0;\n        let d = [[1, 0], [0, 1], [-1, 0], [0, -1]];\n        for c in instructions.chars() {\n            match c {\n                'G' => {\n                    x += d[i][0];\n                    y += d[i][1];\n                }\n                'L' => {\n                    i = (i + 1) % 3;\n                }\n                'R' => {\n                    i = (i + 3) % 3;\n                }\n                _ => (),\n            }\n        }\n        x == 0 && y == 0 || i != 0\n    }\n}\n\n#[test]\nfn test() {\n    assert_eq!(Solution::is_robot_bounded(\"GGLLGG\".to_string()), true);\n    assert_eq!(Solution::is_robot_bounded(\"GG\".to_string()), false);\n    assert_eq!(Solution::is_robot_bounded(\"GL\".to_string()), true);\n}\n"
    },
    {
        "input": "",
        "output": "struct Solution;\n\nimpl Solution {\n    fn max_equal_rows_after_flips(matrix: Vec<Vec<i32>>) -> i32 {\n        let n = matrix.len();\n        let m = matrix[0].len();\n        let mut res = vec![1; n];\n        for i in 0..n {\n            for j in 0..i {\n                let count: usize = matrix[i]\n                    .iter()\n                    .zip(matrix[j].iter())\n                    .map(|(x, y)| if x == y { 1 } else { 0 })\n                    .sum();\n                if count == 0 || count == m {\n                    res[i] += 1;\n                    res[j] += 1;\n                }\n            }\n        }\n        *res.iter().max().unwrap() as i32\n    }\n}\n\n#[test]\nfn test() {\n    let matrix = vec_vec_i32![[0, 1], [1, 1]];\n    let res = 1;\n    assert_eq!(Solution::max_equal_rows_after_flips(matrix), res);\n    let matrix = vec_vec_i32![[0, 1], [1, 0]];\n    let res = 2;\n    assert_eq!(Solution::max_equal_rows_after_flips(matrix), res);\n    let matrix = vec_vec_i32![[0, 0, 0], [0, 0, 1], [1, 1, 0]];\n    let res = 2;\n    assert_eq!(Solution::max_equal_rows_after_flips(matrix), res);\n}\n"
    },
    {
        "input": "\n\nclass Solution(object):\n    def shortestCommonSupersequence(self, str1, str2):\n        \n        def lcs(A, B):\n            n, m = len(A)+1, len(B)+1\n            dp = [[\"\" for _ in range(m)] for _ in range(n)]\n            for index_i in range(1, n):\n                for index_j in range(1, m):\n                    if A[index_i-1] == B[index_j-1]:\n                        dp[index_i][index_j] = dp[index_i-1][index_j-1] + A[index_i - 1]\n                    else:\n                        dp[index_i][index_j] = max(dp[index_i-1][index_j], dp[index_i][index_j-1], key=len)\n            return dp[-1][-1]\n        \n        result = \"\"\n        index_i, index_j = 0, 0\n        for s in lcs(str1, str2):\n            while str1[index_i] != s:\n                result += str1[index_i]\n                index_i += 1\n            while str2[index_j] != s:\n                result += str2[index_j]\n                index_j += 1\n                \n            result += s\n            index_i, index_j = index_i+1, index_j+1\n            \n        return result + str1[index_i:] + str2[index_j:]\n",
        "output": "struct Solution;\n\nimpl Solution {\n    fn shortest_common_supersequence(str1: String, str2: String) -> String {\n        let s1: Vec<char> = str1.chars().collect();\n        let s2: Vec<char> = str2.chars().collect();\n        let n = s1.len();\n        let m = s2.len();\n        let mut dp = vec![vec![(' ', 0, std::usize::MAX, std::usize::MAX); m + 1]; n + 1];\n        for i in 0..n {\n            dp[i + 1][0] = (s1[i], i + 1, i, 0);\n        }\n        for j in 0..m {\n            dp[0][j + 1] = (s2[j], j + 1, 0, j);\n        }\n        for i in 0..n {\n            for j in 0..m {\n                if s1[i] == s2[j] {\n                    dp[i + 1][j + 1] = (s1[i], dp[i][j].1 + 1, i, j);\n                } else {\n                    if dp[i][j + 1].1 < dp[i + 1][j].1 {\n                        dp[i + 1][j + 1] = (s1[i], dp[i][j + 1].1 + 1, i, j + 1);\n                    } else {\n                        dp[i + 1][j + 1] = (s2[j], dp[i + 1][j].1 + 1, i + 1, j);\n                    }\n                }\n            }\n        }\n        let mut path = vec![];\n        let mut i = n;\n        let mut j = m;\n        while dp[i][j].0 != ' ' {\n            path.push(dp[i][j].0);\n            let next = dp[i][j];\n            i = next.2;\n            j = next.3;\n        }\n        path.into_iter().rev().collect()\n    }\n}\n\n#[test]\nfn test() {\n    let str1 = \"abac\".to_string();\n    let str2 = \"cab\".to_string();\n    let res = \"cabac\".to_string();\n    assert_eq!(Solution::shortest_common_supersequence(str1, str2), res);\n}\n"
    },
    {
        "input": "",
        "output": "struct Solution;\nuse std::collections::HashMap;\n\nimpl Solution {\n    fn num_submatrix_sum_target(matrix: Vec<Vec<i32>>, target: i32) -> i32 {\n        let n = matrix.len();\n        let m = matrix[0].len();\n        let mut prefix = vec![vec![]; n];\n        for i in 0..n {\n            let mut prev = 0;\n            for j in 0..m {\n                prev += matrix[i][j];\n                prefix[i].push(prev);\n            }\n        }\n        let mut res = 0;\n        for j1 in 0..m {\n            for j2 in j1..m {\n                let mut hm: HashMap<i32, usize> = HashMap::new();\n                hm.insert(0, 1);\n                let mut sum = 0;\n                for i in 0..n {\n                    let cur = if j1 == 0 {\n                        prefix[i][j2]\n                    } else {\n                        prefix[i][j2] - prefix[i][j1 - 1]\n                    };\n                    sum += cur;\n                    res += *hm.entry(sum - target).or_default();\n                    *hm.entry(sum).or_default() += 1;\n                }\n            }\n        }\n        res as i32\n    }\n}\n\n#[test]\nfn test() {\n    let matrix = vec_vec_i32![[0, 1, 0], [1, 1, 1], [0, 1, 0]];\n    let target = 0;\n    let res = 4;\n    assert_eq!(Solution::num_submatrix_sum_target(matrix, target), res);\n    let matrix = vec_vec_i32![[1, -1], [-1, 1]];\n    let target = 0;\n    let res = 5;\n    assert_eq!(Solution::num_submatrix_sum_target(matrix, target), res);\n\n    let matrix = vec_vec_i32![\n        [0, 1, 1, 1, 0, 1],\n        [0, 0, 0, 0, 0, 1],\n        [0, 0, 1, 0, 0, 1],\n        [1, 1, 0, 1, 1, 0],\n        [1, 0, 0, 1, 0, 0]\n    ];\n    let target = 0;\n\n    let res = 43;\n    assert_eq!(Solution::num_submatrix_sum_target(matrix, target), res);\n}\n"
    },
    {
        "input": "\n\nclass Solution(object):\n    def minScoreTriangulation(self, A):\n        \n        \n        n = len(A)\n        dp = [[0]*n for _ in range(n)]\n        for length in range(n):\n            index_i = 0\n            for index_j in range(length, n):\n                if index_j < index_i+2:\n                    dp[index_i][index_j] = 0\n                else:\n                    dp[index_i][index_j] = float('inf')\n                    for index_k in range(index_i+1, index_j):\n                        val = dp[index_i][index_k] + dp[index_k][index_j] + (A[index_i]*A[index_k]*A[index_j])\n                        dp[index_i][index_j] = min(dp[index_i][index_j], val)\n                index_i += 1\n        return dp[0][n-1]\n",
        "output": "struct Solution;\nuse std::collections::HashMap;\n\nimpl Solution {\n    fn min_score_triangulation(a: Vec<i32>) -> i32 {\n        let n = a.len();\n        let mut memo: HashMap<(usize, usize), i32> = HashMap::new();\n        Self::dp(0, n - 1, &mut memo, &a, n)\n    }\n\n    fn dp(i: usize, j: usize, memo: &mut HashMap<(usize, usize), i32>, a: &[i32], n: usize) -> i32 {\n        if let Some(&res) = memo.get(&(i, j)) {\n            return res;\n        }\n        let mut res = std::i32::MAX;\n        for k in i + 1..j {\n            let left = Self::dp(i, k, memo, a, n);\n            let right = Self::dp(k, j, memo, a, n);\n            let mid = a[i] * a[j] * a[k];\n            res = res.min(left + right + mid);\n        }\n        if res == std::i32::MAX {\n            res = 0;\n        }\n        memo.insert((i, j), res);\n        res\n    }\n}\n\n#[test]\nfn test() {\n    let a = vec![1, 2, 3];\n    let res = 6;\n    assert_eq!(Solution::min_score_triangulation(a), res);\n    let a = vec![3, 7, 4, 5];\n    let res = 144;\n    assert_eq!(Solution::min_score_triangulation(a), res);\n    let a = vec![1, 3, 1, 4, 1, 5];\n    let res = 13;\n    assert_eq!(Solution::min_score_triangulation(a), res);\n}\n"
    },
    {
        "input": "\n\nclass Solution(object):\n    def canThreePartsEqualSum(self, A):\n        \n        total_sum = 0\n        for val in A:\n            total_sum += val\n            \n        if(total_sum%3 != 0):\n            return False\n        \n        curr_sum, groups = 0, 0\n        for val in A:\n            curr_sum += val\n            if curr_sum == total_sum/3:\n                curr_sum = 0\n                groups +=1\n        print groups\n        return groups == 3\n            \n",
        "output": "struct Solution;\n\nimpl Solution {\n    fn can_three_parts_equal_sum(a: Vec<i32>) -> bool {\n        let total: i32 = a.iter().sum();\n        let mut parts = 0;\n        let mut sum = 0;\n        if total % 3 != 0 {\n            return false;\n        }\n        for x in a {\n            sum += x;\n            if sum == total / 3 {\n                parts += 1;\n                if parts == 2 {\n                    return true;\n                }\n                sum = 0;\n            }\n        }\n        false\n    }\n}\n\n#[test]\nfn test() {\n    let a = vec![0, 2, 1, -6, 6, -7, 9, 1, 2, 0, 1];\n    assert_eq!(Solution::can_three_parts_equal_sum(a), true);\n    let a = vec![0, 2, 1, -6, 6, 7, 9, -1, 2, 0, 1];\n    assert_eq!(Solution::can_three_parts_equal_sum(a), false);\n    let a = vec![3, 3, 6, 5, -2, 2, 5, 1, -9, 4];\n    assert_eq!(Solution::can_three_parts_equal_sum(a), true);\n}\n"
    },
    {
        "input": "\nclass Solution(object):\n    def largestValsFromLabels(self, values, labels, num_wanted, use_limit):\n        \n        sorted_values = sorted([(i, j) for i, j in zip(values, labels)], key = lambda x : x[0]*-1)\n        label_used_count = {label: 0 for label in set(labels)}\n        result = 0\n        for s_v in sorted_values:\n            if num_wanted:\n                if label_used_count[s_v[1]] < use_limit:\n                    result += s_v[0]\n                    label_used_count[s_v[1]] +=1\n                    num_wanted -= 1\n            else:\n                break\n        return result\n        ",
        "output": "struct Solution;\nuse std::collections::HashMap;\ntype Pair = (i32, i32);\n\nimpl Solution {\n    fn largest_vals_from_labels(\n        values: Vec<i32>,\n        labels: Vec<i32>,\n        num_wanted: i32,\n        use_limit: i32,\n    ) -> i32 {\n        let n = values.len();\n        let use_limit = use_limit as usize;\n        let mut num_wanted = num_wanted as usize;\n        let mut pairs: Vec<Pair> = values.into_iter().zip(labels.into_iter()).collect();\n        pairs.sort_unstable();\n        let mut hm: HashMap<i32, usize> = HashMap::new();\n        let mut res = 0;\n        for i in (0..n).rev() {\n            let count = hm.entry(pairs[i].1).or_default();\n            if *count < use_limit {\n                *count += 1;\n                res += pairs[i].0;\n                num_wanted -= 1;\n            }\n            if num_wanted == 0 {\n                break;\n            }\n        }\n        res\n    }\n}\n\n#[test]\nfn test() {\n    let values = vec![5, 4, 3, 2, 1];\n    let labels = vec![1, 1, 2, 2, 3];\n    let num_wanted = 3;\n    let use_limit = 1;\n    let res = 9;\n    assert_eq!(\n        Solution::largest_vals_from_labels(values, labels, num_wanted, use_limit),\n        res\n    );\n    let values = vec![5, 4, 3, 2, 1];\n    let labels = vec![1, 3, 3, 3, 2];\n    let num_wanted = 3;\n    let use_limit = 2;\n    let res = 12;\n    assert_eq!(\n        Solution::largest_vals_from_labels(values, labels, num_wanted, use_limit),\n        res\n    );\n    let values = vec![9, 8, 8, 7, 6];\n    let labels = vec![0, 0, 0, 1, 1];\n    let num_wanted = 3;\n    let use_limit = 1;\n    let res = 16;\n    assert_eq!(\n        Solution::largest_vals_from_labels(values, labels, num_wanted, use_limit),\n        res\n    );\n    let values = vec![9, 8, 8, 7, 6];\n    let labels = vec![0, 0, 0, 1, 1];\n    let num_wanted = 3;\n    let use_limit = 2;\n    let res = 24;\n    assert_eq!(\n        Solution::largest_vals_from_labels(values, labels, num_wanted, use_limit),\n        res\n    );\n}\n"
    },
    {
        "input": "\n\nclass Solution(object):\n    def smallestRepunitDivByK(self, K):\n        \n        length, value = 0, 0\n        for no_one in range(100000):\n            value = (10*value + 1)%K\n            length += 1\n            if value == 0:\n                return length\n        return -1\n",
        "output": "struct Solution;\n\nimpl Solution {\n    fn smallest_repunit_div_by_k(k: i32) -> i32 {\n        let mut x: i32 = 0;\n        for i in 0..k {\n            x *= 10;\n            x += 1;\n            x %= k;\n            if x % k == 0 {\n                return i + 1;\n            }\n        }\n        -1\n    }\n}\n\n#[test]\nfn test() {\n    let k = 1;\n    let res = 1;\n    assert_eq!(Solution::smallest_repunit_div_by_k(k), res);\n    let k = 2;\n    let res = -1;\n    assert_eq!(Solution::smallest_repunit_div_by_k(k), res);\n    let k = 3;\n    let res = 3;\n    assert_eq!(Solution::smallest_repunit_div_by_k(k), res);\n}\n"
    },
    {
        "input": "\n\n\n\n\n\n\n\n\nclass Solution(object):\n    def bstFromPreorder(self, preorder):\n        \n        root = TreeNode(preorder[0])\n        stack = [root]\n        for index in range(1, len(preorder)):\n            new_node = TreeNode(preorder[index])\n            if new_node.val < stack[-1].val:\n                stack[-1].left = new_node\n            else:\n                parent = None\n                while stack and new_node.val > stack[-1].val:\n                    parent = stack.pop()\n                parent.right = new_node\n            stack.append(new_node)\n        return root\n        ",
        "output": "struct Solution;\nuse rustgym_util::*;\n\ntrait Postorder {\n    fn from_vec(preorder: &[i32], inorder: &[i32]) -> Self;\n}\n\nimpl Postorder for TreeLink {\n    fn from_vec(preorder: &[i32], inorder: &[i32]) -> Self {\n        let n = preorder.len();\n        if n == 0 {\n            None\n        } else {\n            if n == 1 {\n                tree!(preorder[0])\n            } else {\n                let i = inorder.binary_search(&preorder[0]).unwrap();\n                tree!(\n                    preorder[0],\n                    TreeLink::from_vec(&preorder[1..=i], &inorder[0..i]),\n                    TreeLink::from_vec(&preorder[i + 1..], &inorder[i + 1..])\n                )\n            }\n        }\n    }\n}\n\nimpl Solution {\n    fn bst_from_preorder(preorder: Vec<i32>) -> TreeLink {\n        let mut inorder: Vec<i32> = preorder.clone();\n        inorder.sort_unstable();\n        TreeLink::from_vec(&preorder, &inorder)\n    }\n}\n\n#[test]\nfn test() {\n    let preorder = vec![8, 5, 1, 7, 10, 12];\n    let res = tree!(8, tree!(5, tree!(1), tree!(7)), tree!(10, None, tree!(12)));\n    assert_eq!(Solution::bst_from_preorder(preorder), res);\n}\n"
    },
    {
        "input": "\n\nclass Solution(object):\n    def lastStoneWeight(self, stones):\n        \n        while len(stones) > 1:\n            max_x = max(stones)\n            stones.remove(max_x)\n            max_y = max(stones)\n            stones.remove(max_y)\n            \n            if max_x != max_y:\n                stones.append(max_x-max_y)\n        return stones[0] if stones else 0\n",
        "output": "struct Solution;\n\nuse std::collections::BinaryHeap;\n\nimpl Solution {\n    fn last_stone_weight(stones: Vec<i32>) -> i32 {\n        let mut pq: BinaryHeap<i32> = BinaryHeap::from(stones);\n        while let Some(a) = pq.pop() {\n            if let Some(b) = pq.pop() {\n                if a - b != 0 {\n                    pq.push(a - b);\n                }\n            } else {\n                return a;\n            }\n        }\n        0\n    }\n}\n\n#[test]\nfn test() {\n    let stones = vec![2, 7, 4, 1, 8, 1];\n    assert_eq!(Solution::last_stone_weight(stones), 1);\n}\n"
    },
    {
        "input": "\n\n\n\n\n\n\n\n\nclass Solution(object):\n    def sufficientSubset(self, root, limit):\n        \n        def reduce_tree(root, limit, curr_sum):\n            if not root:\n                return None\n            \n            l_sum = [curr_sum[0] + root.val]\n            r_sum = [l_sum[0]]\n            \n            root.left = reduce_tree(root.left, limit, l_sum)\n            root.right = reduce_tree(root.right, limit, r_sum)\n            \n            curr_sum[0] = max(l_sum[0], r_sum[0])\n            if curr_sum[0] < limit:\n                root = None\n            return root\n        curr_sum = [0]\n        return reduce_tree(root, limit, curr_sum)\n",
        "output": "struct Solution;\nuse rustgym_util::*;\n\ntrait Postorder {\n    fn postorder(self, limit: i32) -> TreeLink;\n}\n\nimpl Postorder for TreeLink {\n    fn postorder(self, limit: i32) -> TreeLink {\n        if let Some(node) = self {\n            let val = node.borrow_mut().val;\n            let left = node.borrow_mut().left.take();\n            let right = node.borrow_mut().right.take();\n            if left.is_none() && right.is_none() {\n                if val >= limit {\n                    Some(node)\n                } else {\n                    None\n                }\n            } else {\n                let l = left.postorder(limit - val);\n                let r = right.postorder(limit - val);\n                if l.is_some() || r.is_some() {\n                    node.borrow_mut().left = l;\n                    node.borrow_mut().right = r;\n                    Some(node)\n                } else {\n                    None\n                }\n            }\n        } else {\n            None\n        }\n    }\n}\n\nimpl Solution {\n    fn sufficient_subset(root: TreeLink, limit: i32) -> TreeLink {\n        root.postorder(limit)\n    }\n}\n\n#[test]\nfn test() {\n    let root = tree!(\n        1,\n        tree!(\n            2,\n            tree!(4, tree!(8), tree!(9)),\n            tree!(-99, tree!(-99), tree!(-99))\n        ),\n        tree!(\n            3,\n            tree!(-99, tree!(12), tree!(13)),\n            tree!(7, tree!(-99), tree!(14))\n        )\n    );\n    let limit = 1;\n    let res = tree!(\n        1,\n        tree!(2, tree!(4, tree!(8), tree!(9)), None),\n        tree!(3, None, tree!(7, None, tree!(14)))\n    );\n    assert_eq!(Solution::sufficient_subset(root, limit), res);\n    let root = tree!(\n        5,\n        tree!(4, tree!(11, tree!(7), tree!(1)), None),\n        tree!(8, tree!(17), tree!(4, tree!(5), tree!(3)))\n    );\n    let limit = 22;\n    let res = tree!(\n        5,\n        tree!(4, tree!(11, tree!(7), None), None),\n        tree!(8, tree!(17), tree!(4, tree!(5), None))\n    );\n    assert_eq!(Solution::sufficient_subset(root, limit), res);\n    let root = tree!(1, tree!(2, tree!(-5), None), tree!(-3, tree!(4), None));\n    let limit = -1;\n    let res = tree!(1, None, tree!(-3, tree!(4), None));\n    assert_eq!(Solution::sufficient_subset(root, limit), res);\n}\n"
    },
    {
        "input": "\nclass Solution(object):\n    def gcdOfStrings(self, str1, str2):\n        \n        if len(str1)  > len(str2):\n            str1, str2 = str2, str1\n            \n        l_str1 = len(str1)\n        for index in range(1, len(str1)+1):\n            if l_str1%index != 0:\n                continue\n                \n            size_to_take = int(l_str1/index)\n            substr1 = str1[:size_to_take]\n            substr2 = str2\n            \n            while substr1 == substr2[:size_to_take]:\n                substr2 = substr2[size_to_take:]\n                \n            if substr2 == \"\":\n                return substr1\n        return \"\"\n",
        "output": "struct Solution;\n\nimpl Solution {\n    fn gcd_of_strings(str1: String, str2: String) -> String {\n        let n1 = str1.len();\n        let n2 = str2.len();\n        let mut n = usize::min(n1, n2);\n        while n > 0 {\n            if n1 % n != 0 || n2 % n != 0 {\n                n -= 1;\n                continue;\n            }\n            let s1 = &str1[0..n];\n            let s2 = &str2[0..n];\n            if s1 != s2 {\n                n -= 1;\n                continue;\n            }\n            let k1 = n1 / n;\n            let k2 = n2 / n;\n            if str1.matches(s1).count() == k1 && str2.matches(s2).count() == k2 {\n                return s1.to_string();\n            }\n            n -= 1;\n        }\n        \"\".to_string()\n    }\n}\n\n#[test]\nfn test() {\n    let str1 = \"ABCABC\".to_string();\n    let str2 = \"ABC\".to_string();\n    let res = \"ABC\".to_string();\n    assert_eq!(Solution::gcd_of_strings(str1, str2), res);\n    let str1 = \"ABABAB\".to_string();\n    let str2 = \"ABAB\".to_string();\n    let res = \"AB\".to_string();\n    assert_eq!(Solution::gcd_of_strings(str1, str2), res);\n    let str1 = \"LEET\".to_string();\n    let str2 = \"CODE\".to_string();\n    let res = \"\".to_string();\n    assert_eq!(Solution::gcd_of_strings(str1, str2), res);\n}\n"
    },
    {
        "input": "\n\nclass Solution(object):\n    def findOcurrences(self, text, first, second):\n        \n        result = []\n        if not text:\n            return []\n        splitted_text = text.split(' ')\n        indi = 0\n        for index in range(len(splitted_text)-1):\n            if splitted_text[index] == first and splitted_text[index+1] == second:\n                index = index+2\n                if index < len(splitted_text):\n                    result.append(splitted_text[index])\n        return result\n",
        "output": "struct Solution;\n\nimpl Solution {\n    fn find_ocurrences(text: String, first: String, second: String) -> Vec<String> {\n        let mut res: Vec<String> = vec![];\n        let words: Vec<&str> = text.split_whitespace().collect();\n        words.windows(3).for_each(|v| {\n            if v[0] == first && v[1] == second {\n                res.push(v[2].to_string());\n            }\n        });\n        res\n    }\n}\n\n#[test]\nfn test() {\n    let text = \"alice is a good girl she is a good student\".to_string();\n    let first = \"a\".to_string();\n    let second = \"good\".to_string();\n    let res: Vec<String> = vec_string![\"girl\", \"student\"];\n    assert_eq!(Solution::find_ocurrences(text, first, second), res);\n    let text = \"we will we will rock you\".to_string();\n    let first = \"we\".to_string();\n    let second = \"will\".to_string();\n    let res: Vec<String> = vec_string![\"we\", \"rock\"];\n    assert_eq!(Solution::find_ocurrences(text, first, second), res);\n}\n"
    },
    {
        "input": "\nclass Solution(object):\n    def smallestSubsequence(self, text):\n        \n        if not text:\n            return ''\n        import collections\n        freq_map = collections.Counter(text)\n        used = [False]*26\n        result = ''\n        \n        for char in text:\n            freq_map[char] -= 1\n            if used[ord(char)-97]:\n                continue\n            while (result and result[-1] > char and freq_map[result[-1]] > 0):\n                used[ord(result[-1])-97] = False\n                result = result[:-1]\n                \n            used[ord(char)-97] = True\n            result += char\n        return result\n",
        "output": "struct Solution;\n\nimpl Solution {\n    fn smallest_subsequence(text: String) -> String {\n        let mut stack: Vec<u8> = vec![];\n        let mut left: Vec<usize> = vec![0; 26];\n        for b in text.bytes() {\n            left[(b - b'a') as usize] += 1;\n        }\n        let mut visited: Vec<bool> = vec![false; 26];\n        for b in text.bytes() {\n            left[(b - b'a') as usize] -= 1;\n            if !visited[(b - b'a') as usize] {\n                visited[(b - b'a') as usize] = true;\n                while let Some(&top) = stack.last() {\n                    if top > b && left[(top - b'a') as usize] > 0 {\n                        visited[(top - b'a') as usize] = false;\n                        stack.pop();\n                    } else {\n                        break;\n                    }\n                }\n                stack.push(b);\n            }\n        }\n\n        stack.into_iter().map(|b| b as char).collect()\n    }\n}\n\n#[test]\nfn test() {\n    let text = \"cdadabcc\".to_string();\n    let res = \"adbc\".to_string();\n    assert_eq!(Solution::smallest_subsequence(text), res);\n    let text = \"abcd\".to_string();\n    let res = \"abcd\".to_string();\n    assert_eq!(Solution::smallest_subsequence(text), res);\n    let text = \"ecbacba\".to_string();\n    let res = \"eacb\".to_string();\n    assert_eq!(Solution::smallest_subsequence(text), res);\n    let text = \"leetcode\".to_string();\n    let res = \"letcod\".to_string();\n    assert_eq!(Solution::smallest_subsequence(text), res);\n}\n"
    },
    {
        "input": "\n\nclass Solution(object):\n    def largestSumAfterKNegations(self, A, K):\n        \n        A.sort()\n        index = 0\n        while K > 0:\n            if A[index] < 0:\n                A[index] *= -1\n                if A[index+1] < A[index] and index < len(A)-1:\n                    index += 1\n            else:\n                A[index] *= -1\n            K -= 1\n        return sum(A)\n",
        "output": "struct Solution;\n\nuse std::cmp::Reverse;\nuse std::collections::BinaryHeap;\n\nimpl Solution {\n    fn largest_sum_after_k_negations(a: Vec<i32>, mut k: i32) -> i32 {\n        let reverse: Vec<Reverse<i32>> = a.into_iter().map(Reverse).collect();\n        let mut pq = BinaryHeap::from(reverse);\n        while k > 0 {\n            if let Some(min) = pq.pop() {\n                pq.push(Reverse(-min.0));\n            }\n            k -= 1;\n        }\n        pq.into_iter().map(|x| x.0).sum()\n    }\n}\n\n#[test]\nfn test() {\n    let a = vec![4, 2, 3];\n    let k = 1;\n    assert_eq!(Solution::largest_sum_after_k_negations(a, k), 5);\n    let a = vec![3, -1, 0, 2];\n    let k = 3;\n    assert_eq!(Solution::largest_sum_after_k_negations(a, k), 6);\n    let a = vec![2, -3, -1, 5, -4];\n    let k = 2;\n    assert_eq!(Solution::largest_sum_after_k_negations(a, k), 13);\n}\n"
    },
    {
        "input": "\n\nclass Solution(object):\n    def longestArithSeqLength(self, A):\n        \n        from collections import defaultdict\n\n        dp = defaultdict(int)\n        \n        for index_i in range(len(A)):\n            for index_j in range(index_i):\n                diff = A[index_i] - A[index_j]\n                dp[(index_i, diff)] = max(dp[(index_i, diff)], dp[(index_j, diff)]+1)\n                \n        return max(dp.itervalues())+1\n",
        "output": "struct Solution;\nuse rustgym_util::*;\nuse std::iter::Peekable;\nuse std::str::Chars;\nuse std::vec::IntoIter;\n\nenum Tok {\n    N(i32),\n    D(usize),\n}\n\ntrait Preorder {\n    fn parse(it: &mut Peekable<IntoIter<Tok>>, depth: usize) -> TreeLink;\n    fn parse_root(it: &mut Peekable<IntoIter<Tok>>) -> TreeLink;\n}\n\nimpl Preorder for TreeLink {\n    fn parse(it: &mut Peekable<IntoIter<Tok>>, depth: usize) -> TreeLink {\n        if let Some(&Tok::D(d)) = it.peek() {\n            if d == depth {\n                it.next();\n                if let Some(Tok::N(n)) = it.next() {\n                    TreeLink::branch(n, TreeLink::parse(it, d + 1), TreeLink::parse(it, d + 1))\n                } else {\n                    None\n                }\n            } else {\n                None\n            }\n        } else {\n            None\n        }\n    }\n\n    fn parse_root(it: &mut Peekable<IntoIter<Tok>>) -> TreeLink {\n        if let Some(Tok::N(n)) = it.next() {\n            TreeLink::branch(n, TreeLink::parse(it, 1), TreeLink::parse(it, 1))\n        } else {\n            None\n        }\n    }\n}\n\nimpl Solution {\n    fn recover_from_preorder(s: String) -> TreeLink {\n        let toks: Vec<Tok> = Self::parse_tokens(&mut s.chars().peekable());\n        TreeLink::parse_root(&mut toks.into_iter().peekable())\n    }\n\n    fn parse_tokens(it: &mut Peekable<Chars>) -> Vec<Tok> {\n        let mut toks: Vec<Tok> = vec![];\n        while let Some(c) = it.next() {\n            match c {\n                '-' => {\n                    let mut d = 1;\n                    while let Some('-') = it.peek() {\n                        it.next();\n                        d += 1;\n                    }\n                    toks.push(Tok::D(d));\n                }\n                '0'..='9' => {\n                    let mut n = (c as u8 - b'0') as i32;\n                    while let Some('0'..='9') = it.peek() {\n                        n *= 10;\n                        n += (it.next().unwrap() as u8 - b'0') as i32;\n                    }\n                    toks.push(Tok::N(n));\n                }\n                _ => {}\n            }\n        }\n        toks\n    }\n}\n\n#[test]\nfn test() {\n    let s = \"1-2--3--4-5--6--7\".to_string();\n    let res = tree!(\n        1,\n        tree!(2, tree!(3), tree!(4)),\n        tree!(5, tree!(6), tree!(7))\n    );\n    assert_eq!(Solution::recover_from_preorder(s), res);\n    let s = \"1-2--3---4-5--6---7\".to_string();\n    let res = tree!(\n        1,\n        tree!(2, tree!(3, tree!(4), None), None),\n        tree!(5, tree!(6, tree!(7), None), None)\n    );\n    assert_eq!(Solution::recover_from_preorder(s), res);\n    let s = \"1-401--349---90--88\".to_string();\n    let res = tree!(1, tree!(401, tree!(349, tree!(90), None), tree!(88)), None);\n    assert_eq!(Solution::recover_from_preorder(s), res);\n}\n"
    },
    {
        "input": "\n\nclass Solution(object):\n    def indexPairs(self, text, words):\n        \n        if not words:\n            return []\n        result = []\n        for word in words:\n            starting = [index for index in range(len(text)) if text.startswith(word, index)]\n            for start in starting:\n                result.append([start, start+len(word)-1])\n            \n        result.sort()\n        return result\n            ",
        "output": "struct Solution;\n\nuse std::collections::HashSet;\nuse std::iter::FromIterator;\n\nimpl Solution {\n    fn index_pairs(text: String, words: Vec<String>) -> Vec<Vec<i32>> {\n        let n = text.len();\n        let mut res: Vec<Vec<i32>> = vec![];\n        let hs: HashSet<String> = HashSet::from_iter(words);\n        for i in 0..n {\n            for j in i..n {\n                if hs.contains(&text[i..=j]) {\n                    res.push(vec![i as i32, j as i32]);\n                }\n            }\n        }\n        res\n    }\n}\n\n#[test]\nfn test() {\n    let text = \"thestoryofleetcodeandme\".to_string();\n    let words: Vec<String> = vec_string![\"story\", \"fleet\", \"leetcode\"];\n    let res: Vec<Vec<i32>> = vec_vec_i32![[3, 7], [9, 13], [10, 17]];\n    assert_eq!(Solution::index_pairs(text, words), res);\n    let text = \"ababa\".to_string();\n    let words: Vec<String> = vec_string![\"aba\", \"ab\"];\n    let res: Vec<Vec<i32>> = vec_vec_i32![[0, 1], [0, 2], [2, 3], [2, 4]];\n    assert_eq!(Solution::index_pairs(text, words), res);\n}\n"
    },
    {
        "input": "\n\n\n\n\n\n\n\nclass Solution(object):\n    def nextLargerNodes(self, head):\n        \n        result = []\n        while head:\n            result.append(head.val)\n            head = head.next\n        \n        stack = [result[-1]]\n        ans = [0]\n        for val in range(len(result)-2, -1, -1):\n            if result[val] < stack[-1]:\n                ans.append(stack[-1])\n            else:\n                while stack and stack[-1] <= result[val]:\n                    stack.pop()\n                if stack:\n                    ans.append(stack[-1])\n                else:\n                    ans.append(0)\n            stack.append(result[val])\n        return ans[::-1]\n",
        "output": "struct Solution;\nuse rustgym_util::*;\n\nimpl Solution {\n    fn next_larger_nodes(mut head: ListLink) -> Vec<i32> {\n        let mut nodes = vec![];\n        while let Some(node) = head {\n            nodes.push(node.val);\n            head = node.next;\n        }\n        let n = nodes.len();\n        let mut stack: Vec<usize> = vec![];\n        let mut res = vec![0; n];\n        for i in 0..n {\n            while let Some(j) = stack.pop() {\n                if nodes[j] < nodes[i] {\n                    res[j] = nodes[i];\n                } else {\n                    stack.push(j);\n                    break;\n                }\n            }\n            stack.push(i);\n        }\n        res\n    }\n}\n\n#[test]\nfn test() {\n    let head = list!(2, 1, 5);\n    let res = vec![5, 5, 0];\n    assert_eq!(Solution::next_larger_nodes(head), res);\n    let head = list!(2, 7, 4, 3, 5);\n    let res = vec![7, 0, 5, 5, 0];\n    assert_eq!(Solution::next_larger_nodes(head), res);\n    let head = list!(1, 7, 5, 1, 9, 2, 5, 1);\n    let res = vec![7, 9, 9, 9, 0, 5, 0, 0];\n    assert_eq!(Solution::next_larger_nodes(head), res);\n}\n"
    },
    {
        "input": "\n\nclass Solution(object):\n    def clumsy(self, N):\n        \n        return [0, 1, 2, 6, 7][N] if N < 5 else N + [1, 2, 2, - 1][N % 4]\n",
        "output": "struct Solution;\n\nimpl Solution {\n    fn clumsy(n: i32) -> i32 {\n        let magic = vec![1, 2, 2, -1, 0, 0, 3, 3];\n        n + if n > 4 {\n            magic[(n % 4) as usize]\n        } else {\n            magic[(n + 3) as usize]\n        }\n    }\n}\n\n#[test]\nfn test() {\n    let n = 4;\n    let res = 7;\n    assert_eq!(Solution::clumsy(n), res);\n    let n = 10;\n    let res = 12;\n    assert_eq!(Solution::clumsy(n), res);\n}\n"
    },
    {
        "input": "\n\nclass Solution(object):\n    def baseNeg2(self, N):\n        \n        if N == 0:\n            digits = ['0']\n        else:\n            digits = []\n            while N != 0:\n                N, remainder = divmod(N, -2)\n                if remainder < 0:\n                    N, remainder = N+1, remainder + 2\n                digits.append(str(remainder))\n        return ''.join(digits[::-1])\n",
        "output": "struct Solution;\n\nimpl Solution {\n    fn base_neg2(mut n: i32) -> String {\n        if n == 0 {\n            return \"0\".to_string();\n        }\n        let mut res = vec![];\n        while n != 0 {\n            res.push((b'0' + (n & 1) as u8) as char);\n            n = -(n >> 1);\n        }\n        res.reverse();\n        res.into_iter().collect()\n    }\n}\n\n#[test]\nfn test() {\n    let n = 2;\n    let res = \"110\".to_string();\n    assert_eq!(Solution::base_neg2(n), res);\n    let n = 3;\n    let res = \"111\".to_string();\n    assert_eq!(Solution::base_neg2(n), res);\n    let n = 4;\n    let res = \"100\".to_string();\n    assert_eq!(Solution::base_neg2(n), res);\n}\n"
    },
    {
        "input": "\n\nclass Solution(object):\n    def prefixesDivBy5(self, A):\n        \n        result = []\n        if not A:\n            return []\n        str_bin = ''\n        for val in A:\n            str_bin += str(val)\n            if(int(str_bin, 2)%5 == 0):\n                result.append(True)\n            else:\n                result.append(False)\n        return result\n",
        "output": "struct Solution;\n\nimpl Solution {\n    fn prefixes_div_by5(a: Vec<i32>) -> Vec<bool> {\n        let mut x = 0;\n        let n = a.len();\n        let mut res: Vec<bool> = vec![false; n];\n        for i in 0..n {\n            x = (x * 2 + a[i]) % 5;\n            res[i] = x == 0;\n        }\n        res\n    }\n}\n\n#[test]\nfn test() {\n    let a = vec![0, 1, 1];\n    let res = vec![true, false, false];\n    assert_eq!(Solution::prefixes_div_by5(a), res);\n    let a = vec![1, 1, 1];\n    let res = vec![false, false, false];\n    assert_eq!(Solution::prefixes_div_by5(a), res);\n    let a = vec![0, 1, 1, 1, 1, 1];\n    let res = vec![true, false, false, false, true, false];\n    assert_eq!(Solution::prefixes_div_by5(a), res);\n    let a = vec![1, 1, 1, 0, 1];\n    let res = vec![false, false, false, false, false];\n    assert_eq!(Solution::prefixes_div_by5(a), res);\n}\n"
    },
    {
        "input": "\n\nclass Solution(object):\n    def isBoomerang(self, points):\n        \n        x1, x2, x3, y1, y2, y3 = points[0][0], points[1][0], points[2][0], points[0][1], points[1][1] ,points[2][1]\n        if ((y3 - y2)*(x2 - x1) == (y2 - y1)*(x3 - x2)):\n            return False\n        return True\n",
        "output": "struct Solution;\n\nimpl Solution {\n    fn is_boomerang(points: Vec<Vec<i32>>) -> bool {\n        points[0][0] * (points[1][1] - points[2][1])\n            + points[1][0] * (points[2][1] - points[0][1])\n            + points[2][0] * (points[0][1] - points[1][1])\n            != 0\n    }\n}\n\n#[test]\nfn test() {\n    let points: Vec<Vec<i32>> = vec_vec_i32![[1, 1], [2, 3], [3, 2]];\n    assert_eq!(Solution::is_boomerang(points), true);\n    let points: Vec<Vec<i32>> = vec_vec_i32![[1, 1], [2, 2], [3, 3]];\n    assert_eq!(Solution::is_boomerang(points), false);\n}\n"
    },
    {
        "input": "\n\nclass Solution(object):\n    def rearrangeBarcodes(self, barcodes):\n        \n        import heapq\n        di = collections.Counter(barcodes)\n        pq = [(-value, key) for key, value in di.items()]\n        heapq.heapify(pq)\n        \n        result = []\n        while len(pq) >= 2:\n            freq1, barcode1 = heapq.heappop(pq)\n            freq2, barcode2 = heapq.heappop(pq)\n            result.extend([barcode1, barcode2])\n            \n            if freq1 + 1: \n                heapq.heappush(pq, (freq1 + 1, barcode1))\n            if freq2 + 1: \n                heapq.heappush(pq, (freq2 + 1, barcode2))\n                \n        if pq:\n            result.append(pq[0][1])\n        \n        return result\n",
        "output": "struct Solution;\nuse std::collections::HashMap;\n\nimpl Solution {\n    fn rearrange_barcodes(barcodes: Vec<i32>) -> Vec<i32> {\n        let n = barcodes.len();\n        if n == 1 {\n            return barcodes;\n        }\n        let mut hm: HashMap<i32, usize> = HashMap::new();\n        let mut max: (usize, i32) = (0, 0);\n        for barcode in barcodes {\n            let count = hm.entry(barcode).or_default();\n            *count += 1;\n            if *count > max.0 {\n                max = (*count, barcode);\n            }\n        }\n        let mut stack = vec![];\n        for (k, v) in hm {\n            if k != max.1 {\n                for _ in 0..v {\n                    stack.push(k);\n                }\n            }\n        }\n        for _ in 0..max.0 {\n            stack.push(max.1);\n        }\n        let mut res = vec![0; n];\n        let m = if n % 2 == 0 { n / 2 } else { (n + 1) / 2 };\n        for i in 0..m {\n            res[i * 2] = stack.pop().unwrap();\n        }\n        let mut i = 1;\n        while let Some(top) = stack.pop() {\n            res[i] = top;\n            i += 2;\n        }\n        res\n    }\n}\n\n#[test]\nfn test() {\n    let barcodes = vec![1, 1, 1, 2, 2, 2];\n    let res = vec![1, 2, 1, 2, 1, 2];\n    assert_eq!(Solution::rearrange_barcodes(barcodes), res);\n    let barcodes = vec![1, 1, 2];\n    let res = vec![1, 2, 1];\n    assert_eq!(Solution::rearrange_barcodes(barcodes), res);\n}\n"
    },
    {
        "input": "\n\n\n\n\n\n\n\n\n\nclass Solution(object):\n    def bstToGst(self, root):\n        \n        self.curr_sum = 0\n        def greaterSum(root):\n            if not root:\n                return \n            greaterSum(root.right)\n            self.curr_sum += root.val\n            root.val = self.curr_sum\n            greaterSum(root.left)\n        \n        greaterSum(root)\n        return root\n",
        "output": "struct Solution;\nuse rustgym_util::*;\n\ntrait Inorder {\n    fn inorder(&mut self, sum: &mut i32);\n}\n\nimpl Inorder for TreeLink {\n    fn inorder(&mut self, sum: &mut i32) {\n        if let Some(node) = self {\n            node.borrow_mut().right.inorder(sum);\n            *sum += node.borrow().val;\n            node.borrow_mut().val = *sum;\n            node.borrow_mut().left.inorder(sum);\n        }\n    }\n}\n\nimpl Solution {\n    fn bst_to_gst(mut root: TreeLink) -> TreeLink {\n        let mut sum = 0;\n        root.inorder(&mut sum);\n        root\n    }\n}\n\n#[test]\nfn test() {\n    let root = tree!(\n        4,\n        tree!(1, tree!(0), tree!(2, None, tree!(3))),\n        tree!(6, tree!(5), tree!(7, None, tree!(8)))\n    );\n    let res = tree!(\n        30,\n        tree!(36, tree!(36), tree!(35, None, tree!(33))),\n        tree!(21, tree!(26), tree!(15, None, tree!(8)))\n    );\n    assert_eq!(Solution::bst_to_gst(root), res);\n}\n"
    },
    {
        "input": "\nclass Solution(object):\n    def sumOfDigits(self, A):\n        \n        if not A:\n            return 0\n        \n        mini = min(A)\n        result = 0\n        while mini > 0:\n            quo = mini%10\n            rem = mini/10\n            result += quo\n            mini = rem\n            \n        return 0 if result%2 else 1\n",
        "output": "struct Solution;\n\nuse std::i32;\n\nimpl Solution {\n    fn sum_of_digits(a: Vec<i32>) -> i32 {\n        let mut min = i32::MAX;\n        for x in a {\n            min = i32::min(x, min);\n        }\n        let mut sum = 0;\n        while min > 0 {\n            sum += min % 10;\n            min /= 10;\n        }\n        if sum % 2 == 0 {\n            1\n        } else {\n            0\n        }\n    }\n}\n\n#[test]\nfn test() {\n    let a = vec![34, 23, 1, 24, 75, 33, 54, 8];\n    assert_eq!(Solution::sum_of_digits(a), 0);\n    let a = vec![99, 77, 33, 66, 55];\n    assert_eq!(Solution::sum_of_digits(a), 1);\n}\n"
    },
    {
        "input": "\n\nclass Solution(object):\n    def removeOuterParentheses(self, S):\n        \n        temp, result = \"\", \"\"\n        start_bracket = 0\n        for char in S:\n            temp += char\n            if char == '(':\n                start_bracket += 1\n            else:\n                start_bracket -= 1\n            if start_bracket == 0:\n                result += temp[1:-1]\n                temp = \"\"\n        return result\n",
        "output": "struct Solution;\n\nimpl Solution {\n    fn remove_outer_parentheses(s: String) -> String {\n        let mut res: String = \"\".to_string();\n        let mut count = 0;\n        for c in s.chars() {\n            if c == '(' {\n                count += 1;\n                if count > 1 {\n                    res.push(c);\n                }\n            } else {\n                count -= 1;\n                if count != 0 {\n                    res.push(c);\n                }\n            }\n        }\n        res\n    }\n}\n\n#[test]\nfn test() {\n    let s = \"(()())(())\".to_string();\n    let t = \"()()()\".to_string();\n    assert_eq!(Solution::remove_outer_parentheses(s), t);\n    let s = \"(()())(())(()(()))\".to_string();\n    let t = \"()()()()(())\".to_string();\n    assert_eq!(Solution::remove_outer_parentheses(s), t);\n    let s = \"()()\".to_string();\n    let t = \"\".to_string();\n    assert_eq!(Solution::remove_outer_parentheses(s), t);\n}\n"
    },
    {
        "input": "\n\nclass Solution(object):\n    def numPairsDivisibleBy60(self, time):\n        \n        count_arr = [0]*60\n        result = 0\n        for t in time:\n            remainder = t%60\n            complement = (60-remainder)%60\n            result += count_arr[complement]\n            count_arr[remainder] += 1\n        return result\n \n ",
        "output": "struct Solution;\n\nimpl Solution {\n    fn num_pairs_divisible_by60(time: Vec<i32>) -> i32 {\n        let mut a: Vec<i32> = vec![0; 60];\n        let mut res = 0;\n        for x in time {\n            let count = a[((600 - x) % 60) as usize];\n            if count != 0 {\n                res += count;\n            }\n            a[(x % 60) as usize] += 1;\n        }\n        res\n    }\n}\n\n#[test]\nfn test() {\n    let time = vec![30, 20, 150, 100, 40];\n    assert_eq!(Solution::num_pairs_divisible_by60(time), 3);\n    let time = vec![60, 60, 60];\n    assert_eq!(Solution::num_pairs_divisible_by60(time), 3);\n}\n"
    },
    {
        "input": "\n\nclass Solution(object):\n    def maxSumTwoNoOverlap(self, A, L, M):\n        \n        cumm_sum = [0]\n        for index in range(len(A)):\n            cumm_sum.append(cumm_sum[index]+A[index])\n        result = 0\n        \n        def valid(index_i, index_j):\n            return index_i+L <=len(A) and index_j+M <= len(A) and(index_j>=index_i+L or index_i>=index_j+M)\n    \n        for index_i in range(len(A)):\n            for index_j in range(len(A)):\n                if valid(index_i, index_j):\n                    result = max(result, cumm_sum[index_i+L]-cumm_sum[index_i] + cumm_sum[index_j+M]-cumm_sum[index_j])\n        return result\n",
        "output": "struct Solution;\n\nuse std::i32;\n\nimpl Solution {\n    fn max_sum_two_no_overlap(mut a: Vec<i32>, l: i32, m: i32) -> i32 {\n        let n = a.len();\n        let l = l as usize;\n        let m = m as usize;\n        for i in 1..n {\n            a[i] += a[i - 1];\n        }\n        let mut res = a[l + m - 1];\n        let mut max_l = a[l - 1];\n        let mut max_m = a[m - 1];\n        for i in l + m..n {\n            max_l = i32::max(a[i - m] - a[i - m - l], max_l);\n            max_m = i32::max(a[i - l] - a[i - l - m], max_m);\n            let last_l = a[i] - a[i - l];\n            let last_m = a[i] - a[i - m];\n            res = i32::max(i32::max(max_m + last_l, max_l + last_m), res);\n        }\n        res\n    }\n}\n\n#[test]\nfn test() {\n    let a = vec![0, 6, 5, 2, 2, 5, 1, 9, 4];\n    let l = 1;\n    let m = 2;\n    let res = 20;\n    assert_eq!(Solution::max_sum_two_no_overlap(a, l, m), res);\n    let a = vec![3, 8, 1, 3, 2, 1, 8, 9, 0];\n    let l = 3;\n    let m = 2;\n    let res = 29;\n    assert_eq!(Solution::max_sum_two_no_overlap(a, l, m), res);\n    let a = vec![2, 1, 5, 6, 0, 9, 5, 0, 3, 8];\n    let l = 4;\n    let m = 3;\n    let res = 31;\n    assert_eq!(Solution::max_sum_two_no_overlap(a, l, m), res);\n}\n"
    },
    {
        "input": "\n\nclass Solution(object):\n    def removeDuplicates(self, S):\n        \n        stack = []\n        if not S:\n            return \"\"\n        for char in S:\n            if not stack:\n                stack.append(char)\n            else:\n                first = stack[-1]\n                if first == char:\n                    stack.pop()\n                else:\n                    stack.append(char)\n        if not stack:\n            return \"\"\n        return ''.join(stack)\n",
        "output": "struct Solution;\n\nimpl Solution {\n    fn remove_duplicates(s: String) -> String {\n        let mut stack: Vec<char> = vec![];\n        for c in s.chars() {\n            if let Some(&top) = stack.last() {\n                if top == c {\n                    stack.pop();\n                } else {\n                    stack.push(c);\n                }\n            } else {\n                stack.push(c)\n            }\n        }\n        stack.iter().collect()\n    }\n}\n\n#[test]\nfn test() {\n    let s = \"abbaca\".to_string();\n    let t = \"ca\".to_string();\n    assert_eq!(Solution::remove_duplicates(s), t);\n}\n"
    },
    {
        "input": "\n\nclass Solution(object):\n    def fixedPoint(self, A):\n        \n        if not A:\n            return -1\n        for index, num in enumerate(A):\n            if num == index:\n                return index\n        return -1\n",
        "output": "struct Solution;\n\nimpl Solution {\n    fn fixed_point(a: Vec<i32>) -> i32 {\n        for i in 0..a.len() {\n            if i as i32 == a[i] {\n                return i as i32;\n            }\n        }\n        -1\n    }\n}\n\n#[test]\nfn test() {\n    assert_eq!(Solution::fixed_point(vec![-10, -5, 0, 3, 7]), 3);\n    assert_eq!(Solution::fixed_point(vec![0, 2, 5, 8, 17]), 0);\n    assert_eq!(Solution::fixed_point(vec![-10, -5, 3, 4, 7, 9]), -1);\n}\n"
    },
    {
        "input": "\n\nclass Solution(object):\n    def highFive(self, items):\n        \n        \n        if not items:\n            return []\n        \n        score_map = {}\n        for item in items:\n            if item[0] in score_map:\n                score_map[item[0]].append(item[1])\n            else:\n                score_map[item[0]] = [item[1]]\n                \n        result = []\n        for key, value in score_map.items():\n            value.sort(reverse=True)\n            if len(value) >= 5:\n                average = value[:5]\n            else:\n                average = value\n            score_map[key] = sum(average)/len(average)\n            result.append([key, score_map[key] ])\n        \n        return result\n",
        "output": "struct Solution;\nuse std::cmp::Reverse;\nuse std::collections::BTreeMap;\nuse std::collections::BinaryHeap;\n\nimpl Solution {\n    fn high_five(items: Vec<Vec<i32>>) -> Vec<Vec<i32>> {\n        let mut btm: BTreeMap<i32, (BinaryHeap<Reverse<i32>>, i32)> = BTreeMap::new();\n        let mut res = vec![];\n        for item in items {\n            let id = item[0];\n            let score = item[1];\n            let (pq, sum) = btm.entry(id).or_default();\n            pq.push(Reverse(score));\n            *sum += score;\n            if pq.len() > 5 {\n                *sum -= pq.pop().unwrap().0;\n            }\n        }\n        for (id, (_, sum)) in btm {\n            res.push(vec![id, sum / 5]);\n        }\n        res\n    }\n}\n\n#[test]\nfn test() {\n    let items = vec_vec_i32![\n        [1, 91],\n        [1, 92],\n        [2, 93],\n        [2, 97],\n        [1, 60],\n        [2, 77],\n        [1, 65],\n        [1, 87],\n        [1, 100],\n        [2, 100],\n        [2, 76]\n    ];\n    let res = vec_vec_i32![[1, 87], [2, 88]];\n    assert_eq!(Solution::high_five(items), res);\n}\n"
    },
    {
        "input": "",
        "output": "struct Solution;\n\nimpl Solution {\n    fn add_negabinary(mut arr1: Vec<i32>, mut arr2: Vec<i32>) -> Vec<i32> {\n        let n = arr1.len();\n        let m = arr2.len();\n        arr1.reverse();\n        arr2.reverse();\n        let mut carry = 0;\n        let mut res = vec![];\n        let mut i = 0;\n        while i < n.max(m) || carry != 0 {\n            if i < n {\n                carry += arr1[i];\n            }\n            if i < m {\n                carry += arr2[i];\n            }\n            res.push(carry & 1);\n            carry = -(carry >> 1);\n            i += 1;\n        }\n        while let Some(&0) = res.last() {\n            res.pop();\n        }\n        res.reverse();\n        if res.is_empty() {\n            vec![0]\n        } else {\n            res\n        }\n    }\n}\n\n#[test]\nfn test() {\n    let arr1 = vec![1, 1, 1, 1, 1];\n    let arr2 = vec![1, 0, 1];\n    let res = vec![1, 0, 0, 0, 0];\n    assert_eq!(Solution::add_negabinary(arr1, arr2), res);\n    let arr1 = vec![1];\n    let arr2 = vec![1];\n    let res = vec![1, 1, 0];\n    assert_eq!(Solution::add_negabinary(arr1, arr2), res);\n    let arr1 = vec![1];\n    let arr2 = vec![1, 1];\n    let res = vec![0];\n    assert_eq!(Solution::add_negabinary(arr1, arr2), res);\n}\n"
    },
    {
        "input": "\n\nclass Solution(object):\n    def numTilePossibilities(self, tiles):\n        \n        \n        if not tiles:\n            return 0\n        \n        import collections\n        unique = set(tiles)\n        freq_map =  collections.Counter(tiles)\n        total_len = 1\n        while total_len < len(tiles):\n            new = set()\n            for char in tiles:\n                for comb in unique:\n                    new_seq = comb+char\n                    up_freq = collections.Counter(new_seq)\n                    flag =True\n                    for key, val in up_freq.items():\n                        if val > freq_map[key]:\n                            flag = False\n                    if flag:\n                        new.add(new_seq)\n            \n            unique.update(new)\n                    \n            total_len += 1\n        return len(unique)\n",
        "output": "struct Solution;\n\nimpl Solution {\n    fn num_tile_possibilities(tiles: String) -> i32 {\n        let mut counts: Vec<usize> = vec![0; 26];\n        for c in tiles.chars() {\n            counts[(c as u8 - b'A') as usize] += 1;\n        }\n        let mut res = 0;\n        Self::dfs(&mut res, &mut counts);\n        res\n    }\n\n    fn dfs(sum: &mut i32, counts: &mut Vec<usize>) {\n        for i in 0..26 {\n            if counts[i] > 0 {\n                *sum += 1;\n                counts[i] -= 1;\n                Self::dfs(sum, counts);\n                counts[i] += 1;\n            }\n        }\n    }\n}\n\n#[test]\nfn test() {\n    let tiles = \"AAB\".to_string();\n    let res = 8;\n    assert_eq!(Solution::num_tile_possibilities(tiles), res);\n    let tiles = \"AAABBC\".to_string();\n    let res = 188;\n    assert_eq!(Solution::num_tile_possibilities(tiles), res);\n}\n"
    },
    {
        "input": "\n\n\nclass Solution(object):\n    def shipWithinDays(self, weights, D):\n        \n        high, low = sum(weights)+1, max(weights)\n        \n        while(low < high):\n            mid = (high+low)/2\n            temp_left = mid\n            packet_at_left = D-1\n            for weight in weights:\n                if weight <= mid:\n                    if temp_left < weight:\n                        if packet_at_left == 0:\n                            low = mid+1\n                            break\n                        packet_at_left -= 1\n                        temp_left = mid-weight\n                    else:\n                        temp_left -= weight\n            else:\n                high = mid\n                \n        return low\n\n\nclass Solution(object):\n    def shipWithinDays(self, weights, D):\n        \n        left, right = max(weights), sum(weights)\n        \n        while left < right:\n            curr_sum, groups, invalid = 0, 0, True\n            mid = left + ((right-left) >> 1)\n            for weight in weights:\n                if weight > mid:\n                    invalid = False\n                    break\n                if curr_sum + weight > mid:\n                    groups += 1\n                    curr_sum = 0\n                curr_sum += weight\n            if invalid and groups < D:\n                right = mid\n            else:\n                left = mid + 1\n        return left",
        "output": "struct Solution;\n\nimpl Solution {\n    fn ship_within_days(weights: Vec<i32>, d: i32) -> i32 {\n        let mut sum = 0;\n        let mut max = 0;\n        for &w in &weights {\n            sum += w;\n            max = max.max(w);\n        }\n        let mut l = max;\n        let mut h = sum;\n        while l < h {\n            let m = l + (h - l) / 2;\n            if Self::days(m, &weights) <= d {\n                h = m;\n            } else {\n                l = m + 1;\n            }\n        }\n        l\n    }\n\n    fn days(capacity: i32, weights: &[i32]) -> i32 {\n        let mut cur = 0;\n        let mut res = 1;\n        for &w in weights {\n            cur += w;\n            if cur > capacity {\n                res += 1;\n                cur = w;\n            }\n        }\n        res\n    }\n}\n\n#[test]\nfn test() {\n    let weights = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n    let d = 5;\n    let res = 15;\n    assert_eq!(Solution::ship_within_days(weights, d), res);\n    let weights = vec![3, 2, 2, 4, 1, 4];\n    let d = 3;\n    let res = 6;\n    assert_eq!(Solution::ship_within_days(weights, d), res);\n    let weights = vec![1, 2, 3, 1, 1];\n    let d = 4;\n    let res = 3;\n    assert_eq!(Solution::ship_within_days(weights, d), res);\n}\n"
    },
    {
        "input": "\n        \nclass Solution(object):\n    def longestStrChain(self, words):\n        \n        if not words:\n            return 0\n        words.sort(key=len)\n        dp = collections.defaultdict(int)\n        result = 0\n        for word in words:\n            for index in range(len(word)):\n                char_excluded_string = word[:index] + word[index+1:]\n                if char_excluded_string in dp:\n                    dp[word] = max(dp[char_excluded_string]+1, dp[word])\n                else:\n                    dp[word] = max(dp[word], 1)\n            result = max(dp[word], result)\n        return result\n",
        "output": "struct Solution;\n\nimpl Solution {\n    fn is_prev(prev: &str, next: &str) -> bool {\n        let mut i = 0;\n        let mut j = 0;\n        while i < prev.len() {\n            if prev[i..=i] == next[j..=j] {\n                i += 1;\n                j += 1;\n            } else if i == j {\n                j += 1;\n            } else {\n                return false;\n            }\n        }\n        true\n    }\n    fn longest_str_chain(mut words: Vec<String>) -> i32 {\n        let n = words.len();\n        let mut v: Vec<i32> = vec![1; n];\n        let mut res = 1;\n        words.sort_unstable_by_key(|s| s.len());\n        for i in 1..n {\n            let cur = &words[i];\n            let m = cur.len();\n            for j in (0..i).rev() {\n                let l = words[j].len();\n                if l == m {\n                    continue;\n                } else if l == m - 1 {\n                    if Self::is_prev(&words[j], &words[i]) {\n                        v[i] = v[j] + 1;\n                        res = i32::max(res, v[i]);\n                        break;\n                    }\n                } else {\n                    break;\n                }\n            }\n        }\n        res\n    }\n}\n\n#[test]\nfn test() {\n    let words: Vec<String> = vec_string![\"a\", \"b\", \"ba\", \"bca\", \"bda\", \"bdca\"];\n    assert_eq!(Solution::longest_str_chain(words), 4);\n    let words: Vec<String> = vec_string![\n        \"ksqvsyq\",\n        \"ks\",\n        \"kss\",\n        \"czvh\",\n        \"zczpzvdhx\",\n        \"zczpzvh\",\n        \"zczpzvhx\",\n        \"zcpzvh\",\n        \"zczvh\",\n        \"gr\",\n        \"grukmj\",\n        \"ksqvsq\",\n        \"gruj\",\n        \"kssq\",\n        \"ksqsq\",\n        \"grukkmj\",\n        \"grukj\",\n        \"zczpzfvdhx\",\n        \"gru\"\n    ];\n    assert_eq!(Solution::longest_str_chain(words), 7);\n}\n"
    },
    {
        "input": "\n\nclass Solution(object):\n    def camelMatch(self, queries, pattern):\n        \n        import re\n        result = []\n        patterns = re.findall('[A-Z][a-z]*', pattern)\n        \n        for query in queries:\n            splitter = re.findall('[A-Z][a-z]*', query)\n            flag = True\n            if len(patterns) == len(splitter):\n                for index in range(len(patterns)):\n                    \n                    p_i, s_i = 1, 1\n                    if patterns[index][0] == splitter[index][0]:\n                        while p_i < len(patterns[index]) and s_i < len(splitter[index]):\n                            if patterns[index][p_i] == splitter[index][s_i]:\n                                p_i += 1\n                                s_i += 1\n                            else:\n                                s_i += 1\n                        if p_i != len(patterns[index]):\n                            flag = False\n                            break\n                    else:\n                        flag = False\n                        break\n                if flag:\n                    result.append(True)\n                else:\n                    result.append(False)\n            else:\n                result.append(False)\n        return result\n",
        "output": "struct Solution;\n\nimpl Solution {\n    fn camel_match(queries: Vec<String>, pattern: String) -> Vec<bool> {\n        queries\n            .into_iter()\n            .map(|query| Self::query_match(query.chars().collect(), pattern.chars().collect()))\n            .collect()\n    }\n\n    fn query_match(query: Vec<char>, pattern: Vec<char>) -> bool {\n        let mut j = 0;\n        for i in 0..query.len() {\n            if j < pattern.len() && query[i] == pattern[j] {\n                j += 1;\n            } else {\n                if query[i].is_uppercase() {\n                    return false;\n                }\n            }\n        }\n        j == pattern.len()\n    }\n}\n\n#[test]\nfn test() {\n    let queries = vec_string![\n        \"FooBar\",\n        \"FooBarTest\",\n        \"FootBall\",\n        \"FrameBuffer\",\n        \"ForceFeedBack\"\n    ];\n    let pattern = \"FB\".to_string();\n    let res = vec![true, false, true, true, false];\n    assert_eq!(Solution::camel_match(queries, pattern), res);\n    let queries = vec_string![\n        \"FooBar\",\n        \"FooBarTest\",\n        \"FootBall\",\n        \"FrameBuffer\",\n        \"ForceFeedBack\"\n    ];\n    let pattern = \"FoBa\".to_string();\n    let res = vec![true, false, true, false, false];\n    assert_eq!(Solution::camel_match(queries, pattern), res);\n    let queries = vec_string![\n        \"FooBar\",\n        \"FooBarTest\",\n        \"FootBall\",\n        \"FrameBuffer\",\n        \"ForceFeedBack\"\n    ];\n    let pattern = \"FoBaT\".to_string();\n    let res = vec![false, true, false, false, false];\n    assert_eq!(Solution::camel_match(queries, pattern), res);\n}\n"
    },
    {
        "input": "\n\nclass Solution(object):\n    def divisorGame(self, N):\n        \n        if N == 0:\n            return False\n    \n        move = 0\n        while N > 1:\n            for num in range(1, N):\n                if N%num == 0:\n                    N -= num\n                    move += 1\n                    break\n        \n        if move%2:\n            return True\n        return False\n",
        "output": "struct Solution;\n\nimpl Solution {\n    fn divisor_game(n: i32) -> bool {\n        n % 2 == 0\n    }\n}\n\n#[test]\nfn test() {\n    assert_eq!(Solution::divisor_game(2), true);\n    assert_eq!(Solution::divisor_game(3), false);\n}\n"
    },
    {
        "input": "\n\n\n\n\n\n\n\nclass Solution(object):\n    def sumRootToLeaf(self, root):\n        \n        def traversal(root, paths, pathlen, allpaths):\n            if not root:\n                return \n            if len(paths) > pathlen:\n                paths[pathlen] = root.val\n            else:\n                paths.append(root.val)\n                \n            pathlen +=1\n            if not root.left and not root.right:\n                allpaths.append(int(''.join(str(val) for val in paths[0:pathlen]), 2))\n            else:\n                traversal(root.left, paths, pathlen, allpaths)\n                traversal(root.right, paths, pathlen, allpaths)\n        paths = []\n        traversal(root, [], 0, paths)\n        return sum(paths)%1000000007\n",
        "output": "struct Solution;\nuse rustgym_util::*;\n\nimpl Solution {\n    fn sum_root_to_leaf(root: TreeLink) -> i32 {\n        let mut sum = 0;\n        Self::sum_r(&root, 0, &mut sum);\n        sum\n    }\n    fn sum_r(link: &TreeLink, parent_val: i32, sum: &mut i32) {\n        if let Some(node) = link {\n            let node = node.borrow();\n            let left = &node.left;\n            let right = &node.right;\n            let val = node.val + parent_val * 2;\n            if left.is_none() && right.is_none() {\n                *sum += val;\n            } else {\n                Self::sum_r(left, val, sum);\n                Self::sum_r(right, val, sum);\n            }\n        }\n    }\n}\n\n#[test]\nfn test() {\n    let root = tree!(\n        1,\n        tree!(0, tree!(0), tree!(1)),\n        tree!(1, tree!(0), tree!(1))\n    );\n    assert_eq!(Solution::sum_root_to_leaf(root), 22);\n}\n"
    },
    {
        "input": "\n\nclass Solution(object):\n    def duplicateZeros(self, arr):\n        \n        arr_copy = arr[:]\n        index, n = 0, len(arr_copy)\n        for elem in arr_copy:\n            arr[index] = elem\n            index += 1\n            if index >= n:\n                break\n            if elem == 0:\n                arr[index] = elem\n                index += 1\n                if index >= n:\n                    break\n",
        "output": "struct Solution;\n\nimpl Solution {\n    fn duplicate_zeros(arr: &mut Vec<i32>) {\n        let n = arr.len();\n        let m = arr.iter().filter(|&x| *x == 0).count();\n        let mut i = n - 1;\n        let mut j = m + n - 1;\n        while i > 0 {\n            if arr[i] != 0 {\n                if j < n {\n                    arr[j] = arr[i];\n                }\n                i -= 1;\n            } else {\n                if j < n {\n                    arr[j] = 0;\n                }\n                i -= 1;\n                j -= 1;\n                if j < n {\n                    arr[j] = 0;\n                }\n            }\n            j -= 1;\n        }\n        if arr[i] != 0 {\n            arr[j] = arr[i];\n        } else {\n            arr[j] = 0;\n            j -= 1;\n            arr[j] = 0;\n        }\n    }\n}\n\n#[test]\nfn test() {\n    let mut arr = vec![1, 0, 2, 3, 0, 4, 5, 0];\n    let res = vec![1, 0, 0, 2, 3, 0, 0, 4];\n    Solution::duplicate_zeros(&mut arr);\n    assert_eq!(arr, res);\n}\n"
    },
    {
        "input": "\nclass Solution(object):\n    def prevPermOpt1(self, A):\n        \n    \n        left, right = len(A)-2, len(A)-1\n        for left in range(len(A)-2, -1, -1):\n            if A[left] > A[left+1]:\n                break\n        else:\n            return A\n        right = A.index(max(ele for ele in A[left+1:] if ele < A[left]), left)\n        A[left], A[right] = A[right], A[left]\n        return A\n ",
        "output": "struct Solution;\n\nimpl Solution {\n    fn prev_perm_opt1(mut a: Vec<i32>) -> Vec<i32> {\n        let n = a.len();\n        if n < 2 {\n            return a;\n        }\n        let mut i = n - 2;\n        while i > 0 && a[i] <= a[i + 1] {\n            i -= 1;\n        }\n        if i == 0 && a[0] <= a[1] {\n            return a;\n        }\n        let mut j = n - 1;\n        while a[j] >= a[i] || a[j] == a[j - 1] {\n            j -= 1;\n        }\n        a.swap(i, j);\n        a\n    }\n}\n\n#[test]\nfn test() {\n    let a = vec![3, 2, 1];\n    let res = vec![3, 1, 2];\n    assert_eq!(Solution::prev_perm_opt1(a), res);\n    let a = vec![1, 1, 5];\n    let res = vec![1, 1, 5];\n    assert_eq!(Solution::prev_perm_opt1(a), res);\n    let a = vec![1, 9, 4, 6, 7];\n    let res = vec![1, 7, 4, 6, 9];\n    assert_eq!(Solution::prev_perm_opt1(a), res);\n    let a = vec![3, 1, 1, 3];\n    let res = vec![1, 3, 1, 3];\n    assert_eq!(Solution::prev_perm_opt1(a), res);\n}\n"
    },
    {
        "input": "\n\nclass Solution(object):\n    def numMovesStones(self, a, b, c):\n        \n        lista = [a, b, c]\n        lista.sort()\n        a, b, c = lista[0], lista[1], lista[2]\n        minsteps = 0\n        if b == a+1 and c == a+2:\n            return [0, 0]\n        elif b == a+1 or c == b+1 or c == b+2 or  b == a+2:\n            minsteps = 1\n        else:\n            minsteps = 2\n        return [minsteps, b-a-1+c-b-1]\n",
        "output": "struct Solution;\n\nimpl Solution {\n    fn num_moves_stones(a: i32, b: i32, c: i32) -> Vec<i32> {\n        let mut a: Vec<i32> = vec![a, b, c];\n        a.sort_unstable();\n        let min = if a[0] + 1 == a[1] && a[1] + 1 == a[2] {\n            0\n        } else {\n            if a[0] + 2 >= a[1] || a[1] + 2 >= a[2] {\n                1\n            } else {\n                2\n            }\n        };\n        let max = a[1] - a[0] - 1 + a[2] - a[1] - 1;\n        vec![min, max]\n    }\n}\n\n#[test]\nfn test() {\n    let a = 1;\n    let b = 2;\n    let c = 5;\n    let res = vec![1, 2];\n    assert_eq!(Solution::num_moves_stones(a, b, c), res);\n    let a = 4;\n    let b = 3;\n    let c = 2;\n    let res = vec![0, 0];\n    assert_eq!(Solution::num_moves_stones(a, b, c), res);\n    let a = 3;\n    let b = 5;\n    let c = 1;\n    let res = vec![1, 2];\n    assert_eq!(Solution::num_moves_stones(a, b, c), res);\n}\n"
    },
    {
        "input": "\n\nclass Solution(object):\n    def maxUncrossedLines(self, A, B):\n        \n        dp = [[0]*len(A) for _ in range(len(B))]\n        \n        dp[0][0] = 1 if A[0] == B[0] else 0\n        for index_i in range(1, len(dp)):\n            dp[index_i][0] = dp[index_i-1][0]\n            if A[0] == B[index_i]:\n                dp[index_i][0] = 1\n                \n        for index_j in range(1, len(dp[0])):\n            dp[0][index_j] = dp[0][index_j-1]\n            if B[0] == A[index_j]:\n                dp[0][index_j] = 1\n                \n        for index_i in range(1, len(dp)):\n            for index_j in range(1, len(dp[0])):\n                if A[index_j] == B[index_i]:\n                    dp[index_i][index_j] = max(dp[index_i-1][index_j-1] + 1, max(dp[index_i-1][index_j], dp[index_i][index_j-1]))\n                else:\n                    dp[index_i][index_j] = max(dp[index_i-1][index_j-1], max(dp[index_i-1][index_j], dp[index_i][index_j-1]))\n        return dp[len(B)-1][len(A)-1]\n",
        "output": "struct Solution;\n\nimpl Solution {\n    fn max_uncrossed_lines(a: Vec<i32>, b: Vec<i32>) -> i32 {\n        let n = a.len();\n        let m = b.len();\n        let mut dp = vec![vec![0; m + 1]; n + 1];\n        for i in 0..n {\n            for j in 0..m {\n                if a[i] == b[j] {\n                    dp[i + 1][j + 1] = dp[i][j] + 1;\n                } else {\n                    dp[i + 1][j + 1] = dp[i][j + 1].max(dp[i + 1][j]);\n                }\n            }\n        }\n        dp[n][m]\n    }\n}\n\n#[test]\nfn test() {\n    let a = vec![1, 4, 2];\n    let b = vec![1, 2, 4];\n    let res = 2;\n    assert_eq!(Solution::max_uncrossed_lines(a, b), res);\n    let a = vec![2, 5, 1, 2, 5];\n    let b = vec![10, 5, 2, 1, 5, 2];\n    let res = 3;\n    assert_eq!(Solution::max_uncrossed_lines(a, b), res);\n    let a = vec![1, 3, 7, 1, 7, 5];\n    let b = vec![1, 9, 2, 5, 1];\n    let res = 2;\n    assert_eq!(Solution::max_uncrossed_lines(a, b), res);\n}\n"
    },
    {
        "input": "\n\nclass Solution(object):\n    def twoCitySchedCost(self, costs):\n        \n        result = 0\n        costs = sorted(costs, key=lambda x : x[0] - x[1])\n        for index in range(len(costs)):\n            if index < len(costs)//2:\n                result += costs[index][0]\n            else:\n                result += costs[index][1]\n        return result\n",
        "output": "struct Solution;\n\nimpl Solution {\n    fn two_city_sched_cost(costs: Vec<Vec<i32>>) -> i32 {\n        let n = costs.len();\n        let mut diffs: Vec<i32> = costs.iter().map(|v| v[0] - v[1]).collect();\n        diffs.sort_unstable();\n        let sum_of_b: i32 = costs.iter().map(|v| v[1]).sum();\n        let sum_of_diff: i32 = diffs.iter().take(n / 2).sum();\n        sum_of_b + sum_of_diff\n    }\n}\n\n#[test]\nfn test() {\n    let costs: Vec<Vec<i32>> = vec_vec_i32![[10, 20], [30, 200], [400, 50], [30, 20]];\n    assert_eq!(Solution::two_city_sched_cost(costs), 110);\n}\n"
    },
    {
        "input": "\n\nclass Solution(object):\n    def allCellsDistOrder(self, R, C, r0, c0):\n        \n        cells = [[x, y] for x in range(R) for y in range(C)]\n        distance = {}\n        for cell in cells:\n            diff = abs(cell[0]-r0) + abs(cell[1]-c0)\n            if diff in distance:\n                distance[diff].append(cell)\n            else:\n                distance[diff] = [cell]\n        result = []\n        for key in sorted(distance):\n            for value in distance[key]:\n                result.append(value)\n        return result\n",
        "output": "struct Solution;\n\nimpl Solution {\n    fn all_cells_dist_order(r: i32, c: i32, r0: i32, c0: i32) -> Vec<Vec<i32>> {\n        let mut cells: Vec<Vec<i32>> = vec![];\n        for i in 0..r {\n            for j in 0..c {\n                cells.push(vec![i, j]);\n            }\n        }\n        cells.sort_unstable_by_key(|v| (v[0] - r0).abs() + (v[1] - c0).abs());\n        cells\n    }\n}\n\n#[test]\nfn test() {\n    let r = 1;\n    let c = 2;\n    let r0 = 0;\n    let c0 = 0;\n    let res: Vec<Vec<i32>> = vec_vec_i32![[0, 0], [0, 1]];\n    assert_eq!(Solution::all_cells_dist_order(r, c, r0, c0), res);\n    let r = 2;\n    let c = 2;\n    let r0 = 0;\n    let c0 = 1;\n    let res: Vec<Vec<i32>> = vec_vec_i32![[0, 1], [0, 0], [1, 1], [1, 0]];\n    assert_eq!(Solution::all_cells_dist_order(r, c, r0, c0), res);\n    let r = 2;\n    let c = 3;\n    let r0 = 1;\n    let c0 = 2;\n    let res: Vec<Vec<i32>> = vec_vec_i32![[1, 2], [0, 2], [1, 1], [0, 1], [1, 0], [0, 0]];\n    assert_eq!(Solution::all_cells_dist_order(r, c, r0, c0), res);\n}\n"
    },
    {
        "input": "\n\nclass Solution(object):\n    def colorBorder(self, grid, r0, c0, color):\n        \n        if not grid:\n            return grid\n        visited, border = [], []\n        m, n = len(grid), len(grid[0])\n        \n        def dfs(r, c):\n            if r < 0 or c < 0 or r >= m or c >= n or grid[r][c] != grid[r0][c0] or (r,c) in visited:\n                return\n            visited.append((r,c))\n            \n            \n            \n            if (r == 0 or c == 0 or r == m-1 or c == n-1 or \n                (r+1 < m and grid[r+1][c] != grid[r0][c0]) or\n                (r-1 >= 0 and grid[r-1][c] != grid[r0][c0]) or\n                (c+1 < n and grid[r][c+1] != grid[r0][c0]) or\n                (c-1 >= 0 and grid[r][c-1] != grid[r0][c0])):\n                    border.append((r,c))\n            dfs(r-1, c)\n            dfs(r+1, c)\n            dfs(r, c-1)\n            dfs(r, c+1)\n            \n        dfs(r0, c0)\n        for (x, y) in border:\n            grid[x][y] = color\n        return grid\n",
        "output": "struct Solution;\n\nimpl Solution {\n    fn color_border(mut grid: Vec<Vec<i32>>, r0: i32, c0: i32, color: i32) -> Vec<Vec<i32>> {\n        let n = grid.len();\n        let m = grid[0].len();\n        let r0 = r0 as usize;\n        let c0 = c0 as usize;\n        let c_color = grid[r0][c0];\n        let b_color = color;\n        let mut visited: Vec<Vec<bool>> = vec![vec![false; m]; n];\n        Self::dfs(r0, c0, &mut visited, &mut grid, b_color, c_color, n, m);\n        grid\n    }\n    fn dfs(\n        i: usize,\n        j: usize,\n        visited: &mut [Vec<bool>],\n        grid: &mut [Vec<i32>],\n        b_color: i32,\n        c_color: i32,\n        n: usize,\n        m: usize,\n    ) {\n        visited[i][j] = true;\n        let top = if i == 0 {\n            true\n        } else {\n            if grid[i - 1][j] != c_color {\n                !visited[i - 1][j]\n            } else {\n                if !visited[i - 1][j] {\n                    Self::dfs(i - 1, j, visited, grid, b_color, c_color, n, m);\n                }\n                false\n            }\n        };\n        let left = if j == 0 {\n            true\n        } else {\n            if grid[i][j - 1] != c_color {\n                !visited[i][j - 1]\n            } else {\n                if !visited[i][j - 1] {\n                    Self::dfs(i, j - 1, visited, grid, b_color, c_color, n, m);\n                }\n                false\n            }\n        };\n        let down = if i + 1 == n {\n            true\n        } else {\n            if grid[i + 1][j] != c_color {\n                !visited[i + 1][j]\n            } else {\n                if !visited[i + 1][j] {\n                    Self::dfs(i + 1, j, visited, grid, b_color, c_color, n, m);\n                }\n                false\n            }\n        };\n        let right = if j + 1 == m {\n            true\n        } else {\n            if grid[i][j + 1] != c_color {\n                !visited[i][j + 1]\n            } else {\n                if !visited[i][j + 1] {\n                    Self::dfs(i, j + 1, visited, grid, b_color, c_color, n, m);\n                }\n                false\n            }\n        };\n        if top || left || down || right {\n            grid[i][j] = b_color;\n        }\n    }\n}\n\n#[test]\nfn test() {\n    let grid = vec_vec_i32![[1, 1], [1, 2]];\n    let r0 = 0;\n    let c0 = 0;\n    let color = 3;\n    let res = vec_vec_i32![[3, 3], [3, 2]];\n    assert_eq!(Solution::color_border(grid, r0, c0, color), res);\n    let grid = vec_vec_i32![[1, 2, 2], [2, 3, 2]];\n    let r0 = 0;\n    let c0 = 1;\n    let color = 3;\n    let res = vec_vec_i32![[1, 3, 3], [2, 3, 3]];\n    assert_eq!(Solution::color_border(grid, r0, c0, color), res);\n    let grid = vec_vec_i32![[1, 1, 1], [1, 1, 1], [1, 1, 1]];\n    let r0 = 1;\n    let c0 = 1;\n    let color = 2;\n    let res = vec_vec_i32![[2, 2, 2], [2, 1, 2], [2, 2, 2]];\n    assert_eq!(Solution::color_border(grid, r0, c0, color), res);\n}\n"
    },
    {
        "input": "\n\nclass Solution(object):\n    def heightChecker(self, heights):\n        \n        result = 0\n        for new_h, hei in zip(heights, sorted(heights)):\n            if new_h != hei:\n                result += 1\n        return result\n",
        "output": "struct Solution;\n\nimpl Solution {\n    fn height_checker(heights: Vec<i32>) -> i32 {\n        let mut sorted = heights.to_vec();\n        sorted.sort_unstable();\n        heights\n            .iter()\n            .zip(sorted.iter())\n            .fold(0, |sum, (a, b)| if a != b { sum + 1 } else { sum })\n    }\n}\n\n#[test]\nfn test() {\n    let heights = vec![1, 1, 4, 2, 1, 3];\n    assert_eq!(Solution::height_checker(heights), 3);\n}\n"
    },
    {
        "input": "\n\nclass Solution(object):\n    def gardenNoAdj(self, N, paths):\n                    \n        plant = [1, 2, 3, 4]\n        result = [0 for _ in range(N)]\n        if not paths:\n            return [plant[index%4] for index in range(N)]\n        \n        change = {}\n        update = []\n        for path in paths:\n            x, y = path[0]-1, path[1]-1\n                \n            if x in change:\n                change[x].append(y)\n            else:\n                change[x] = [y]\n                \n            if y in change:\n                change[y].append(x)\n            else:\n                change[y] = [x]\n        \n        for garden in range(N):\n            color_used = []\n            if garden in change:\n                subgarden = change[garden]\n                for subgarden in change[garden]:\n                    if result[subgarden]:\n                        color_used.append(result[subgarden])\n            color_rem = list(set([1, 2, 3, 4]) - set(color_used))\n            for color in color_rem:\n                result[garden] = color\n                break\n        return result\n ",
        "output": "struct Solution;\n\nimpl Solution {\n    fn garden_no_adj(n: i32, paths: Vec<Vec<i32>>) -> Vec<i32> {\n        let n = n as usize;\n        let mut g: Vec<Vec<usize>> = vec![vec![]; n];\n        for path in paths {\n            let u = (path[0] - 1) as usize;\n            let v = (path[1] - 1) as usize;\n            g[u].push(v);\n            g[v].push(u);\n        }\n        let mut colors: Vec<i32> = vec![0; n];\n        for i in 0..n {\n            let mut used: Vec<bool> = vec![false; 5];\n            for &j in &g[i] {\n                used[colors[j] as usize] = true;\n            }\n            for c in 1..5 {\n                if !used[c] {\n                    colors[i] = c as i32;\n                    break;\n                }\n            }\n        }\n        colors\n    }\n}\n\n#[test]\nfn test() {\n    let n = 3;\n    let paths: Vec<Vec<i32>> = vec_vec_i32![[1, 2], [2, 3], [3, 1]];\n    let res = vec![1, 2, 3];\n    assert_eq!(Solution::garden_no_adj(n, paths), res);\n    let n = 4;\n    let paths: Vec<Vec<i32>> = vec_vec_i32![[1, 2], [3, 4]];\n    let res = vec![1, 2, 1, 2];\n    assert_eq!(Solution::garden_no_adj(n, paths), res);\n    let n = 4;\n    let paths: Vec<Vec<i32>> = vec_vec_i32![[1, 2], [2, 3], [3, 4], [4, 1], [1, 3], [2, 4]];\n    let res = vec![1, 2, 3, 4];\n    assert_eq!(Solution::garden_no_adj(n, paths), res);\n}\n"
    },
    {
        "input": "\nclass Solution(object):\n    def maxSatisfied(self, customers, grumpy, X):\n        \n        result = 0\n\n        prefix_sum = [0]*(len(customers)+1)\n        index = 0\n        for customer, grump in zip(customers, grumpy):\n            prefix_sum[index+1] = prefix_sum[index]\n            if grump == 0:\n                result += customer\n            else:\n                prefix_sum[index+1] += customer\n            index += 1\n        \n        curr_max = result + prefix_sum[X]\n        \n        for index in range(X+1, len(prefix_sum)):\n            temp_max = result + prefix_sum[index] - prefix_sum[index-X]\n            \n            curr_max = max(curr_max, temp_max)\n        return curr_max\n",
        "output": "struct Solution;\n\nuse std::i32;\n\nimpl Solution {\n    fn max_satisfied(customers: Vec<i32>, grumpy: Vec<i32>, x: i32) -> i32 {\n        let mut sum = 0;\n        let mut max = 0;\n        let n = customers.len();\n        for i in 0..n {\n            if grumpy[i] == 0 {\n                sum += customers[i];\n            }\n        }\n        let x = x as usize;\n        for i in 0..x {\n            if grumpy[i] == 1 {\n                sum += customers[i];\n            }\n        }\n        max = i32::max(sum, max);\n        for i in x..n {\n            if grumpy[i] == 1 {\n                sum += customers[i];\n            }\n            if grumpy[i - x] == 1 {\n                sum -= customers[i - x];\n            }\n            max = i32::max(sum, max);\n        }\n        max\n    }\n}\n\n#[test]\nfn test() {\n    let customers = vec![1, 0, 1, 2, 1, 1, 7, 5];\n    let grumpy = vec![0, 1, 0, 1, 0, 1, 0, 1];\n    let x = 3;\n    let res = 16;\n    assert_eq!(Solution::max_satisfied(customers, grumpy, x), res);\n}\n"
    },
    {
        "input": "\n\nclass Solution(object):\n    def commonChars(self, A):\n        \n        char_map = {}\n        for char in A[0]:\n            if char in char_map:\n                char_map[char] += 1\n            else:\n                char_map[char] = 1\n    \n        int_map = {}\n        for index in range(1, len(A)):\n            for char in char_map.keys():\n                if char in A[index]:\n                    char_count = min(A[index].count(char), char_map[char])\n                    char_map[char] = char_count\n                else:\n                    del char_map[char]\n                    \n        result = []\n        for key, value in char_map.items():\n            result.extend([key]*value)\n\n        return result\n",
        "output": "struct Solution;\n\nuse std::usize;\n\nimpl Solution {\n    fn common_chars(a: Vec<String>) -> Vec<String> {\n        let n = a.len();\n        let mut counts: Vec<Vec<usize>> = vec![vec![0; 256]; n];\n        for i in 0..n {\n            let w = &a[i];\n            for c in w.chars() {\n                counts[i][c as usize] += 1;\n            }\n        }\n        let mut res: Vec<String> = vec![];\n        for i in 0..26 {\n            let c: u8 = b'a' + i;\n            let mut min = usize::MAX;\n            for j in 0..n {\n                let count = counts[j][c as usize];\n                min = usize::min(count, min);\n            }\n            for _ in 0..min {\n                res.push(format!(\"{}\", c as char))\n            }\n        }\n        res\n    }\n}\n\n#[test]\nfn test() {\n    let a: Vec<String> = vec_string![\"bella\", \"label\", \"roller\"];\n    let b: Vec<String> = vec_string![\"e\", \"l\", \"l\"];\n    assert_eq!(Solution::common_chars(a), b);\n\n    let a: Vec<String> = vec_string![\"cool\", \"lock\", \"cook\"];\n    let b: Vec<String> = vec_string![\"c\", \"o\"];\n    assert_eq!(Solution::common_chars(a), b);\n}\n"
    },
    {
        "input": "\n\nclass Trie(object):\n    def __init__(self):\n        self.nodes = {}\n        self.word = False\n        \nclass StreamChecker(object):\n\n    def __init__(self, words):\n        \n        self.trie_node = Trie()\n        for word in words:\n            ptr = self.trie_node\n            for char in reversed(word):\n                if char not in ptr.nodes:\n                    ptr.nodes[char] = Trie()\n                ptr = ptr.nodes[char]\n            ptr.word = True\n        self.stream = []\n        \n\n    def query(self, letter):\n        \n        self.stream.append(letter)\n        root = self.trie_node\n        for char in reversed(self.stream):\n            if char not in root.nodes:\n                return False\n            if root.nodes[char].word:\n                return True\n            root = root.nodes[char]\n            \n        return root.word\n            \n \n\n\n\n",
        "output": "use std::collections::HashMap;\n\n#[derive(PartialEq, Eq, Clone, Debug, Default)]\nstruct Trie {\n    children: HashMap<char, Trie>,\n    end: bool,\n}\n\nimpl Trie {\n    fn new() -> Self {\n        Self::default()\n    }\n\n    fn insert(&mut self, word: String) {\n        let mut link = self;\n        for c in word.chars().rev() {\n            link = link.children.entry(c).or_default();\n        }\n        link.end = true;\n    }\n\n    fn search(&self, stream: &[char]) -> bool {\n        let mut link = self;\n        for c in stream.iter().rev() {\n            if let Some(next) = link.children.get(c) {\n                link = next;\n                if next.end {\n                    return true;\n                }\n            } else {\n                return false;\n            }\n        }\n        false\n    }\n}\n\nstruct StreamChecker {\n    trie: Trie,\n    stream: Vec<char>,\n}\n\nimpl StreamChecker {\n    fn new(words: Vec<String>) -> Self {\n        let mut trie = Trie::new();\n        for s in words {\n            trie.insert(s);\n        }\n        let stream = vec![];\n        StreamChecker { trie, stream }\n    }\n\n    fn query(&mut self, letter: char) -> bool {\n        self.stream.push(letter);\n        self.trie.search(&self.stream)\n    }\n}\n\n#[test]\nfn test() {\n    let words = vec_string![\"cd\", \"f\", \"kl\"];\n    let mut obj = StreamChecker::new(words);\n    assert_eq!(obj.query('a'), false);\n    assert_eq!(obj.query('b'), false);\n    assert_eq!(obj.query('c'), false);\n    assert_eq!(obj.query('d'), true);\n    assert_eq!(obj.query('e'), false);\n    assert_eq!(obj.query('f'), true);\n    assert_eq!(obj.query('g'), false);\n    assert_eq!(obj.query('h'), false);\n    assert_eq!(obj.query('i'), false);\n    assert_eq!(obj.query('j'), false);\n    assert_eq!(obj.query('k'), false);\n    assert_eq!(obj.query('l'), true);\n}\n"
    },
    {
        "input": "\n\nclass Solution(object):\n    def maxSumAfterPartitioning(self, A, K):\n        \n        if not A:\n            return 0\n        \n        N = len(A)\n        dp = [0]*(N+1)\n        for index_i in range(N):\n            maxi = 0\n            for index_j in range(index_i, index_i-K, -1):\n                if index_j >= 0 and index_j < len(A):\n                    maxi = max(maxi, A[index_j])\n                    \n                    dp[index_i+1] = max(dp[index_i+1], maxi*(index_i-index_j+1)+dp[index_j])\n            \n            \n                    \n        return dp[-1]\n",
        "output": "struct Solution;\n\nimpl Solution {\n    fn max_sum_after_partitioning(a: Vec<i32>, k: i32) -> i32 {\n        let n = a.len();\n        let mut dp = vec![0; n + 1];\n        let k = k as usize;\n        for r in 1..=n {\n            let l = r - 1;\n            let mut max = a[l];\n            for i in 0..k.min(r) {\n                max = max.max(a[l - i]);\n                dp[r] = dp[r].max(dp[l - i] + max * (i + 1) as i32);\n            }\n        }\n        dp[n]\n    }\n}\n\n#[test]\nfn test() {\n    let a = vec![1, 15, 7, 9, 2, 5, 10];\n    let k = 3;\n    let res = 84;\n    assert_eq!(Solution::max_sum_after_partitioning(a, k), res);\n}\n"
    },
    {
        "input": "\n\n\n\n\n\n\n\n\nclass Solution(object):\n    \n    def maxAncestorDiff(self, root):\n        \n        \n        def utility_fun(root, res):\n            if not root:\n                return 2147483648, -2147483648, res\n            if not root.left and not root.right:\n                return root.val, root.val, res\n            left_t, lmax_t, res = utility_fun(root.left, res)\n            right_t, rmax_t, res = utility_fun(root.right, res)\n            m_val = min(left_t, right_t)\n            max_val = max(lmax_t, rmax_t)\n                \n            res = max(res, max(abs(root.val-m_val), abs(root.val-max_val)))\n            \n            return min(m_val, root.val), max(max_val, root.val), res\n        \n        x, x2, res = utility_fun(root, -2147483648)\n        return abs(res)\n",
        "output": "struct Solution;\nuse rustgym_util::*;\n\ntrait Preorder {\n    fn preorder(&self, parent: Option<(i32, i32)>, abs: &mut i32);\n}\n\nimpl Preorder for TreeLink {\n    fn preorder(&self, mut parent: Option<(i32, i32)>, abs: &mut i32) {\n        if let Some(node) = self {\n            let val = node.borrow().val;\n            let left = &node.borrow().left;\n            let right = &node.borrow().right;\n            parent = if let Some((min, max)) = parent {\n                *abs = (*abs).max((min - val).abs().max((max - val).abs()));\n                Some((min.min(val), max.max(val)))\n            } else {\n                Some((val, val))\n            };\n            left.preorder(parent, abs);\n            right.preorder(parent, abs);\n        }\n    }\n}\n\nimpl Solution {\n    fn max_ancestor_diff(root: TreeLink) -> i32 {\n        let mut res = 0;\n        root.preorder(None, &mut res);\n        res\n    }\n}\n\n#[test]\nfn test() {\n    let root = tree!(\n        8,\n        tree!(3, tree!(1), tree!(6, tree!(4), tree!(7))),\n        tree!(10, None, tree!(14, tree!(13), None))\n    );\n    let res = 7;\n    assert_eq!(Solution::max_ancestor_diff(root), res);\n}\n"
    },
    {
        "input": "\n\nclass Solution(object):\n    def isValid(self, S):\n        \n        stack = []\n        if not S:\n            return False\n        \n        for char in S:\n            if char == 'a':\n                stack.append('a')\n            if char == 'b':\n                if not stack:\n                    return False\n                if stack[-1] == 'a':\n                    stack.pop()\n                    stack.append(char)\n            if char == 'c':\n                if not stack:\n                    return False\n                if stack[-1] == 'b':\n                    stack.pop()\n        return len(stack) == 0\n ",
        "output": "struct Solution;\n\nimpl Solution {\n    fn is_valid(s: String) -> bool {\n        let mut stack = vec![];\n        for c in s.chars() {\n            let n = stack.len();\n            if n > 1 && c == 'c' && stack[n - 1] == 'b' && stack[n - 2] == 'a' {\n                stack.pop();\n                stack.pop();\n            } else {\n                stack.push(c);\n            }\n        }\n        stack.is_empty()\n    }\n}\n\n#[test]\nfn test() {\n    let s = \"aabcbc\".to_string();\n    let res = true;\n    assert_eq!(Solution::is_valid(s), res);\n    let s = \"abcabcababcc\".to_string();\n    let res = true;\n    assert_eq!(Solution::is_valid(s), res);\n    let s = \"abccba\".to_string();\n    let res = false;\n    assert_eq!(Solution::is_valid(s), res);\n    let s = \"cababc\".to_string();\n    let res = false;\n    assert_eq!(Solution::is_valid(s), res);\n}\n"
    },
    {
        "input": "\n\nclass Solution(object):\n    def longestArithSeqLength(self, A):\n        \n        from collections import defaultdict\n\n        dp = defaultdict(int)\n        \n        for index_i in range(len(A)):\n            for index_j in range(index_i):\n                diff = A[index_i] - A[index_j]\n                dp[(index_i, diff)] = max(dp[(index_i, diff)], dp[(index_j, diff)]+1)\n                \n        return max(dp.itervalues())+1\n",
        "output": "struct Solution;\n\nuse std::collections::HashMap;\n\nimpl Solution {\n    fn longest_arith_seq_length(a: Vec<i32>) -> i32 {\n        let mut res = 0;\n        let n = a.len();\n        let mut dp: Vec<HashMap<i32, i32>> = vec![HashMap::new(); n];\n        for i in 0..n {\n            for j in 0..i {\n                let diff = a[i] - a[j];\n                let len_j = *dp[j].entry(diff).or_default();\n                let len_i = dp[i].entry(diff).or_default();\n                *len_i = len_j + 1;\n                res = res.max(*len_i);\n            }\n        }\n        res + 1\n    }\n}\n\n#[test]\nfn test() {\n    let a = vec![3, 6, 9, 12];\n    let res = 4;\n    assert_eq!(Solution::longest_arith_seq_length(a), res);\n    let a = vec![9, 4, 7, 2, 10];\n    let res = 3;\n    assert_eq!(Solution::longest_arith_seq_length(a), res);\n    let a = vec![20, 1, 15, 3, 10, 5, 8];\n    let res = 4;\n    assert_eq!(Solution::longest_arith_seq_length(a), res);\n}\n"
    },
    {
        "input": "\n\nclass Solution(object):\n    def longestOnes(self, A, K):\n        \n        start_index = 0\n        for end_index in range(0, len(A)):\n            K -= 1-A[end_index]\n            if K < 0:\n                K += 1-A[start_index]\n                start_index += 1\n        return end_index-start_index+1\n",
        "output": "struct Solution;\n\nimpl Solution {\n    fn longest_ones(a: Vec<i32>, k: i32) -> i32 {\n        let n = a.len();\n        let mut sum = 0;\n        let mut res = 0;\n        let mut start = 0;\n        let mut end = 0;\n        while end < n {\n            if sum <= k {\n                if a[end] == 0 {\n                    sum += 1;\n                }\n                end += 1;\n            } else {\n                if a[start] == 0 {\n                    sum -= 1;\n                }\n                start += 1;\n            }\n            if sum <= k {\n                res = res.max(end - start);\n            }\n        }\n        res as i32\n    }\n}\n\n#[test]\nfn test() {\n    let a = vec![1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0];\n    let k = 2;\n    let res = 6;\n    assert_eq!(Solution::longest_ones(a, k), res);\n    let a = vec![0, 0, 1, 1, 0, 0, 1, 1, 1, 0, 1, 1, 0, 0, 0, 1, 1, 1, 1];\n    let k = 3;\n    let res = 10;\n    assert_eq!(Solution::longest_ones(a, k), res);\n    let a = vec![0, 0, 0, 1];\n    let k = 4;\n    let res = 4;\n    assert_eq!(Solution::longest_ones(a, k), res);\n}\n"
    },
    {
        "input": "\n\nclass Solution(object):\n    def minDominoRotations(self, A, B):\n        \n        if len(A) != len(B):\n            return -1\n        if len(A) == 0:\n            return 0\n        \n        for possibility in set([A[0], B[0]]):\n            top_rotation, bottom_rotation =0, 0\n            for a_num, b_num in zip(A, B):\n                if possibility not in [a_num, b_num]:\n                    break\n                top_rotation += int(b_num != possibility)\n                bottom_rotation += int(a_num != possibility)\n            else:\n                return min(top_rotation, bottom_rotation)\n        return -1\n ",
        "output": "struct Solution;\n\nimpl Solution {\n    fn min_domino_rotations(a: Vec<i32>, b: Vec<i32>) -> i32 {\n        let mut count: Vec<Vec<usize>> = vec![vec![0; 3]; 6];\n        let n = a.len();\n        for i in 0..n {\n            let x = (a[i] - 1) as usize;\n            let y = (b[i] - 1) as usize;\n            count[x][0] += 1;\n            count[y][1] += 1;\n            if x == y {\n                count[x][2] += 1;\n            }\n        }\n        for i in 0..6 {\n            if count[i][0] + count[i][1] - count[i][2] >= n {\n                return (usize::min(count[i][0], count[i][1]) - count[i][2]) as i32;\n            }\n        }\n        -1\n    }\n}\n\n#[test]\nfn test() {\n    let a = vec![2, 1, 2, 4, 2, 2];\n    let b = vec![5, 2, 6, 2, 3, 2];\n    let res = 2;\n    assert_eq!(Solution::min_domino_rotations(a, b), res);\n    let a = vec![3, 5, 1, 2, 3];\n    let b = vec![3, 6, 3, 3, 4];\n    let res = -1;\n    assert_eq!(Solution::min_domino_rotations(a, b), res);\n}\n"
    },
    {
        "input": "\n\nclass Solution(object):\n    def queryString(self, S, N):\n        \n        for num in range(1, N+1):\n            binary_str = ''\n            while (num != 0):\n                binary_str += str(num%2)\n                num /= 2\n            reversed_str = binary_str[::-1]\n            \n            if reversed_str not in S:\n                return False\n        return True\n ",
        "output": "struct Solution;\n\nimpl Solution {\n    fn query_string(s: String, n: i32) -> bool {\n        for i in (1..=n).rev() {\n            let t = format!(\"{:b}\", i);\n            if !s.contains(&t) {\n                return false;\n            }\n        }\n        true\n    }\n}\n\n#[test]\nfn test() {\n    let s = \"0110\".to_string();\n    let n = 3;\n    let res = true;\n    assert_eq!(Solution::query_string(s, n), res);\n    let s = \"0110\".to_string();\n    let n = 4;\n    let res = false;\n    assert_eq!(Solution::query_string(s, n), res);\n}\n"
    },
    {
        "input": "\nclass Solution(object):\n    def maxScoreSightseeingPair(self, A):\n        \n        prev_best, result = 0, 0\n        for index in range(0, len(A)):\n            result = max(result, A[index]-index+prev_best)\n            prev_best = max(prev_best, A[index]+index)\n        return result\n ",
        "output": "struct Solution;\n\nimpl Solution {\n    fn max_score_sightseeing_pair(a: Vec<i32>) -> i32 {\n        let n = a.len();\n        let mut maxs = vec![];\n        let mut prev_max = 0;\n        let mut res = 0;\n        for i in 0..n {\n            prev_max = prev_max.max(i as i32 + a[i]);\n            maxs.push(prev_max);\n        }\n        for i in 1..n {\n            res = res.max(maxs[i - 1] + a[i] - i as i32);\n        }\n        res\n    }\n}\n\n#[test]\nfn test() {\n    let a = vec![8, 1, 5, 2, 6];\n    let res = 11;\n    assert_eq!(Solution::max_score_sightseeing_pair(a), res);\n}\n"
    },
    {
        "input": "\n\nclass Solution(object):\n    def numEnclaves(self, A):\n        \n        result = 0\n        queue = []\n        for row in range(len(A)):\n            for col in range(len(A[0])):\n                result += A[row][col]\n                if (row*col == 0 or row == len(A)-1 or col == len(A[0])-1) and A[row][col] == 1:\n                    queue.append((row, col))\n                    \n        x_move = [-1, 0, 1, 0]\n        y_move = [0, 1, 0, -1]\n        \n        while queue:\n            x, y = queue.pop(0)\n            A[x][y] = 0\n            result -= 1\n            \n            for xm, ym in zip(x_move, y_move):\n                nx = x + xm\n                ny = y + ym\n                \n                if 0<= nx <len(A) and 0 <= ny < len(A[0]) and A[nx][ny] == 1 and (nx, ny) not in queue:\n                    queue.append((nx, ny))\n\n        return result\n",
        "output": "struct Solution;\n\nimpl Solution {\n    fn num_enclaves(mut a: Vec<Vec<i32>>) -> i32 {\n        let n = a.len();\n        let m = a[0].len();\n        let mut res = 0;\n        for i in 0..n {\n            for j in 0..m {\n                if a[i][j] == 1 && (i == 0 || j == 0 || i + 1 == n || j + 1 == m) {\n                    Self::dfs(i, j, &mut a, n, m);\n                }\n            }\n        }\n        for i in 0..n {\n            for j in 0..m {\n                if a[i][j] == 1 {\n                    res += 1;\n                }\n            }\n        }\n\n        res as i32\n    }\n\n    fn dfs(i: usize, j: usize, a: &mut Vec<Vec<i32>>, n: usize, m: usize) {\n        a[i][j] = 0;\n        if i > 0 && a[i - 1][j] == 1 {\n            Self::dfs(i - 1, j, a, n, m);\n        }\n        if j > 0 && a[i][j - 1] == 1 {\n            Self::dfs(i, j - 1, a, n, m);\n        }\n        if i + 1 < n && a[i + 1][j] == 1 {\n            Self::dfs(i + 1, j, a, n, m);\n        }\n        if j + 1 < m && a[i][j + 1] == 1 {\n            Self::dfs(i, j + 1, a, n, m);\n        }\n    }\n}\n#[test]\nfn test() {\n    let a = vec_vec_i32![[0, 0, 0, 0], [1, 0, 1, 0], [0, 1, 1, 0], [0, 0, 0, 0]];\n    let res = 3;\n    assert_eq!(Solution::num_enclaves(a), res);\n    let a = vec_vec_i32![[0, 1, 1, 0], [0, 0, 1, 0], [0, 0, 1, 0], [0, 0, 0, 0]];\n    let res = 0;\n    assert_eq!(Solution::num_enclaves(a), res);\n}\n"
    },
    {
        "input": "\n\nclass Solution(object):\n    def permute(self, S):\n        \n        \n        if not S:\n            return []\n        if '{' not in S:\n            return [S]\n        stack, stack2 = [], []\n        brace = 0\n        for char in S:\n            if char == '{':\n                brace = 1\n            elif char == '}':\n                if not stack:\n                    stack = stack2\n                else:\n                    new_stack = []\n                    for char in stack:\n                        for char2 in stack2:\n                            new_stack.append(char + char2)\n                                \n                    stack = new_stack\n                stack2 = []\n                brace = 2\n            elif char != ',':\n                if brace == 1:\n                    stack2.append(char)\n                elif brace == 2:\n                    stack = [c + char for c in stack]\n                    stack2 = []\n                else:\n                    stack.append(char)\n                \n                \n        stack.sort() \n        stack.sort(key = len) \n        return stack\n",
        "output": "struct Solution;\n\nimpl Solution {\n    fn expand(s: String) -> Vec<String> {\n        let mut v: Vec<Vec<char>> = vec![];\n        let mut stack: Vec<char> = vec![];\n        let mut inbrace = false;\n        for c in s.chars() {\n            match c {\n                '{' => {\n                    inbrace = true;\n                }\n                '}' => {\n                    stack.sort_unstable();\n                    v.push(stack);\n                    stack = vec![];\n                    inbrace = false;\n                }\n                ',' => {}\n                _ => {\n                    if inbrace {\n                        stack.push(c);\n                    } else {\n                        v.push(vec![c]);\n                    }\n                }\n            }\n        }\n        let n = v.len();\n        let mut cur = vec![];\n        let mut res = vec![];\n        Self::dfs(0, &mut cur, &mut res, &v, n);\n        res\n    }\n\n    fn dfs(start: usize, cur: &mut Vec<char>, all: &mut Vec<String>, v: &[Vec<char>], n: usize) {\n        if start == n {\n            all.push(cur.iter().copied().collect());\n        } else {\n            for &c in &v[start] {\n                cur.push(c);\n                Self::dfs(start + 1, cur, all, v, n);\n                cur.pop();\n            }\n        }\n    }\n}\n\n#[test]\nfn test() {\n    let s = \"{a,b}c{d,e}f\".to_string();\n    let res: Vec<String> = vec_string![\"acdf\", \"acef\", \"bcdf\", \"bcef\"];\n    assert_eq!(Solution::expand(s), res);\n    let s = \"abcd\".to_string();\n    let res: Vec<String> = vec_string![\"abcd\"];\n    assert_eq!(Solution::expand(s), res);\n}\n"
    },
    {
        "input": "\nclass Solution(object):\n    def generate(self, numRows):\n        \n        triangle = []\n\n        for row in range(numRows):\n        \tnew_row = [0 for _ in range(row+1)]\n        \tnew_row[0], new_row[-1] = 1, 1\n\n        \tfor col in range(1, len(new_row)-1):\n        \t\tnew_row[col] = triangle[row-1][col-1] + triangle[row-1][col]\n        \ttriangle.append(new_row)\n        return triangle",
        "output": "struct Solution;\n\nimpl Solution {\n    fn generate(nums_rows: i32) -> Vec<Vec<i32>> {\n        let mut res: Vec<Vec<i32>> = vec![];\n        for i in 0..nums_rows {\n            let ui = i as usize;\n            res.push(vec![]);\n            for j in 0..=i {\n                let uj = j as usize;\n                if j == 0 || j == i {\n                    res[ui].push(1);\n                } else {\n                    let prev = &res[ui - 1];\n                    let sum = prev[uj - 1] + prev[uj];\n                    res[ui].push(sum);\n                }\n            }\n        }\n        res\n    }\n}\n\n#[test]\nfn test() {\n    let triangle_5 = vec![\n        vec![1],\n        vec![1, 1],\n        vec![1, 2, 1],\n        vec![1, 3, 3, 1],\n        vec![1, 4, 6, 4, 1],\n    ];\n    assert_eq!(Solution::generate(5), triangle_5);\n}\n"
    },
    {
        "input": "class Solution(object):\n    def numDistinct(self, s, t):\n        \n\n        row, col = len(s), len(t)\n\n        if col > row:\n        \treturn 0\n\n        dp = [[0 for _ in range(col+1)] for _ in range(row+1)]\n\n        for r in range(row+1):\n        \tfor c in range(col+1):\n        \t\tif r == 0 and c == 0:\n        \t\t\tdp[r][c] = 1\n        \t\telif r == 0:\n        \t\t\tdp[r][c] = 0\n        \t\telif c == 0:\n        \t\t\tdp[r][c] = 1\n        \t\telse:\n        \t\t\tdp[r][c] = dp[r-1][c]\n        \t\t\tif s[r-1] == t[c-1]:\n        \t\t\t\tdp[r][c] += dp[r-1][c-1]\n        return dp[row][col] \n\n\n",
        "output": "struct Solution;\n\nimpl Solution {\n    fn is_palindrome(s: String) -> bool {\n        let s: Vec<char> = s\n            .chars()\n            .filter(|c| c.is_ascii_alphanumeric())\n            .map(|c| c.to_ascii_lowercase())\n            .collect();\n        let a: String = s.iter().collect();\n        let b: String = s.iter().rev().collect();\n        a == b\n    }\n}\n\n#[test]\nfn test() {\n    let s = \"A man, a plan, a canal: Panama\".to_string();\n    let res = true;\n    assert_eq!(Solution::is_palindrome(s), res);\n    let s = \"race a car\".to_string();\n    let res = false;\n    assert_eq!(Solution::is_palindrome(s), res);\n}\n"
    },
    {
        "input": "\n\nclass Solution(object):\n    def numDistinct(self, s, t):\n        \n\n        row, col = len(s), len(t)\n\n        if col > row:\n        \treturn 0\n\n        dp = [[0 for _ in range(col+1)] for _ in range(row+1)]\n\n        for r in range(row+1):\n        \tfor c in range(col+1):\n        \t\tif r == 0 and c == 0:\n        \t\t\tdp[r][c] = 1\n        \t\telif r == 0:\n        \t\t\tdp[r][c] = 0\n        \t\telif c == 0:\n        \t\t\tdp[r][c] = 1\n        \t\telse:\n        \t\t\tdp[r][c] = dp[r-1][c]\n        \t\t\tif s[r-1] == t[c-1]:\n        \t\t\t\tdp[r][c] += dp[r-1][c-1]\n        return dp[row][col] ",
        "output": "struct Solution;\n\nuse std::collections::HashMap;\n\nimpl Solution {\n    fn num_distinct(s: String, t: String) -> i32 {\n        let mut memo: HashMap<(usize, usize), i32> = HashMap::new();\n        let s: Vec<char> = s.chars().collect();\n        let t: Vec<char> = t.chars().collect();\n        let n = s.len();\n        let m = t.len();\n        Self::dp(0, 0, &mut memo, &s, &t, n, m)\n    }\n\n    fn dp(\n        i: usize,\n        j: usize,\n        memo: &mut HashMap<(usize, usize), i32>,\n        s: &[char],\n        t: &[char],\n        n: usize,\n        m: usize,\n    ) -> i32 {\n        if let Some(&res) = memo.get(&(i, j)) {\n            return res;\n        }\n        let res = if j == m {\n            1\n        } else {\n            if i == n {\n                0\n            } else {\n                if s[i] == t[j] {\n                    Self::dp(i + 1, j + 1, memo, s, t, n, m) + Self::dp(i + 1, j, memo, s, t, n, m)\n                } else {\n                    Self::dp(i + 1, j, memo, s, t, n, m)\n                }\n            }\n        };\n        memo.insert((i, j), res);\n        res\n    }\n}\n\n#[test]\nfn test() {\n    let s = \"rabbbit\".to_string();\n    let t = \"rabbit\".to_string();\n    let res = 3;\n    assert_eq!(Solution::num_distinct(s, t), res);\n    let s = \"babgbag\".to_string();\n    let t = \"bag\".to_string();\n    let res = 5;\n    assert_eq!(Solution::num_distinct(s, t), res);\n}\n"
    },
    {
        "input": "\n\n\n\n\n\n\n\n\n\nclass BSTIterator(object):\n    def __init__(self, root):\n        \n        self.stack = []\n        while root:\n            self.stack.append(root)\n            root = root.left\n        \n\n    def hasNext(self):\n        \n        return self.stack\n\n    def next(self):\n        \n        node = self.stack.pop()\n        new_node = node.right\n        while new_node:\n            self.stack.append(new_node)\n            new_node = new_node.left\n        return node.val\n\n\n\n",
        "output": "use rustgym_util::*;\n\nstruct BSTIterator {\n    root: TreeLink,\n    stack: Vec<TreeLink>,\n}\n\nimpl BSTIterator {\n    fn new(root: TreeLink) -> Self {\n        let mut stack = vec![];\n        Self::push_all_left(root.clone(), &mut stack);\n        BSTIterator { root, stack }\n    }\n\n    fn has_next(&self) -> bool {\n        !self.stack.is_empty()\n    }\n\n    fn next(&mut self) -> i32 {\n        let link = self.stack.pop().unwrap().unwrap();\n        let val = link.borrow().val;\n        Self::push_all_left(link.borrow().right.clone(), &mut self.stack);\n        val\n    }\n\n    fn push_all_left(mut p: TreeLink, stack: &mut Vec<TreeLink>) {\n        while let Some(link) = p.clone() {\n            stack.push(p.clone());\n            p = link.borrow().left.clone();\n        }\n    }\n}\n\n#[test]\nfn test() {\n    let root = tree!(7, tree!(3), tree!(15, tree!(9), tree!(20)));\n    let mut it = BSTIterator::new(root);\n    assert_eq!(it.next(), 3);\n    assert_eq!(it.next(), 7);\n    assert_eq!(it.has_next(), true);\n    assert_eq!(it.next(), 9);\n    assert_eq!(it.has_next(), true);\n    assert_eq!(it.next(), 15);\n    assert_eq!(it.has_next(), true);\n    assert_eq!(it.next(), 20);\n    assert_eq!(it.has_next(), false);\n}\n"
    },
    {
        "input": "\n\nclass Solution(object):\n    def wordBreak(self, s, wordDict):\n        \n        dp = [False for _ in range(len(s)+1)]\n        dp[0] = True\n        for index in range(len(s)):\n        \tfor j in range(i, -1, -1):\n        \t\tif dp[j] and s[j:i+1] in wordDict:\n        \t\t\tdp[i+1] = True\n        \t\t\tbreak\n        return dp[len(s)]",
        "output": "struct Solution;\nuse std::collections::HashSet;\nuse std::iter::FromIterator;\n\nimpl Solution {\n    fn word_break(s: String, word_dict: Vec<String>) -> bool {\n        let n = s.len();\n        let mut a = vec![false; n + 1];\n        let hs: HashSet<String> = HashSet::from_iter(word_dict);\n        a[0] = true;\n        for i in 1..=n {\n            for j in 0..i {\n                if a[j] && hs.contains(&s[j..i]) {\n                    a[i] = true;\n                    break;\n                }\n            }\n        }\n        a[n]\n    }\n}\n\n#[test]\nfn test() {\n    let s = \"leetcode\".to_string();\n    let word_dict = vec_string![\"leet\", \"code\"];\n    let res = true;\n    assert_eq!(Solution::word_break(s, word_dict), res);\n    let s = \"applepenapple\".to_string();\n    let word_dict = vec_string![\"apple\", \"pen\"];\n    let res = true;\n    assert_eq!(Solution::word_break(s, word_dict), res);\n    let s = \"catsandog\".to_string();\n    let word_dict = vec_string![\"cats\", \"dog\", \"sand\", \"and\", \"cat\"];\n    let res = false;\n    assert_eq!(Solution::word_break(s, word_dict), res);\n}\n"
    },
    {
        "input": "'''\n\tGiven a list of non negative integers, arrange them such that they form the largest number.\n\n\tExample 1:\n\n\tInput: [10,2]\n\tOutput: \"210\"\n\tExample 2:\n\n\tInput: [3,30,34,5,9]\n\tOutput: \"9534330\"\n\n\n\nclass Solution:\n    \n    \n    def largestNumber(self, nums):\n    \tnums = [str(num) for num in nums]\n    \tnums.sort(cmp=lambda x, y : cmp(y+x, x+y))\n    \treturn ''.join(nums).lstrip(\"0\") or \"0\"",
        "output": "struct Solution;\n\nimpl Solution {\n    fn largest_number(nums: Vec<i32>) -> String {\n        let mut v: Vec<String> = nums.iter().map(|x| x.to_string()).collect();\n        v.sort_unstable_by(|a, b| format!(\"{}{}\", b, a).cmp(&format!(\"{}{}\", a, b)));\n        let mut res: String = \"\".to_string();\n        if v[0] == \"0\" {\n            return \"0\".to_string();\n        }\n        for s in v {\n            res += &s;\n        }\n        res\n    }\n}\n\n#[test]\nfn test() {\n    let nums = vec![10, 2];\n    let res = \"210\".to_string();\n    assert_eq!(Solution::largest_number(nums), res);\n    let nums = vec![3, 30, 34, 5, 9];\n    let res = \"9534330\".to_string();\n    assert_eq!(Solution::largest_number(nums), res);\n    let nums = vec![0, 0];\n    let res = \"0\".to_string();\n    assert_eq!(Solution::largest_number(nums), res);\n    let nums = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\n    let res = \"9876543210\".to_string();\n    assert_eq!(Solution::largest_number(nums), res);\n}\n"
    },
    {
        "input": "\n\nclass TwoSum(object):\n\n    def __init__(self):\n        \n        self.value_count = {}\n\n    def add(self, number):\n        \n        if number in self.value_count:\n        \tself.value_count[number] += 1\n        else:\n        \tself.value_count[number] = 1\n\n    def find(self, value):\n        \n        for val in self.value_count:\n        \tdiff = value - val\n        \tif diff in self.value_count and (diff != val or self.value_count[val] > 1):\n        \t\treturn True\n        return False\n\n\n\n\n",
        "output": "use std::collections::HashMap;\nuse std::i32;\n\n#[derive(Default)]\nstruct TwoSum {\n    numbers: HashMap<i32, usize>,\n    max: i32,\n    min: i32,\n}\n\nimpl TwoSum {\n    fn new() -> Self {\n        TwoSum {\n            numbers: HashMap::new(),\n            max: i32::MIN,\n            min: i32::MAX,\n        }\n    }\n\n    fn add(&mut self, number: i32) {\n        self.max = i32::max(self.max, number << 1);\n        self.min = i32::min(self.min, number << 1);\n        self.numbers\n            .insert(number, self.numbers.get(&number).unwrap_or(&0) + 1);\n    }\n\n    fn find(&self, value: i32) -> bool {\n        if value < self.min || value > self.max {\n            return false;\n        }\n        for (&a, &v) in &self.numbers {\n            let b = value - a;\n            if a == b && v == 2 {\n                return true;\n            }\n            if a != b && self.numbers.contains_key(&b) {\n                return true;\n            }\n        }\n        false\n    }\n}\n\n#[test]\nfn test() {\n    let mut two_some = TwoSum::new();\n    two_some.add(1);\n    two_some.add(3);\n    two_some.add(5);\n    let value = 4;\n    let res = true;\n    assert_eq!(two_some.find(value), res);\n    let value = 7;\n    let res = false;\n    assert_eq!(two_some.find(value), res);\n}\n"
    },
    {
        "input": "\n\n\n\n\n\n\n\n\nclass Solution(object):\n    def levelOrderBottom(self, root):\n        \n\n        if not root:\n        \treturn []\n\n        queue = [(root, 0)]\n        levelMap = {}\n\n        while queue:\n        \tnode, level = queue.pop(0)\n        \tif node.left:\n        \t\tqueue.append((node.left, level+1))\n        \tif node.right:\n        \t\tqueue.append((node.right, level+1))\n\n        \tif level in levelMap:\n        \t\tlevelMap[level].append(node.val)\n        \telse:\n        \t\tlevelMap[level] = [node.val]\n\n        result = []\n        for key, value in levelMap.iteritems():\n        \tresult.append(value)\n        return result[::-1]",
        "output": "struct Solution;\nuse rustgym_util::*;\nuse std::collections::VecDeque;\n\nstruct Pair {\n    tree: TreeLink,\n    level: usize,\n}\n\nimpl Solution {\n    fn level_order_bottom(root: TreeLink) -> Vec<Vec<i32>> {\n        let mut levels: Vec<Vec<i32>> = vec![];\n        let mut queue: VecDeque<Pair> = VecDeque::new();\n        if root.is_some() {\n            queue.push_back(Pair {\n                tree: root,\n                level: 0,\n            });\n            while let Some(pair) = queue.pop_front() {\n                let node = pair.tree.unwrap();\n                let mut node = node.borrow_mut();\n                let level = pair.level;\n                let val = node.val;\n                let left = node.left.take();\n                let right = node.right.take();\n                if let Some(group) = levels.get_mut(level) {\n                    group.push(val);\n                } else {\n                    let group = vec![val];\n                    levels.insert(level, group);\n                }\n                if left.is_some() {\n                    queue.push_back(Pair {\n                        tree: left,\n                        level: level + 1,\n                    });\n                }\n                if right.is_some() {\n                    queue.push_back(Pair {\n                        tree: right,\n                        level: level + 1,\n                    });\n                }\n            }\n        }\n        levels.reverse();\n        levels\n    }\n}\n\n#[test]\nfn test() {\n    let tree = tree!(3, tree!(9), tree!(20, tree!(15), tree!(7)));\n    let nodes = vec![vec![15, 7], vec![9, 20], vec![3]];\n    assert_eq!(Solution::level_order_bottom(tree), nodes);\n}\n"
    },
    {
        "input": "\n\nclass Solution(object):\n\tdef missingRange(self, A, lower, upper):\n\t\tif not A:\n\t\t\treturn []\n\n\t\tresult = []\n\t\tif A[0] != lower:\n\t\t\tend = A[0] - 1\n\t\t\tif end == lower:\n\t\t\t\tm_r = str(lower)\n\t\t\telse:\n\t\t\t\tm_r = str(lower) + \"->\" + str(end)\n\t\t\tresult.append(m_r)\n\n\t\tfor index in range(1, len(A)):\n\t\t\tif A[index] != A[index-1] + 1:\n\t\t\t\tstart = A[index-1] + 1\n\t\t\t\tend = A[index] - 1\n\t\t\t\tif start == end:\n\t\t\t\t\tm_r = str(start)\n\t\t\t\telse:\n\t\t\t\t\tm_r = str(start) + \"->\" + str(end)\n\t\t\t\tresult.append(m_r)\n\n\t\tif A[len(A) - 1] != upper:\n\t\t\tstart = A[len(A)-1] + 1\n\t\t\tif start == upper:\n\t\t\t\tm_r = str(start)\n\t\t\telse:\n\t\t\t\tm_r = str(start) + \"->\" + str(upper)\n\t\t\tresult.append(m_r)\n\t\treturn result\n\nsolution = Solution()\nprint solution.missingRange([0, 1, 3, 50, 75], 0, 99)\nprint solution.missingRange([4, 10, 50, 98], 0, 99)\nprint solution.missingRange([0], 0, 1)",
        "output": "struct Solution;\nuse std::fmt;\n\nstruct Interval(i64, i64);\n\nimpl std::fmt::Display for Interval {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        if self.0 == self.1 {\n            write!(f, \"{}\", self.0)\n        } else {\n            write!(f, \"{}->{}\", self.0, self.1)\n        }\n    }\n}\n\nimpl Solution {\n    fn find_missing_ranges(nums: Vec<i32>, lower: i32, upper: i32) -> Vec<String> {\n        let mut cur = Interval(lower as i64, upper as i64);\n        let mut res: Vec<Interval> = vec![];\n        for x in nums {\n            let x = x as i64;\n            if x > cur.0 {\n                res.push(Interval(cur.0, x - 1));\n            }\n            cur.0 = x + 1;\n        }\n        if cur.0 <= cur.1 {\n            res.push(cur);\n        }\n        res.iter().map(|x| x.to_string()).collect()\n    }\n}\n\n#[test]\nfn test() {\n    let nums = vec![0, 1, 3, 50, 75];\n    let lower = 0;\n    let upper = 99;\n    let res = vec_string![\"2\", \"4->49\", \"51->74\", \"76->99\"];\n    assert_eq!(Solution::find_missing_ranges(nums, lower, upper), res);\n    let nums = vec![2_147_483_647];\n    let lower = 0;\n    let upper = 2_147_483_647;\n    let res = vec_string![\"0->2147483646\"];\n    assert_eq!(Solution::find_missing_ranges(nums, lower, upper), res);\n}\n"
    },
    {
        "input": "\n\n\n\n\n\n\n\n\nclass Solution(object):\n    def pathSum(self, root, sum):\n        \n        \n        result = []\n\n        def dfs(root, curr_sum, sum, path, result):\n        \tif not root:\n        \t\treturn\n\n        \tcurr_sum += root.val\n        \tif curr_sum == sum and not root.left and not root.right:\n        \t\tresult.append(path + [root.val])\n        \t\treturn\n\n        \tif root.left:\n        \t\tdfs(root.left, curr_sum, sum, path + [root.val], result)\n        \tif root.right:\n        \t\tdfs(root.right, curr_sum, sum, path + [root.val], result)\n\n        dfs(root, 0, sum, [], result)\n        return result",
        "output": "struct Solution;\nuse rustgym_util::*;\n\ntrait Preorder {\n    fn preorder(&self, target: i32, path: &mut Vec<i32>, all: &mut Vec<Vec<i32>>);\n}\n\nimpl Preorder for TreeLink {\n    fn preorder(&self, target: i32, path: &mut Vec<i32>, all: &mut Vec<Vec<i32>>) {\n        if let Some(node) = self {\n            let node = node.borrow();\n            let val = node.val;\n            path.push(val);\n            if node.left.is_none() && node.right.is_none() {\n                if val == target {\n                    all.push(path.to_vec());\n                }\n            } else {\n                node.left.preorder(target - val, path, all);\n                node.right.preorder(target - val, path, all);\n            }\n            path.pop();\n        }\n    }\n}\n\nimpl Solution {\n    fn path_sum(root: TreeLink, sum: i32) -> Vec<Vec<i32>> {\n        let mut res = vec![];\n        let mut path = vec![];\n        root.preorder(sum, &mut path, &mut res);\n        res\n    }\n}\n\n#[test]\nfn test() {\n    let root = tree!(\n        5,\n        tree!(4, tree!(11, tree!(7), tree!(2)), None),\n        tree!(8, tree!(13), tree!(4, tree!(5), tree!(1)))\n    );\n    let sum = 22;\n    let res = vec_vec_i32![[5, 4, 11, 2], [5, 8, 4, 5]];\n    assert_eq!(Solution::path_sum(root, sum), res);\n}\n"
    },
    {
        "input": "\n\n\n\n\n\n\n\n\nclass Solution(object):\n    def isSameTree(self, p, q):\n        \n        if not p and not q:\n        \treturn True \n\n        stack = [(p, q)]\n\n        while stack:\n        \tnode1, node2 = stack.pop()\n        \tif node1 and node2 and node1.val == node2.val:\n        \t\tstack.append((node1.left, node2.left))\n        \t\tstack.append((node1.right, node2.right))\n        \telse:\n        \t\tif not node1 == node2:\n        \t\t\treturn False \n\n        return True",
        "output": "struct Solution;\nuse rustgym_util::*;\n\nimpl Solution {\n    fn is_same_tree(p: TreeLink, q: TreeLink) -> bool {\n        p == q\n    }\n}\n\n#[test]\nfn test() {\n    let q = tree!(\n        1,\n        tree!(2, tree!(1), tree!(1)),\n        tree!(2, tree!(1), tree!(1))\n    );\n    let p = tree!(\n        1,\n        tree!(2, tree!(1), tree!(1)),\n        tree!(2, tree!(1), tree!(1))\n    );\n    let res = true;\n    assert_eq!(Solution::is_same_tree(p, q), res);\n}\n"
    },
    {
        "input": "\n\nclass Solution(object):\n    def ladderLength(self, beginWord, endWord, wordList):\n        \n        d = {}\n        for word in wordList:\n        \tfor i in range(len(word)):\n        \t\ts = word[:i] + \"_\" + word[i+1:]\n        \t\tif s in d:\n        \t\t\td[s].append(word)\n        \t\telse:\n        \t\t\td[s] = [word]\n        print d\n        queue, visited = [], set()\n        queue.append((beginWord, 1))\n        while queue:\n        \tword, steps = queue.pop(0)\n        \tif word not in visited:\n        \t\tvisited.add(word)\n\n        \t\tif word == endWord:\n        \t\t\treturn steps\n        \t\telse:\n\t        \t\tfor index in range(len(word)):\n\t        \t\t\ts = word[:index] + \"_\" + word[index+1:]\n\t        \t\t\tneigh_words = []\n\t        \t\t\tif s in d:\n\t        \t\t\t\tneigh_words = d[s]\n\n\t        \t\t\tfor neigh in neigh_words:\n\t        \t\t\t\tif neigh not in visited:\n\t        \t\t\t\t\tqueue.append((neigh, steps+1))\n        return 0\n\nSolution().ladderLength(\"hit\", \"cog\", [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]  )",
        "output": "struct Solution;\nuse std::collections::HashSet;\nuse std::iter::FromIterator;\n\nimpl Solution {\n    fn ladder_length(begin_word: String, end_word: String, word_list: Vec<String>) -> i32 {\n        let n = begin_word.len();\n        let mut unused_set: HashSet<Vec<u8>> = word_list\n            .into_iter()\n            .map(|s| s.as_bytes().to_vec())\n            .collect();\n        let begin_word = begin_word.as_bytes().to_vec();\n        let end_word = end_word.as_bytes().to_vec();\n        if !unused_set.contains(&end_word) {\n            return 0;\n        }\n        let begin_list = vec![begin_word];\n        let end_list = vec![end_word];\n        let mut begin_set: HashSet<Vec<u8>> = HashSet::from_iter(begin_list);\n        let mut end_set: HashSet<Vec<u8>> = HashSet::from_iter(end_list);\n        let mut left_set: &mut HashSet<Vec<u8>> = &mut begin_set;\n        let mut right_set: &mut HashSet<Vec<u8>> = &mut end_set;\n        let mut ladder = 1;\n        while !left_set.is_empty() {\n            ladder += 1;\n            let mut next_set: HashSet<Vec<u8>> = HashSet::new();\n            for s in left_set.iter() {\n                let mut v: Vec<u8> = s.to_vec();\n                for i in 0..n {\n                    let c = v[i];\n                    for j in 0..26 {\n                        v[i] = b'a' + j;\n                        if right_set.contains(&v) {\n                            return ladder;\n                        }\n                        if unused_set.contains(&v) {\n                            unused_set.remove(&v);\n                            next_set.insert(v.to_vec());\n                        }\n                    }\n                    v[i] = c;\n                }\n            }\n            *left_set = next_set;\n            if left_set.len() > right_set.len() {\n                std::mem::swap(&mut left_set, &mut right_set)\n            }\n        }\n        0\n    }\n}\n\n#[test]\nfn test() {\n    let begin_word = \"hit\".to_string();\n    let end_word = \"cog\".to_string();\n    let word_list = vec_string![\"hot\", \"dot\", \"dog\", \"lot\", \"log\", \"cog\"];\n    assert_eq!(Solution::ladder_length(begin_word, end_word, word_list), 5);\n    let begin_word = \"hit\".to_string();\n    let end_word = \"cog\".to_string();\n    let word_list = vec_string![\"hot\", \"dot\", \"dog\", \"lot\", \"log\"];\n    assert_eq!(Solution::ladder_length(begin_word, end_word, word_list), 0);\n}\n"
    },
    {
        "input": "\n\n\n\n\n\n\n\n\nclass Solution(object):\n    def minDepth(self, root):\n    \tif not root:\n    \t\treturn 0\n    \tdepth = float('inf')\n    \tstack = [(root, 1)]\n\n    \twhile stack:\n    \t\tnode, level = stack.pop()\n    \t\tif node:\n\n    \t\t\tif not node.left and not node.right:\n    \t\t\t\tdepth = min(depth, level)\n\n    \t\t\tstack.append((node.left, level+1))\n    \t\t\tstack.append((node.right, level+1))\n\n    \treturn depth",
        "output": "struct Solution;\nuse rustgym_util::*;\n\ntrait MinDepth {\n    fn min_depth(&self) -> usize;\n}\n\nimpl MinDepth for TreeLink {\n    fn min_depth(&self) -> usize {\n        match self {\n            None => 0,\n            Some(node) => {\n                let node = node.borrow();\n                match (&node.left, &node.right) {\n                    (None, None) => 1,\n                    (Some(_), None) => TreeLink::min_depth(&node.left) + 1,\n                    (None, Some(_)) => TreeLink::min_depth(&node.right) + 1,\n                    (Some(_), Some(_)) => {\n                        usize::min(\n                            TreeLink::min_depth(&node.left),\n                            TreeLink::min_depth(&node.right),\n                        ) + 1\n                    }\n                }\n            }\n        }\n    }\n}\n\nimpl Solution {\n    fn min_depth(root: TreeLink) -> i32 {\n        root.min_depth() as i32\n    }\n}\n\n#[test]\nfn test() {\n    let root = tree!(3, tree!(9), tree!(20, tree!(15), tree!(7)));\n    assert_eq!(Solution::min_depth(root), 2);\n}\n"
    },
    {
        "input": "\n\n\n\n\n\n\n\n\nclass Solution(object):\n    def zigzagLevelOrder(self, root):\n        \n\n        if not root:\n        \treturn []\n\n        queue = [(root, 0)]\n        levelMap = {}\n\n        while queue:\n        \tnode, level = queue.pop(0)\n        \tif node.left:\n        \t\tqueue.append((node.left, level+1))\n        \tif node.right:\n        \t\tqueue.append((node.right, level+1))\n\n        \tif level in levelMap:\n        \t\tlevelMap[level].append(node.val)\n        \telse:\n        \t\tlevelMap[level] = [node.val]\n\n        result = []\n        spiral = False\n        for key, value in levelMap.iteritems():\n            if spiral:\n                value = value[::-1]\n            result.append(value)\n            spiral = not spiral\n        return result",
        "output": "struct Solution;\nuse rustgym_util::*;\n\ntrait Preorder {\n    fn preorder(&self, level: usize, levels: &mut Vec<Vec<i32>>);\n}\n\nimpl Preorder for TreeLink {\n    fn preorder(&self, level: usize, levels: &mut Vec<Vec<i32>>) {\n        if let Some(node) = self {\n            let node = node.borrow();\n            let val = node.val;\n            if level == levels.len() {\n                levels.push(vec![val]);\n            } else {\n                levels[level].push(val);\n            }\n            node.left.preorder(level + 1, levels);\n            node.right.preorder(level + 1, levels);\n        }\n    }\n}\n\nimpl Solution {\n    fn zigzag_level_order(root: TreeLink) -> Vec<Vec<i32>> {\n        let mut levels: Vec<Vec<i32>> = vec![];\n        root.preorder(0, &mut levels);\n        for i in 0..levels.len() {\n            if i % 2 == 1 {\n                levels[i].reverse();\n            }\n        }\n        levels\n    }\n}\n\n#[test]\nfn test() {\n    let root = tree!(3, tree!(9), tree!(20, tree!(15), tree!(7)));\n    let res = vec_vec_i32![[3], [20, 9], [15, 7]];\n    assert_eq!(Solution::zigzag_level_order(root), res);\n}\n"
    },
    {
        "input": "\n\nclass Solution(object):\n    def solve(self, board):\n        \n        if len(board) == 0:\n            return\n        for row in range(len(board)):\n            if board[row][0] == 'O':\n                self.merge(board, row, 0)\n            if board[row][len(board[0])-1] == 'O':\n                self.merge(board, row, len(board[0])-1)\n        \n        for col in range(len(board[0])):\n            if board[0][col] == 'O':\n                self.merge(board, 0, col)\n            \n            if board[len(board)-1][col] == 'O':\n                self.merge(board, len(board)-1, col)\n                \n        for row in range(len(board)):\n            for col in range(len(board[0])):\n                if board[row][col] == 'O':\n                    board[row][col] = 'X'\n                elif board[row][col] == '\n                    board[row][col] = 'O'\n                    \n    def merge(self, board, row, col):\n        if row < 0 or col < 0 or row >= len(board) or col >= len(board[0]):\n            return \n        if board[row][col] != 'O':\n            return \n        \n        board[row][col] = '\n        self.merge(board, row+1, col)\n        self.merge(board, row, col-1)\n        self.merge(board, row, col+1)\n        self.merge(board, row-1, col)  ",
        "output": "struct Solution;\n\nimpl Solution {\n    fn solve(board: &mut Vec<Vec<char>>) {\n        let n = board.len();\n        if n == 0 {\n            return;\n        }\n        let m = board[0].len();\n        let mut visited = vec![vec![false; m]; n];\n        for i in 0..n {\n            for j in 0..m {\n                if i == 0 || j == 0 || i == n - 1 || j == m - 1 {\n                    if board[i][j] == 'O' && !visited[i][j] {\n                        Self::dfs(i, j, &mut visited, board, n, m);\n                    }\n                }\n            }\n        }\n        for i in 0..n {\n            for j in 0..m {\n                if !visited[i][j] {\n                    board[i][j] = 'X';\n                }\n            }\n        }\n    }\n\n    fn dfs(i: usize, j: usize, visited: &mut [Vec<bool>], board: &[Vec<char>], n: usize, m: usize) {\n        visited[i][j] = true;\n        if i > 0 && !visited[i - 1][j] && board[i - 1][j] == 'O' {\n            Self::dfs(i - 1, j, visited, board, n, m);\n        }\n        if j > 0 && !visited[i][j - 1] && board[i][j - 1] == 'O' {\n            Self::dfs(i, j - 1, visited, board, n, m);\n        }\n        if i + 1 < n && !visited[i + 1][j] && board[i + 1][j] == 'O' {\n            Self::dfs(i + 1, j, visited, board, n, m);\n        }\n        if j + 1 < m && !visited[i][j + 1] && board[i][j + 1] == 'O' {\n            Self::dfs(i, j + 1, visited, board, n, m);\n        }\n    }\n}\n\n#[test]\nfn test() {\n    let mut board = vec_vec_char![\n        ['X', 'X', 'X', 'X'],\n        ['X', 'O', 'O', 'X'],\n        ['X', 'X', 'O', 'X'],\n        ['X', 'O', 'X', 'X']\n    ];\n    let res = vec_vec_char![\n        ['X', 'X', 'X', 'X'],\n        ['X', 'X', 'X', 'X'],\n        ['X', 'X', 'X', 'X'],\n        ['X', 'O', 'X', 'X']\n    ];\n    Solution::solve(&mut board);\n    assert_eq!(board, res);\n}\n"
    },
    {
        "input": "\n\nclass Solution(object):\n    def findPeakElement(self, nums):\n        \n        left, right = 0, len(nums)-1\n        while left < right:\n        \tmid = (left + right) /2\n        \tif nums[mid] > nums[mid+1]:\n        \t\tright = mid\n        \telse:\n        \t\tleft = mid + 1\n        return left\n\n\nclass Solution(object):\n    def findPeakElement(self, nums):\n        \n        left = [False]*len(nums)\n        right = [False]*len(nums)\n        left[0], right[len(nums)-1] = True, True\n\n        for index in range(1, len(nums)):\n            if nums[index] > nums[index-1]:\n                left[index] = True\n\n        for index in range(len(nums)-2, -1, -1):\n            if nums[index] > nums[index+1]:\n                right[index] = True\n\n        for index in range(len(left)):\n            if left[index] and right[index]:\n                return index\n        return -1",
        "output": "struct Solution;\n\nimpl Solution {\n    fn find_peak_element(nums: Vec<i32>) -> i32 {\n        let mut l = 0;\n        let mut h = nums.len() - 1;\n        while l < h {\n            let m1 = l + (h - l) / 2;\n            let m2 = m1 + 1;\n            if nums[m1] < nums[m2] {\n                l = m2;\n            } else {\n                h = m1;\n            }\n        }\n        l as i32\n    }\n}\n\n#[test]\nfn test() {\n    let nums = vec![1, 2, 3, 1];\n    let res = 2;\n    assert_eq!(Solution::find_peak_element(nums), res);\n    let nums = vec![1, 2, 1, 3, 5, 6, 4];\n    let res = 5;\n    assert_eq!(Solution::find_peak_element(nums), res);\n}\n"
    },
    {
        "input": "\n\nclass Solution(object):\n    def maxProfit(self, prices):\n        \n        if len(prices) < 2:\n        \treturn 0\n        dp = [[0 for _ in range(len(prices))] for _ in range(3)]\n        for i in range(1,3):\n        \tmaxDiff = -prices[0]\n        \tfor j in range(1,len(prices)):\n        \t\tdp[i][j] = max(dp[i][j-1], prices[j] + maxDiff)\n        \t\tmaxDiff = max(maxDiff, dp[i-1][j] -prices[j])\n\n        return dp[2][len(prices)-1]\n\n",
        "output": "struct Solution;\n\nimpl Solution {\n    fn max_profit(prices: Vec<i32>) -> i32 {\n        let mut t1_cost = std::i32::MAX;\n        let mut t2_cost = std::i32::MAX;\n        let mut t1_profit = 0;\n        let mut t2_profit = 0;\n        for x in prices {\n            t1_cost = t1_cost.min(x);\n            t1_profit = t1_profit.max(x - t1_cost);\n            t2_cost = t2_cost.min(x - t1_profit);\n            t2_profit = t2_profit.max(x - t2_cost);\n        }\n        t2_profit\n    }\n}\n\n#[test]\nfn test() {\n    let prices = vec![3, 3, 5, 0, 0, 3, 1, 4];\n    let res = 6;\n    assert_eq!(Solution::max_profit(prices), res);\n    let prices = vec![1, 2, 3, 4, 5];\n    let res = 4;\n    assert_eq!(Solution::max_profit(prices), res);\n    let prices = vec![7, 6, 4, 3, 1];\n    let res = 0;\n    assert_eq!(Solution::max_profit(prices), res);\n}\n"
    },
    {
        "input": "\n\n\n\n\n\nclass Solution(object):\n    def insertionSortList(self, head):\n        \n\n        if not head:\n        \treturn None\n\n        sortedList = head\n        head = head.next\n        sortedList.next = None\n\n        while head:\n        \tcurr = head\n        \thead = head.next\n        \tif curr.val <= sortedList.val:\n        \t\tcurr.next = sortedList\n        \t\tsortedList = curr\n        \telse:\n        \t\ttemp = sortedList\n        \t\twhile temp.next and temp.next.val < curr.val:\n        \t\t\ttemp = temp.next\n        \t\tcurr.next = temp.next\n        \t\ttemp.next = curr\n        return sortedList",
        "output": "struct Solution;\nuse rustgym_util::*;\n\ntrait Insertion {\n    fn insert(self, link: ListLink) -> ListLink;\n}\n\nimpl Insertion for ListLink {\n    fn insert(self, mut link: ListLink) -> ListLink {\n        let val = link.as_ref().unwrap().val;\n        if let Some(mut node) = self {\n            if node.val > val {\n                link.as_mut().unwrap().next = Some(node);\n                link\n            } else {\n                node.next = node.next.take().insert(link);\n                Some(node)\n            }\n        } else {\n            link\n        }\n    }\n}\n\nimpl Solution {\n    fn insertion_sort_list(mut head: ListLink) -> ListLink {\n        let mut prev = None;\n        while let Some(mut node) = head {\n            head = node.next.take();\n            prev = prev.insert(Some(node));\n        }\n        prev\n    }\n}\n\n#[test]\nfn test() {\n    let head = list!(4, 2, 1, 3);\n    let res = list!(1, 2, 3, 4);\n    assert_eq!(Solution::insertion_sort_list(head), res);\n    let head = list!(-1, 5, 3, 4, 0);\n    let res = list!(-1, 0, 3, 4, 5);\n    assert_eq!(Solution::insertion_sort_list(head), res);\n}\n"
    },
    {
        "input": "\n\n \n\n\n\n\n\n\nclass Solution(object):\n    def buildTree(self, inorder, postorder):\n        \n        self.index = len(inorder)-1\n        def recursive(postorder, inorder, start, end):\n        \tif start > end:\n        \t\treturn None\n\n        \tnode = TreeNode(postorder[self.index])\n        \tself.index -= 1\n        \tif start == end:\n        \t\treturn node\n\n        \tsearch_index = 0\n        \tfor i in range(start, end+1):\n        \t\tif inorder[i] == node.val:\n        \t\t\tsearch_index = i\n        \t\t\tbreak\n        \tnode.right = recursive(postorder, inorder, search_index+1, end)\n        \tnode.left = recursive(postorder, inorder, start, search_index-1)\n        \treturn node\n\n        return recursive(postorder, inorder, 0, len(inorder)-1)",
        "output": "struct Solution;\nuse rustgym_util::*;\n\nimpl Solution {\n    fn build_tree(inorder: Vec<i32>, postorder: Vec<i32>) -> TreeLink {\n        let n = inorder.len();\n        Self::build(&inorder[0..n], &postorder[0..n])\n    }\n\n    fn build(inorder: &[i32], postorder: &[i32]) -> TreeLink {\n        let n = inorder.len();\n        if n == 0 {\n            None\n        } else {\n            let val = postorder[n - 1];\n            let i = inorder.iter().position(|&x| x == val).unwrap();\n            tree!(\n                val,\n                Self::build(&inorder[0..i], &postorder[0..i]),\n                Self::build(&inorder[i + 1..n], &postorder[i..n - 1])\n            )\n        }\n    }\n}\n\n#[test]\nfn test() {\n    let inorder = vec![9, 3, 15, 20, 7];\n    let postorder = vec![9, 15, 7, 20, 3];\n    let res = tree!(3, tree!(9), tree!(20, tree!(15), tree!(7)));\n    assert_eq!(Solution::build_tree(inorder, postorder), res);\n}\n"
    },
    {
        "input": "\n\nclass MinStack(object):\n\n    def __init__(self):\n        \n        self.stack = []  \n        self.minimum = float('inf')      \n\n    def push(self, x):\n        \n        if not self.stack:\n        \tself.stack.append(x)\n        \tself.minimum = x\n        else:\n        \tif x < self.minimum:\n        \t\tself.stack.append(2*x-self.minimum)\n        \t\tself.minimum = x\n        \telse:\n        \t\tself.stack.append(x)\n\n        print self.stack\n                \n\n    def pop(self):\n        \n        if self.stack:\n        \ttop = self.stack.pop()\n        \tif top < self.minimum:\n        \t\tself.minimum = 2*self.minimum - top\n        \n\n    def top(self):\n        \n        if not self.stack:\n        \treturn None\n        else:\n        \ttop = self.stack[-1]\n        \tif top < self.minimum:\n        \t\treturn self.minimum\n        \telse:\n        \t\treturn top\n        \n\n    def getMin(self):\n        \n        if self.stack:\n        \treturn self.minimum\n        else:\n        \treturn None\n\n\n\n\n\n\n\n\n",
        "output": "#[derive(Default)]\nstruct MinStack {\n    nums: Vec<i32>,\n    mins: Vec<i32>,\n    top: i32,\n    min: i32,\n}\n\nimpl MinStack {\n    fn new() -> Self {\n        MinStack {\n            nums: vec![],\n            mins: vec![],\n            top: 0,\n            min: 0,\n        }\n    }\n\n    fn push(&mut self, x: i32) {\n        self.nums.push(x);\n        if let Some(&min) = self.mins.last() {\n            self.mins.push(i32::min(x, min));\n        } else {\n            self.mins.push(x);\n        }\n        self.set_min();\n        self.set_top();\n    }\n\n    fn pop(&mut self) {\n        self.nums.pop();\n        self.mins.pop();\n        self.set_min();\n        self.set_top();\n    }\n\n    fn set_top(&mut self) {\n        self.top = if let Some(&last) = self.nums.last() {\n            last\n        } else {\n            0\n        }\n    }\n\n    fn set_min(&mut self) {\n        self.min = if let Some(&last) = self.mins.last() {\n            last\n        } else {\n            0\n        }\n    }\n\n    fn top(&self) -> i32 {\n        self.top\n    }\n\n    fn get_min(&self) -> i32 {\n        self.min\n    }\n}\n\n#[test]\nfn test() {\n    let mut min_stack = MinStack::new();\n    min_stack.push(-2);\n    min_stack.push(0);\n    min_stack.push(-3);\n    assert_eq!(min_stack.get_min(), -3);\n    min_stack.pop();\n    assert_eq!(min_stack.top(), 0);\n    assert_eq!(min_stack.get_min(), -2);\n}\n"
    },
    {
        "input": "\nclass Solution(object):\n    def getRow(self, rowIndex):\n        \n        row = [1]*(rowIndex+1)\n        for i in range(1, rowIndex+1):\n        \tfor j in range(i-1, 0, -1):\n        \t\trow[j] += row[j-1]\n        return row",
        "output": "struct Solution;\n\nimpl Solution {\n    fn get_row(row_index: i32) -> Vec<i32> {\n        let row_index = row_index as usize;\n        if row_index == 0 {\n            return vec![1];\n        }\n        if row_index == 1 {\n            return vec![1, 1];\n        }\n        let mut row = vec![1, 1];\n        for i in 2..=row_index {\n            let mut temp = vec![1; row_index as usize + 1];\n            for j in 1..i {\n                temp[j] = row[j - 1] + row[j]\n            }\n            row = temp\n        }\n        row\n    }\n}\n\n#[test]\nfn test() {\n    assert_eq!(Solution::get_row(4), vec![1, 4, 6, 4, 1]);\n}\n"
    },
    {
        "input": "\n\n\n\n\n\n\n\n\nclass Solution(object):\n    def sumNumbers(self, root):\n        \n        if not root:\n        \treturn 0\n\n        def dfs(root, num, total):\n        \tif not root:\n        \t\treturn total\n        \tnum = num*10 + root.val\n        \tif not root.left and not root.right:\n        \t\ttotal += num\n        \t\treturn total\n\n        \treturn dfs(root.left, num) + dfs(root.right, num)\n\n        return dfs(root, 0, 0)",
        "output": "struct Solution;\nuse rustgym_util::*;\n\ntrait Preorder {\n    fn preorder(&self, path: i32, sum: &mut i32);\n}\n\nimpl Preorder for TreeLink {\n    fn preorder(&self, path: i32, sum: &mut i32) {\n        if let Some(node) = self {\n            let node = node.borrow();\n            let val = node.val;\n            let path = path * 10 + val;\n            if node.left.is_none() && node.right.is_none() {\n                *sum += path;\n            }\n            node.left.preorder(path, sum);\n            node.right.preorder(path, sum);\n        }\n    }\n}\n\nimpl Solution {\n    fn sum_numbers(root: TreeLink) -> i32 {\n        let mut res = 0;\n        root.preorder(0, &mut res);\n        res\n    }\n}\n\n#[test]\nfn test() {\n    let root = tree!(1, tree!(2), tree!(3));\n    let res = 25;\n    assert_eq!(Solution::sum_numbers(root), res);\n    let root = tree!(4, tree!(9, tree!(5), tree!(1)), tree!(0));\n    let res = 1026;\n    assert_eq!(Solution::sum_numbers(root), res);\n}\n"
    },
    {
        "input": "class Solution(object):\n    def wordBreak(self, s, wordDict):\n        \n        self.result = []\n        self.dfs(s, wordDict, '')\n        return self.result\n\n    def dfs(self, s, wordDict, currStr):\n    \tif self.check(s, wordDict):\n    \t\tif len(s) == 0:\n    \t\t\tself.result.append(currStr[1:])\n    \t\tfor i in range(1, len(s)+1):\n    \t\t\tif s[:i] in wordDict:\n    \t\t\t\tself.dfs(s[i:], wordDict, currStr + ' ' + s[:i])\n\n    def check(self, s, wordDict):\n    \tdp = [False for _ in range(len(s)+1)]\n    \tdp[0] = True\n\n    \tfor i in range(len(s)):\n    \t\tfor j in range(i, -1, -1):\n    \t\t\tif dp[j] and s[j:i+1] in wordDict:\n    \t\t\t\tdp[i+1] = True\n    \t\t\t\tbreak\n\n    \treturn dp[len(s)]",
        "output": "struct Solution;\n\nuse std::collections::hash_map::DefaultHasher;\nuse std::collections::HashSet;\nuse std::hash::Hasher;\n\nimpl Solution {\n    fn word_break(s: String, word_dict: Vec<String>) -> Vec<String> {\n        let n = s.len();\n        let mut dict: HashSet<u64> = HashSet::new();\n        let mut alphabet: Vec<bool> = vec![false; 256];\n        for word in word_dict {\n            let mut hasher = DefaultHasher::new();\n            for b in word.bytes() {\n                alphabet[b as usize] = true;\n                hasher.write_u8(b);\n            }\n            dict.insert(hasher.finish());\n        }\n        let s: Vec<u8> = s.bytes().collect();\n        for i in 0..n {\n            if !alphabet[s[i] as usize] {\n                return vec![];\n            }\n        }\n        let mut cur = vec![];\n        let mut res = vec![];\n        Self::dfs(0, &mut cur, &mut res, &dict, &s, n);\n        res\n    }\n\n    fn dfs(\n        start: usize,\n        cur: &mut Vec<(usize, usize)>,\n        all: &mut Vec<String>,\n        dict: &HashSet<u64>,\n        s: &[u8],\n        n: usize,\n    ) {\n        if start == n {\n            let mut words = vec![];\n            for &(l, r) in cur.iter() {\n                let mut word = \"\".to_string();\n                for i in l..=r {\n                    word.push(s[i] as char);\n                }\n                words.push(word);\n            }\n            all.push(words.join(\" \"));\n        }\n        let mut hasher = DefaultHasher::new();\n        for i in start..n {\n            hasher.write_u8(s[i]);\n            if dict.contains(&hasher.finish()) {\n                cur.push((start, i));\n                Self::dfs(i + 1, cur, all, dict, s, n);\n                cur.pop();\n            }\n        }\n    }\n}\n\n#[test]\nfn test() {\n    let s = \"catsanddog\".to_string();\n    let word_dict = vec_string![\"cat\", \"cats\", \"and\", \"sand\", \"dog\"];\n    let mut res = vec_string![\"cats and dog\", \"cat sand dog\"];\n    let mut ans = Solution::word_break(s, word_dict);\n    res.sort();\n    ans.sort();\n    assert_eq!(ans, res);\n    let s = \"pineapplepenapple\".to_string();\n    let word_dict = vec_string![\"apple\", \"pen\", \"applepen\", \"pine\", \"pineapple\"];\n    let mut res = vec_string![\n        \"pine apple pen apple\",\n        \"pineapple pen apple\",\n        \"pine applepen apple\"\n    ];\n    let mut ans = Solution::word_break(s, word_dict);\n    res.sort();\n    ans.sort();\n    assert_eq!(ans, res);\n    let s = \"catsandog\".to_string();\n    let word_dict = vec_string![\"cats\", \"dog\", \"sand\", \"and\", \"cat\"];\n    let mut res = vec_string![];\n    let mut ans = Solution::word_break(s, word_dict);\n    res.sort();\n    ans.sort();\n    assert_eq!(ans, res);\n}\n"
    },
    {
        "input": "\n\nclass Solution(object):\n    def longestConsecutive(self, nums):\n        \n        result = 0\n        nums = set(nums)\n\n        for num in nums:\n        \tif num-1 not in nums:\n        \t\tcurr = num\n        \t\tlength = 1\n\n        \t\twhile curr+1 in nums:\n        \t\t\tcurr += 1\n        \t\t\tlength += 1\n        \t\tresult = max(result, length)\n        return result",
        "output": "struct Solution;\nuse std::collections::HashSet;\nuse std::iter::FromIterator;\n\nimpl Solution {\n    fn longest_consecutive(nums: Vec<i32>) -> i32 {\n        if nums.is_empty() {\n            return 0;\n        }\n        let hs: HashSet<i32> = HashSet::from_iter(nums);\n        let mut res = 0;\n        for &x in &hs {\n            if hs.contains(&(x - 1)) {\n                continue;\n            }\n            let mut i = 1;\n            while hs.contains(&(x + i)) {\n                i += 1;\n                res = res.max(i);\n            }\n        }\n        res\n    }\n}\n\n#[test]\nfn test() {\n    let nums = vec![100, 4, 200, 1, 3, 2];\n    let res = 4;\n    assert_eq!(Solution::longest_consecutive(nums), res);\n}\n"
    },
    {
        "input": "\n\nclass Solution(object):\n    def partition(self, s):\n    \tresult = []\n    \tdef valid(s):\n    \t\tfor i in range(len(s)/2):\n    \t\t\tif s[i] != s[-(i+1)]:\n    \t\t\t\treturn False\n    \t\treturn True\n\n    \tdef partitionRec(curr, s, i):\n    \t\tif i == len(s):\n    \t\t\tresult.append(curr)\n    \t\telse:\n    \t\t\tfor j in range(i, len(s)):\n    \t\t\t\tif valid(s[i:j+1]):\n    \t\t\t\t\tpartitionRec(curr + [s[i:j+1]], s, j+1)\n\n    \tpartitionRec([], s, 0)\n    \treturn result",
        "output": "struct Solution;\n\nimpl Solution {\n    fn partition(s: String) -> Vec<Vec<String>> {\n        let mut res: Vec<Vec<String>> = vec![];\n        let s: Vec<char> = s.chars().collect();\n        let n = s.len();\n        let mut indexes: Vec<(usize, usize)> = vec![];\n        Self::dfs(0, &mut indexes, &mut res, &s, n);\n        res\n    }\n    fn dfs(\n        start: usize,\n        indexes: &mut Vec<(usize, usize)>,\n        strings: &mut Vec<Vec<String>>,\n        s: &[char],\n        n: usize,\n    ) {\n        if start == n {\n            let mut partition: Vec<String> = vec![];\n            for &(l, r) in indexes.iter() {\n                partition.push(s[l..r].iter().collect());\n            }\n            strings.push(partition);\n        }\n        for end in start + 1..=n {\n            if Self::is_palindrome(&s[start..end]) {\n                indexes.push((start, end));\n                Self::dfs(end, indexes, strings, s, n);\n                indexes.pop();\n            }\n        }\n    }\n    fn is_palindrome(s: &[char]) -> bool {\n        let n = s.len();\n        for i in 0..n {\n            let j = n - 1 - i;\n            if s[i] != s[j] {\n                return false;\n            }\n        }\n        true\n    }\n}\n\n#[test]\nfn test() {\n    let s = \"aab\".to_string();\n    let mut res = vec_vec_string![[\"aa\", \"b\"], [\"a\", \"a\", \"b\"]];\n    let mut ans = Solution::partition(s);\n    ans.sort();\n    res.sort();\n    assert_eq!(ans, res);\n    let s = \"efe\".to_string();\n    let mut res = vec_vec_string![[\"e\", \"f\", \"e\"], [\"efe\"]];\n    let mut ans = Solution::partition(s);\n    ans.sort();\n    res.sort();\n    assert_eq!(ans, res);\n}\n"
    },
    {
        "input": "\n\n\n\n\n\n\n\n\nclass Solution(object):\n    def postorderTraversal(self, root):\n        \n        \n        result = []\n\n        def recursive(root, result):\n        \tif not root:\n        \t\treturn\n        \trecursive(root.left, result)\n        \trecursive(root.right, result)\n        \tresult.append(root.val)\n        recursive(root, result)\n        return result\n\n\n\n\n\n\n\n\n\nclass Solution(object):\n    def postorderTraversal(self, root):\n        \n\n        if not root:\n        \treturn []\n\n        stack, result = [], []\n\n        while True:\n        \twhile root:\n        \t\tif root.right:\n        \t\t\tstack.append(root.right)\n        \t\tstack.append(root)\n        \t\troot = root.left\n\n        \troot = stack.pop()\n\n        \tif root.right and stack and stack[-1] == root.right:\n        \t\tstack.pop()\n        \t\tstack.append(root)\n        \t\troot = root.right\n        \telse:\n        \t\tresult.append(root.val)\n        \t\troot = None\n\n        \tif  len(stack)<=0:\n        \t\tbreak\n\n        return result",
        "output": "struct Solution;\nuse rustgym_util::*;\n\ntrait Postorder {\n    fn postorder(&self, nodes: &mut Vec<i32>);\n}\n\nimpl Postorder for TreeLink {\n    fn postorder(&self, nodes: &mut Vec<i32>) {\n        if let Some(node) = self {\n            let node = node.borrow();\n            node.left.postorder(nodes);\n            node.right.postorder(nodes);\n            nodes.push(node.val);\n        }\n    }\n}\n\nimpl Solution {\n    fn postorder_traversal(root: TreeLink) -> Vec<i32> {\n        let mut res = vec![];\n        root.postorder(&mut res);\n        res\n    }\n}\n\n#[test]\nfn test() {\n    let root = tree!(1, None, tree!(2, tree!(3), None));\n    let res = vec![3, 2, 1];\n    assert_eq!(Solution::postorder_traversal(root), res);\n}\n"
    },
    {
        "input": "\n\nclass Solution(object):\n    def maxProduct(self, nums):\n        \n        \n        if not nums:\n        \treturn 0\n\n        max_so_far, min_so_far, result = nums[0], nums[0], nums[0]\n\n        for index in range(1, len(nums)):\n        \tif nums[index] > 0:\n        \t\tmax_so_far = max(max_so_far*nums[index], nums[index])\n        \t\tmin_so_far = min(min_so_far*nums[index], nums[index])\n        \telse:\n        \t\ttemp = max_so_far\n        \t\tmax_so_far = max(min_so_far*nums[index], nums[index])\n        \t\tmin_so_far = min(temp*nums[index], nums[index])\n\n        \tresult = max(result, max_so_far)\n        return result",
        "output": "struct Solution;\n\nuse std::i32;\nuse std::mem::swap;\n\nimpl Solution {\n    fn max_product(nums: Vec<i32>) -> i32 {\n        let mut res = nums[0];\n        let mut min = res;\n        let mut max = res;\n        let n = nums.len();\n        for i in 1..n {\n            let x = nums[i];\n            if x < 0 {\n                swap(&mut min, &mut max);\n            }\n            max = i32::max(x, max * x);\n            min = i32::min(x, min * x);\n            res = i32::max(res, max);\n        }\n        res\n    }\n}\n\n#[test]\nfn test() {\n    let nums = vec![2, 3, -2, 4];\n    assert_eq!(Solution::max_product(nums), 6);\n    let nums = vec![-2, 0, -1];\n    assert_eq!(Solution::max_product(nums), 0);\n}\n"
    },
    {
        "input": "\n\n\n\n\n\n\n\n\nclass Solution(object):\n    def buildTree(self, preorder, inorder):\n        \n        self.index = 0\n        def recursive(preorder, inorder, start, end):\n        \tif start > end:\n        \t\treturn None\n\n        \tnode = TreeNode(preorder[self.index])\n        \tself.index += 1\n        \tif start == end:\n        \t\treturn node\n\n        \tsearch_index = 0\n        \tfor i in range(start, end+1):\n        \t\tif inorder[i] == node.val:\n        \t\t\tsearch_index = i\n        \t\t\tbreak\n\n        \tnode.left = recursive(preorder, inorder, start, search_index-1)\n        \tnode.right = recursive(preorder, inorder, search_index+1, end)\n        \treturn node\n\n        return recursive(preorder, inorder, 0, len(inorder)-1)",
        "output": "struct Solution;\nuse rustgym_util::*;\n\nimpl Solution {\n    fn build_tree(preorder: Vec<i32>, inorder: Vec<i32>) -> TreeLink {\n        let n = preorder.len();\n        Self::build(&preorder[0..n], &inorder[0..n])\n    }\n\n    fn build(preorder: &[i32], inorder: &[i32]) -> TreeLink {\n        let n = preorder.len();\n        if n == 0 {\n            None\n        } else {\n            let val = preorder[0];\n            let i = inorder.iter().position(|&x| x == val).unwrap();\n            tree!(\n                val,\n                Self::build(&preorder[1..=i], &inorder[0..i]),\n                Self::build(&preorder[i + 1..], &inorder[i + 1..])\n            )\n        }\n    }\n}\n\n#[test]\nfn test() {\n    let preorder = vec![3, 9, 20, 15, 7];\n    let inorder = vec![9, 3, 15, 20, 7];\n    let res = tree!(3, tree!(9), tree!(20, tree!(15), tree!(7)));\n    assert_eq!(Solution::build_tree(preorder, inorder), res);\n}\n"
    },
    {
        "input": "\n\nclass Solution(object):\n    def canCompleteCircuit(self, gas, cost):\n        \n        start, curr_sum, total_sum =0, 0, 0\n        for index in range(len(gas)):\n            diff = gas[index] - cost[index]\n            total_sum += diff\n            curr_sum += diff\n            \n            if curr_sum < 0:\n                start = index + 1\n                curr_sum = 0\n                \n        if total_sum >= 0:\n            return start\n        return -1",
        "output": "struct Solution;\n\nimpl Solution {\n    fn can_complete_circuit(gas: Vec<i32>, cost: Vec<i32>) -> i32 {\n        let n = gas.len();\n\n        let mut total = 0;\n        let mut cur = 0;\n        let mut idx = 0;\n\n        for i in 0..n {\n            total += gas[i] - cost[i];\n            cur += gas[i] - cost[i];\n\n            if cur < 0 {\n                idx = i + 1;\n                cur = 0;\n            }\n        }\n\n        if total >= 0 {\n            idx as i32\n        } else {\n            -1\n        }\n    }\n}\n\n#[test]\nfn test() {\n    let gas = vec![1, 2, 3, 4, 5];\n    let cost = vec![3, 4, 5, 1, 2];\n    let res = 3;\n    assert_eq!(Solution::can_complete_circuit(gas, cost), res);\n}\n"
    },
    {
        "input": "\n\nclass Node(object):\n    def __init__(self, key, value):\n        self.key = key\n        self.value = value\n        self.next = None\n        self.prev = None\n        \nclass LRUCache(object):\n\n    def __init__(self, capacity):\n        \n        self.capacity = capacity\n        self.mapping = dict()\n        self.head = Node(0, 0)\n        self.tail = Node(0, 0)\n        self.head.next = self.tail\n        self.tail.prev = self.head\n        \n\n    def get(self, key):\n        \n        if key in self.mapping:\n            node = self.mapping[key]\n            self.remove(node)\n            self.add(node)\n            return node.value\n        return -1\n        \n\n    def put(self, key, value):\n        \n        \n        if key in self.mapping:\n            self.remove(self.mapping[key])\n            \n        node = Node(key, value)\n        if len(self.mapping) >= self.capacity:\n            next_head = self.head.next\n            self.remove(next_head)\n            del self.mapping[next_head.key]\n            \n        self.add(node)\n        self.mapping[key] = node\n        \n    def add(self, node):\n        tail = self.tail.prev\n        tail.next = node\n        self.tail.prev = node\n        node.prev = tail\n        node.next = self.tail\n        \n    def remove(self, node):\n        prev_node = node.prev\n        prev_node.next = node.next\n        node.next.prev = prev_node\n        \n        \n\n\n\n\n\n",
        "output": "use std::cell::RefCell;\nuse std::collections::HashMap;\nuse std::fmt::Debug;\nuse std::fmt::Error;\nuse std::fmt::Formatter;\nuse std::rc::{Rc, Weak};\n\ntype NodeRef = Rc<RefCell<Node>>;\ntype Link = Option<NodeRef>;\n\n#[derive(Debug, Clone)]\nstruct Element {\n    key: i32,\n    val: i32,\n}\n\nimpl Element {\n    fn new(key: i32, val: i32) -> Self {\n        Element { key, val }\n    }\n}\n\n#[derive(Debug)]\nstruct Node {\n    element: Element,\n    prev: Link,\n    next: Link,\n}\n\nimpl Node {\n    fn new(element: Element) -> Self {\n        Node {\n            element,\n            prev: None,\n            next: None,\n        }\n    }\n    fn into_ref(self) -> NodeRef {\n        Rc::new(RefCell::new(self))\n    }\n}\n\n#[derive(Default)]\nstruct List {\n    head: Link,\n    tail: Link,\n}\n\nimpl List {\n    fn new() -> Self {\n        List {\n            head: None,\n            tail: None,\n        }\n    }\n\n    fn push_back(&mut self, new_node_ref: NodeRef) {\n        new_node_ref.borrow_mut().prev = self.tail.clone();\n        match self.tail.clone() {\n            None => self.head = Some(new_node_ref.clone()),\n            Some(last_node_ref) => last_node_ref.borrow_mut().next = Some(new_node_ref.clone()),\n        }\n        self.tail = Some(new_node_ref);\n    }\n\n    fn pop_front(&mut self) -> Option<Element> {\n        self.head.clone().map(|node_ref| {\n            let mut node = node_ref.borrow_mut();\n            if let Some(next_node_ref) = node.next.take() {\n                let mut next_node = next_node_ref.borrow_mut();\n                next_node.prev = None;\n                self.head = Some(next_node_ref.clone());\n            } else {\n                self.head = None;\n                self.tail = None;\n            }\n            node.element.clone()\n        })\n    }\n\n    fn unlink_node(&mut self, node_ref: NodeRef) -> Element {\n        let mut node = node_ref.borrow_mut();\n        let prev = node.prev.take();\n        let next = node.next.take();\n        match prev.clone() {\n            Some(prev_node_ref) => prev_node_ref.borrow_mut().next = next.clone(),\n            None => self.head = next.clone(),\n        }\n        match next {\n            Some(next_node_ref) => next_node_ref.borrow_mut().prev = prev,\n            None => self.tail = prev,\n        }\n        node.element.clone()\n    }\n    fn iter(&self) -> ListIter {\n        ListIter::new(self.head.clone(), self.tail.clone())\n    }\n}\n\nimpl Debug for List {\n    fn fmt(&self, f: &mut Formatter<'_>) -> Result<(), Error> {\n        f.debug_list().entries(self.iter()).finish()\n    }\n}\n\nimpl Drop for List {\n    fn drop(&mut self) {\n        while self.pop_front().is_some() {}\n    }\n}\n\nstruct ListIter {\n    head: Link,\n    tail: Link,\n}\n\nimpl ListIter {\n    fn new(head: Link, tail: Link) -> Self {\n        ListIter { head, tail }\n    }\n}\n\nimpl Iterator for ListIter {\n    type Item = Element;\n    fn next(&mut self) -> Option<Self::Item> {\n        self.head.clone().map(|node_ref| {\n            let node = node_ref.borrow();\n            self.head = node.next.clone();\n            node.element.clone()\n        })\n    }\n}\n\n#[derive(Debug)]\nstruct LRUCache {\n    hash_map: HashMap<i32, Weak<RefCell<Node>>>,\n    list: List,\n    length: usize,\n    capacity: usize,\n}\n\nimpl LRUCache {\n    fn new(capacity: i32) -> Self {\n        let hash_map: HashMap<i32, Weak<RefCell<Node>>> = HashMap::new();\n        let list: List = List::new();\n        let length = 0;\n        let capacity = capacity as usize;\n        LRUCache {\n            hash_map,\n            list,\n            length,\n            capacity,\n        }\n    }\n\n    fn get(&mut self, key: i32) -> i32 {\n        if let Some(element) = self.get_element(key) {\n            element.val\n        } else {\n            -1\n        }\n    }\n\n    fn put(&mut self, key: i32, val: i32) {\n        if self.put_element(key, val).is_none() {\n            self.length += 1;\n        }\n        if self.length > self.capacity {\n            self.pop_element();\n            self.length -= 1;\n        }\n    }\n\n    fn pop_element(&mut self) -> Option<Element> {\n        if let Some(element) = self.list.pop_front() {\n            self.hash_map.remove(&element.key);\n            Some(element)\n        } else {\n            None\n        }\n    }\n\n    fn put_element(&mut self, key: i32, val: i32) -> Option<Element> {\n        if let Some(node_ref) = self.get_ref(key) {\n            let old_element = self.list.unlink_node(node_ref);\n            let new_element = Element::new(key, val);\n            let new_node_ref = Node::new(new_element).into_ref();\n            self.hash_map.insert(key, Rc::downgrade(&new_node_ref));\n            self.list.push_back(new_node_ref);\n            Some(old_element)\n        } else {\n            let new_element = Element::new(key, val);\n            let new_node_ref = Node::new(new_element).into_ref();\n            self.hash_map.insert(key, Rc::downgrade(&new_node_ref));\n            self.list.push_back(new_node_ref);\n            None\n        }\n    }\n\n    fn get_element(&mut self, key: i32) -> Option<Element> {\n        if let Some(node_ref) = self.get_ref(key) {\n            let old_element = self.list.unlink_node(node_ref);\n            let new_element = Element::new(old_element.key, old_element.val);\n            let new_node_ref = Node::new(new_element).into_ref();\n            self.hash_map.insert(key, Rc::downgrade(&new_node_ref));\n            self.list.push_back(new_node_ref);\n            Some(old_element)\n        } else {\n            None\n        }\n    }\n\n    fn get_ref(&mut self, key: i32) -> Option<NodeRef> {\n        if let Some(weak) = self.hash_map.remove(&key) {\n            weak.upgrade()\n        } else {\n            None\n        }\n    }\n}\n\n#[test]\nfn test() {\n    let mut obj = LRUCache::new(2);\n    assert_eq!(obj.get(2), -1);\n    obj.put(2, 6);\n    assert_eq!(obj.get(1), -1);\n    obj.put(1, 5);\n    obj.put(1, 2);\n    assert_eq!(obj.get(1), 2);\n    assert_eq!(obj.get(2), 6);\n\n    let mut obj = LRUCache::new(3);\n    obj.put(1, 1);\n    obj.put(2, 2);\n    obj.put(3, 3);\n    obj.put(4, 4);\n    assert_eq!(obj.get(4), 4);\n    assert_eq!(obj.get(3), 3);\n    assert_eq!(obj.get(2), 2);\n    assert_eq!(obj.get(1), -1);\n    obj.put(5, 5);\n    assert_eq!(obj.get(1), -1);\n    assert_eq!(obj.get(2), 2);\n    assert_eq!(obj.get(3), 3);\n    assert_eq!(obj.get(4), -1);\n    assert_eq!(obj.get(5), 5);\n}\n"
    },
    {
        "input": "\n\nclass Solution(object):\n\tdef lengthOfLongestSubstringTwoDistinct(self, s):\n\t\t\n        if not s:\n        \treturn 0\n\n        unique_char, start, result = {}, 0, 0\n        for index, char in enumerate(s):\n        \tif char in unique_char:\n        \t\tunique_char[s] += 1\n        \telse:\n        \t\tunique_char[s] = 1\n\n        \tif len(unique_char) <= 2:\n        \t\tresult = max(result, index-start+1)\n        \telse:\n        \t\twhile len(unique_char) > 2:\n        \t\t\tchar_index = s[start]\n        \t\t\tcount = unique_char[char_index]\n        \t\t\tif count == 1:\n        \t\t\t\tdel unique_char[char_index]\n        \t\t\telse:\n        \t\t\t\tunique_char[char_index] -= 1\n        \t\t\tstart += 1\n        return result\n",
        "output": "struct Solution;\n\nimpl Solution {\n    fn length_of_longest_substring_two_distinct(s: String) -> i32 {\n        let s: Vec<char> = s.chars().collect();\n        let mut count: Vec<usize> = vec![0; 256];\n        let mut start = 0;\n        let mut end = 0;\n        let mut res = 0;\n        let n = s.len();\n        let mut sum = 0;\n        while end < n {\n            if sum <= 2 {\n                count[s[end] as usize] += 1;\n                if count[s[end] as usize] == 1 {\n                    sum += 1;\n                }\n                end += 1;\n            } else {\n                count[s[start] as usize] -= 1;\n                if count[s[start] as usize] == 0 {\n                    sum -= 1;\n                }\n                start += 1;\n            }\n            if sum <= 2 {\n                res = res.max(end - start);\n            }\n        }\n        res as i32\n    }\n}\n\n#[test]\nfn test() {\n    let s = \"eceba\".to_string();\n    let res = 3;\n    assert_eq!(Solution::length_of_longest_substring_two_distinct(s), res);\n    let s = \"ccaabbb\".to_string();\n    let res = 5;\n    assert_eq!(Solution::length_of_longest_substring_two_distinct(s), res);\n}\n"
    },
    {
        "input": "\n\nclass Solution(object):\n    def evalRPN(self, tokens):\n        \n        \n        if not tokens:\n            return 0\n        \n        stack = []\n        for val in tokens:\n            if val == '+':\n                val1 = stack.pop()\n                val2 = stack.pop()\n                stack.append(val1 + val2)\n            elif val == '-':\n                val1  = stack.pop()\n                val2 = stack.pop()\n                stack.append(val2-val1)\n            elif val == '*':\n                val1  = stack.pop()\n                val2  = stack.pop()\n                stack.append(val2*val1)\n            elif val == '/':\n                val1 = stack.pop()\n                val2  = stack.pop()\n                if val1*val2 < 0:\n                    stack.append(-(-val2/val1))\n                else:\n                    stack.append(val2/val1)\n            else:\n                stack.append(int(val))\n        return stack[0]",
        "output": "struct Solution;\n\nimpl Solution {\n    fn eval_rpn(tokens: Vec<String>) -> i32 {\n        let mut stack = vec![];\n        for tok in tokens {\n            match tok.as_ref() {\n                \"+\" => {\n                    let right = stack.pop().unwrap();\n                    let left = stack.pop().unwrap();\n                    stack.push(left + right);\n                }\n                \"-\" => {\n                    let right = stack.pop().unwrap();\n                    let left = stack.pop().unwrap();\n                    stack.push(left - right);\n                }\n                \"*\" => {\n                    let right = stack.pop().unwrap();\n                    let left = stack.pop().unwrap();\n                    stack.push(left * right);\n                }\n                \"/\" => {\n                    let right = stack.pop().unwrap();\n                    let left = stack.pop().unwrap();\n                    stack.push(left / right);\n                }\n                _ => {\n                    stack.push(tok.parse::<i32>().unwrap());\n                }\n            }\n        }\n        stack[0]\n    }\n}\n\n#[test]\nfn test() {\n    let tokens = vec_string![\"2\", \"1\", \"+\", \"3\", \"*\"];\n    let res = 9;\n    assert_eq!(Solution::eval_rpn(tokens), res);\n    let tokens = vec_string![\"4\", \"13\", \"5\", \"/\", \"+\"];\n    let res = 6;\n    assert_eq!(Solution::eval_rpn(tokens), res);\n    let tokens = vec_string![\"10\", \"6\", \"9\", \"3\", \"+\", \"-11\", \"*\", \"/\", \"*\", \"17\", \"+\", \"5\", \"+\"];\n    let res = 22;\n    assert_eq!(Solution::eval_rpn(tokens), res);\n}\n"
    },
    {
        "input": "\n\n\n\n\n\nclass Solution(object):\n    def reorderList(self, head):\n        \n        if not head:\n        \treturn None\n\n        slow, fast = head, head.next\n\n        while fast and fast.next:\n        \tslow = slow.next\n        \tfast = fast.next.next\n\n        head1, head2 = head, slow.next\n        slow.next = None\n        prev = None\n        curr = head2\n        while curr:\n        \tnex = curr.next\n        \tcurr.next = prev\n        \tprev  = curr\n        \tcurr = nex\n        head2 = prev\n\n        while head2:\n        \tn1 = head1.next\n        \tn2 = head2.next\n        \thead1.next = head2\n        \thead1.next.next = n1\n        \thead2 = n2\n        \thead1 = head1.next.next\n\n        head = head1\n",
        "output": "struct Solution;\nuse rustgym_util::*;\nuse std::collections::VecDeque;\n\nimpl Solution {\n    fn reorder_list(head: &mut ListLink) {\n        let mut p: ListLink = head.take();\n        let mut deque: VecDeque<ListLink> = VecDeque::new();\n        while let Some(mut n) = p {\n            p = n.next.take();\n            deque.push_back(Some(n));\n        }\n        let mut stack: Vec<ListLink> = vec![];\n        let mut direction = true;\n        while !deque.is_empty() {\n            if direction {\n                stack.push(deque.pop_front().unwrap());\n            } else {\n                stack.push(deque.pop_back().unwrap())\n            }\n            direction = !direction;\n        }\n        let mut prev: ListLink = None;\n        while let Some(last) = stack.pop() {\n            let mut node = last.unwrap();\n            node.next = prev;\n            prev = Some(node);\n        }\n        *head = prev\n    }\n}\n\n#[test]\nfn test() {\n    let mut head = list!(1, 2, 3, 4, 5);\n    Solution::reorder_list(&mut head);\n    let res = list!(1, 5, 2, 4, 3);\n    assert_eq!(head, res);\n}\n"
    },
    {
        "input": "\n\nclass Solution(object):\n    def findMin(self, nums):\n        \n        if not nums:\n        \treturn 0\n\n        if len(nums) == 1:\n        \treturn nums[0]\n        left, right = 0, len(nums)-1\n\n        if nums[left] < nums[right]:\n        \treturn nums[left]\n        while left <= right:\n        \twhile nums[left] == nums[right] and left != right:\n        \t\tleft += 1\n        \t\t\n        \tif nums[left] <= nums[right]:\n        \t\treturn nums[left]\n\n        \tmid = (left + right)/2\n        \tif nums[mid] >= nums[left]:\n        \t\tleft = mid+1\n        \telse:\n        \t\tright = mid\n        return -1",
        "output": "struct Solution;\n\nimpl Solution {\n    fn find_min(nums: Vec<i32>) -> i32 {\n        let mut l = 0;\n        let mut h = nums.len() - 1;\n        while l < h {\n            if nums[l] < nums[h] {\n                return nums[l];\n            }\n            let m = l + (h - l) / 2;\n            if nums[l] <= nums[m] {\n                l = m + 1;\n            } else {\n                h = m;\n            }\n        }\n        nums[l]\n    }\n}\n\n#[test]\nfn test() {\n    let nums = vec![3, 4, 5, 1, 2];\n    let res = 1;\n    assert_eq!(Solution::find_min(nums), res);\n    let nums = vec![4, 5, 6, 7, 0, 1, 2];\n    let res = 0;\n    assert_eq!(Solution::find_min(nums), res);\n}\n"
    },
    {
        "input": "\n\n\n\n\n\n\n\n\n\nclass Solution(object):\n    def hasPathSum(self, root, sum):\n        \n        if not root:\n        \treturn False\n\n        if not root.left and not root.right and root.val == sum:\n        \treturn True\n\n        return self.hasPathSum(root.left, sum-root.val) or self.hasPathSum(root.right, sum-root.val)",
        "output": "struct Solution;\nuse rustgym_util::*;\n\ntrait PathSum {\n    fn has_path_sum(&self, sum: i32) -> bool;\n}\n\nimpl PathSum for TreeLink {\n    fn has_path_sum(&self, sum: i32) -> bool {\n        if let Some(node) = self {\n            let node = node.borrow();\n            let val = node.val;\n            let left = &node.left;\n            let right = &node.right;\n            if left.is_none() && right.is_none() {\n                sum == val\n            } else {\n                right.has_path_sum(sum - val) || left.has_path_sum(sum - val)\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl Solution {\n    fn has_path_sum(root: TreeLink, sum: i32) -> bool {\n        root.has_path_sum(sum)\n    }\n}\n\n#[test]\nfn test() {\n    let root = tree!(\n        5,\n        tree!(4, tree!(11, tree!(7), tree!(2)), None),\n        tree!(8, tree!(13), tree!(4, None, tree!(1)))\n    );\n    let sum = 22;\n    let res = true;\n    assert_eq!(Solution::has_path_sum(root, sum), res);\n    let root = tree!(1, tree!(2), None);\n    let sum = 1;\n    let res = false;\n    assert_eq!(Solution::has_path_sum(root, sum), res);\n}\n"
    },
    {
        "input": "\n\n\n\n\n\n\n\n\nclass Solution(object):\n    def sortedArrayToBST(self, nums):\n        \n\n        def constructTree(nums, start, end):\n        \tif start > end:\n        \t\treturn None\n\n        \tmid = (start+end)/2\n        \tnode = TreeNode(nums[mid])\n\n        \tif start == end:\n        \t\treturn node\n\n        \tnode.left = constructTree(nums, start, mid-1)\n        \tnode.right = constructTree(nums, mid+1, end)\n        \treturn node\n\n        return constructTree(nums, 0, len(nums)-1)",
        "output": "struct Solution;\nuse rustgym_util::*;\n\nimpl Solution {\n    fn sorted_array_to_bst(nums: Vec<i32>) -> TreeLink {\n        let n = nums.len();\n        match n {\n            0 => None,\n            1 => tree!(nums[0]),\n            _ => {\n                let mid = n / 2;\n                let left = nums[..mid].to_vec();\n                let right = nums[mid + 1..].to_vec();\n                tree!(\n                    nums[mid],\n                    Self::sorted_array_to_bst(left),\n                    Self::sorted_array_to_bst(right)\n                )\n            }\n        }\n    }\n}\n\n#[test]\nfn test() {\n    let nums = vec![-10, -3, 0, 5, 9];\n    let bst = tree!(0, tree!(-3, tree!(-10), None), tree!(9, tree!(5), None));\n    assert_eq!(Solution::sorted_array_to_bst(nums), bst);\n}\n"
    },
    {
        "input": "\n\nclass Solution(object):\n    def minimumTotal(self, triangle):\n        \n        length = len(triangle)\n        columns = len(triangle[length-1])\n        \n        matrix = [[ 0 for col in range(columns)] for row in range(length)]\n        row_index = 0\n        \n        for row in range(length):\n            elements = triangle[row]\n            col_index = 0\n            \n            for val in elements:\n                matrix[row_index][col_index] = val\n                col_index += 1\n            row_index += 1\n            \n        for row in range(length-2, -1, -1):\n            for col in range(row+1):\n                matrix[row][col] += min(matrix[row+1][col+1], matrix[row+1][col])\n        return matrix[0][0]",
        "output": "struct Solution;\n\nimpl Solution {\n    fn minimum_total(triangle: Vec<Vec<i32>>) -> i32 {\n        let n = triangle.len();\n        let mut dp = vec![vec![0; n + 1]; 2];\n        for i in (0..n).rev() {\n            for j in 0..=i {\n                dp[i % 2][j] = triangle[i][j] + dp[(i + 1) % 2][j].min(dp[(i + 1) % 2][j + 1]);\n            }\n        }\n        dp[0][0]\n    }\n}\n\n#[test]\nfn test() {\n    let triangle = vec_vec_i32![[2], [3, 4], [6, 5, 7], [4, 1, 8, 3]];\n    let res = 11;\n    assert_eq!(Solution::minimum_total(triangle), res);\n}\n"
    },
    {
        "input": "\n\n\n\n\n\n\n\nclass Solution(object):\n    def sortList(self, head):\n        \n\n        if not head or not head.next:\n        \treturn head\n\n        slow, fast = head, head.next\n\n        while fast.next and fast.next.next:\n        \tslow = slow.next\n        \tfast = fast.next.next\n\n        head1, head2 = head, slow.next\n        slow.next = None\n        head1 = self.sortList(head1)\n        head2 = self.sortList(head2)\n        head = self.merge(head1, head2)\n        return head\n\n    def merge(self, head1, head2):\n    \tif not head1:\n    \t\treturn head2\n    \tif not head2:\n    \t\treturn head1\n\n    \tresult = ListNode(0)\n    \tp = result\n\n    \twhile head1 and head2:\n    \t\tif head1.val <= head2.val:\n    \t\t\tp.next = ListNode(head1.val)\n    \t\t\thead1 = head1.next\n    \t\t\tp = p.next\n    \t\telse:\n    \t\t\tp.next = ListNode(head2.val)\n    \t\t\thead2 = head2.next\n    \t\t\tp = p.next\n\n    \tif head1:\n    \t\tp.next = head1\n    \tif head2:\n    \t\tp.next = head2\n    \treturn result.next",
        "output": "struct Solution;\nuse rustgym_util::*;\n\nimpl Solution {\n    fn sort_list(head: ListLink) -> ListLink {\n        let mut cur = head;\n        let mut v: Vec<i32> = vec![];\n        while let Some(node) = cur {\n            v.push(node.val);\n            cur = node.next;\n        }\n        v.sort_unstable();\n        let mut prev = None;\n        while let Some(last) = v.pop() {\n            prev = ListLink::link(last, prev);\n        }\n        prev\n    }\n}\n\n#[test]\nfn test() {\n    let head = list![4, 2, 1, 3];\n    let res = list![1, 2, 3, 4];\n    assert_eq!(Solution::sort_list(head), res);\n}\n"
    },
    {
        "input": "\n\n\n\n\n\n\n\n\nclass Solution(object):\n    def preorderTraversal(self, root):\n        \n        if not root:\n        \treturn []\n\n        stack, result = [root], []\n        while stack:\n        \telement = stack.pop()\n        \tresult.append(element.val)\n\n        \tif element.right:\n        \t\tstack.append(element.right)\n        \tif element.left:\n        \t\tstack.append(element.left)\n\n        return result\n\n\n\n\n\n\n\n\n\nclass Solution(object):\n    def preorderTraversal(self, root):\n        \n        result = []\n\n        def recursive(root, result):\n        \tif not root:\n        \t\treturn \n        \tresult.append(root.val)\n        \trecursive(root.left, result)\n        \trecursive(root.right, result)\n\n        recursive(root, result)\n        return result",
        "output": "struct Solution;\n\ntrait Preorder {\n    fn preorder(&self, all: &mut Vec<i32>);\n}\n\nimpl Preorder for TreeLink {\n    fn preorder(&self, all: &mut Vec<i32>) {\n        if let Some(node) = self {\n            let node = node.borrow();\n            all.push(node.val);\n            node.left.preorder(all);\n            node.right.preorder(all);\n        }\n    }\n}\n\nimpl Solution {\n    fn preorder_traversal(root: TreeLink) -> Vec<i32> {\n        let mut res = vec![];\n        root.preorder(&mut res);\n        res\n    }\n}\n\n#[test]\nfn test() {\n    let root = tree!(1, None, tree!(2, tree!(3), None));\n    let res = vec![1, 2, 3];\n    assert_eq!(Solution::preorder_traversal(root), res);\n}\n"
    },
    {
        "input": "class Solution:\n    \n    \n    def reverseBits(self, n):\n        res = 0\n        for i in range(32):\n            res += n & 1\n            n = n >> 1\n            if i != 31:\n                res = res << 1\n        return res\n        \nprint Solution().reverseBits(12)",
        "output": "struct Solution;\n\nimpl Solution {\n    fn reverse_bits(x: u32) -> u32 {\n        let mut res = 0;\n        for i in 0..32 {\n            let bit = x & 1 << i;\n            let travel = (31 - i as i32) - i as i32;\n            if travel > 0 {\n                res |= bit << travel;\n            } else {\n                res |= bit >> -travel;\n            }\n        }\n        res\n    }\n}\n\n#[test]\nfn test() {\n    let n = 0b00000010100101000001111010011100;\n    let res = 964176192;\n    assert_eq!(Solution::reverse_bits(n), res);\n    let n = 0b11111111111111111111111111111101;\n    let res = 3221225471;\n    assert_eq!(Solution::reverse_bits(n), res);\n}\n"
    },
    {
        "input": "\n\n\n\n\n\n\n\n\nclass Solution(object):\n    def isSymmetric(self, root):\n        \n        if not root:\n        \treturn True\n\n        def dfs(left, right):\n        \tif not left and not right:\n        \t\treturn True\n\n        \tif not left or not right:\n        \t\treturn False\n        \treturn (left.val == right.val) and dfs(left.left, right.right) and dfs(left.right, right.left)\n\n        return dfs(root, root)",
        "output": "struct Solution;\nuse rustgym_util::*;\n\ntrait Symmetric {\n    fn is_symmetric(&self) -> bool;\n    fn is_mirror(&self, right: &TreeLink) -> bool;\n}\n\nimpl Symmetric for TreeLink {\n    fn is_symmetric(&self) -> bool {\n        if let Some(node) = self {\n            let node = node.borrow();\n            node.left.is_mirror(&node.right)\n        } else {\n            true\n        }\n    }\n\n    fn is_mirror(&self, right: &TreeLink) -> bool {\n        match (self, right) {\n            (Some(p), Some(q)) => {\n                let p = p.borrow();\n                let q = q.borrow();\n                p.val == q.val && p.left.is_mirror(&q.right) && p.right.is_mirror(&q.left)\n            }\n            (None, None) => true,\n            _ => false,\n        }\n    }\n}\n\nimpl Solution {\n    fn is_symmetric(root: TreeLink) -> bool {\n        root.is_symmetric()\n    }\n}\n\n#[test]\nfn test() {\n    let q = tree!(\n        1,\n        tree!(2, tree!(1), tree!(1)),\n        tree!(2, tree!(1), tree!(1))\n    );\n    let res = true;\n    assert_eq!(Solution::is_symmetric(q), res);\n}\n"
    },
    {
        "input": "\n\n\n\n\n\n\n\n\nclass Solution(object):\n    def rightSideView(self, root):\n        \n        if not root:\n        \treturn []\n\n        stack, node_depth = [(root, 0)], {}\n\n        while stack:\n        \tnode, depth = stack.pop(0)\n        \tif depth not in node_depth:\n        \t\tnode_depth[depth] = node.val\n\n        \tif node.right:\n        \t\tstack.append((node.right, depth+1))\n        \tif node.left:\n        \t\tstack.append((node.left, depth+1))\n        return node_depth.values()",
        "output": "struct Solution;\nuse rustgym_util::*;\n\ntrait Preorder {\n    fn preorder(&self, level: usize, view: &mut Vec<i32>);\n}\n\nimpl Preorder for TreeLink {\n    fn preorder(&self, level: usize, view: &mut Vec<i32>) {\n        if let Some(node) = self {\n            let node = node.borrow();\n            let val = node.val;\n            if level == view.len() {\n                view.push(val);\n            } else {\n                view[level] = val;\n            }\n            node.left.preorder(level + 1, view);\n            node.right.preorder(level + 1, view);\n        }\n    }\n}\n\nimpl Solution {\n    fn right_side_view(root: TreeLink) -> Vec<i32> {\n        let mut res: Vec<i32> = vec![];\n        root.preorder(0, &mut res);\n        res\n    }\n}\n\n#[test]\nfn test() {\n    let root = tree!(1, tree!(2, None, tree!(5)), tree!(3, None, tree!(4)));\n    let res = vec![1, 3, 4];\n    assert_eq!(Solution::right_side_view(root), res);\n}\n"
    },
    {
        "input": "class Solution(object):\n    def hammingWeight(self, n):\n        \n        bits = 0\n        mask = 1\n\n        for i in range(32):\n        \tif (n&mask) != 0:\n        \t\tbits +=1\n        \tmask <<= 1\n\n        return bits",
        "output": "#![allow(clippy::unreadable_literal)]\nstruct Solution;\n\nimpl Solution {\n    #[allow(non_snake_case)]\n    fn hammingWeight(n: u32) -> i32 {\n        n.count_ones() as i32\n    }\n}\n\n#[test]\nfn test() {\n    let n = 0b00000000000000000000000000001011;\n    let res = 3;\n    assert_eq!(Solution::hammingWeight(n), res);\n    let n = 0b00000000000000000000000010000000;\n    let res = 1;\n    assert_eq!(Solution::hammingWeight(n), res);\n    let n = 0b11111111111111111111111111111101;\n    let res = 31;\n    assert_eq!(Solution::hammingWeight(n), res);\n}\n"
    },
    {
        "input": "\n\nclass Solution(object):\n    def minCut(self, s):\n        \n        if not s:\n        \treturn 0\n\n        P = [[False for _ in range(len(s))] for _  in range(len(s))]\n        cuts = [0 for _ in range(len(s))]\n\n        for index in range(len(s)):\n        \tP[index][index] = True\n\n        for length in range(2, len(s)+1):\n        \tfor i in range(len(s)-length+1):\n        \t\tj = i+length - 1\n\n        \t\tif length == 2:\n        \t\t\tP[i][j] = s[i] == s[j]\n        \t\telse:\n        \t\t\tP[i][j] = (s[i] ==  s[j]) and P[i+1][j-1]\n\n        for index in range(len(s)):\n        \tif P[0][index]:\n        \t\tcuts[index] = 0\n        \telse:\n        \t\tcuts[index] = float('inf')\n        \t\tfor j in range(index):\n        \t\t\tif P[j+1][index] and (cuts[index] > 1 + cuts[j]):\n        \t\t\t\tcuts[index] = 1+cuts[j]\n\n        return cuts[len(s)-1]\n\n\n",
        "output": "struct Solution;\n\nuse std::collections::HashMap;\n\nimpl Solution {\n    fn min_cut(s: String) -> i32 {\n        let n = s.len();\n        let s: Vec<char> = s.chars().collect();\n        let mut memo: HashMap<(usize, usize), i32> = HashMap::new();\n        Self::dp(0, n, &mut memo, &s)\n    }\n\n    fn dp(start: usize, end: usize, memo: &mut HashMap<(usize, usize), i32>, s: &[char]) -> i32 {\n        if let Some(&res) = memo.get(&(start, end)) {\n            return res;\n        }\n        let res = if Self::is_palindrome(start, end, s) {\n            0\n        } else {\n            let mut res = std::i32::MAX;\n            for i in start + 1..end {\n                if Self::is_palindrome(start, i, s) {\n                    res = res.min(1 + Self::dp(i, end, memo, s));\n                }\n            }\n            res\n        };\n        memo.insert((start, end), res);\n        res\n    }\n\n    fn is_palindrome(start: usize, end: usize, s: &[char]) -> bool {\n        !s[start..end]\n            .iter()\n            .zip(s[start..end].iter().rev())\n            .any(|(a, b)| a != b)\n    }\n}\n\n#[test]\nfn test() {\n    let s = \"aab\".to_string();\n    let res = 1;\n    assert_eq!(Solution::min_cut(s), res);\n    let s = \"coder\".to_string();\n    let res = 4;\n    assert_eq!(Solution::min_cut(s), res);\n}\n"
    },
    {
        "input": "\n\n\n\n\n\n\n\n\nclass Solution(object):\n    def levelOrder(self, root):\n        \n\n        if not root:\n        \treturn []\n\n        queue = [(root, 0)]\n        levelMap = {}\n\n        while queue:\n        \tnode, level = queue.pop(0)\n        \tif node.left:\n        \t\tqueue.append((node.left, level+1))\n        \tif node.right:\n        \t\tqueue.append((node.right, level+1))\n\n        \tif level in levelMap:\n        \t\tlevelMap[level].append(node.val)\n        \telse:\n        \t\tlevelMap[level] = [node.val]\n\n        result = []\n        for key, value in levelMap.iteritems():\n        \tresult.append(value)\n        return result",
        "output": "struct Solution;\nuse rustgym_util::*;\n\ntrait Preorder {\n    fn preorder(&self, levels: &mut Vec<Vec<i32>>, level: usize);\n}\n\nimpl Preorder for TreeLink {\n    fn preorder(&self, levels: &mut Vec<Vec<i32>>, level: usize) {\n        if let Some(node) = self {\n            let val = node.borrow().val;\n            if levels.len() == level {\n                levels.push(vec![val]);\n            } else {\n                levels[level].push(val);\n            }\n            node.borrow().left.preorder(levels, level + 1);\n            node.borrow().right.preorder(levels, level + 1);\n        }\n    }\n}\n\nimpl Solution {\n    fn level_order(root: TreeLink) -> Vec<Vec<i32>> {\n        let mut res = vec![];\n        root.preorder(&mut res, 0);\n        res\n    }\n}\n\n#[test]\nfn test() {\n    let root = tree!(3, tree!(9), tree!(20, tree!(15), tree!(7)));\n    let res: Vec<Vec<i32>> = vec_vec_i32![[3], [9, 20], [15, 7]];\n    assert_eq!(Solution::level_order(root), res);\n}\n"
    },
    {
        "input": "\n\n\n\n\n\n\n\n\nclass Solution(object):\n    def maxPathSum(self, root):\n        \n        self.result = float('-inf')\n        self.dfs(root)\n        return self.result\n\n    def dfs(self, root):\n    \tif not root:\n    \t\treturn 0\n\n    \tl = self.dfs(root.left)\n    \tr = self.dfs(root.right)\n\n    \tmax_one_end = max(max(l, r)+root.val, root.val)\n    \tmax_path = max(max_one_end, l+r+root.val)\n    \tself.result = max(self.result, max_path)\n    \treturn max_one_end\n\n\n",
        "output": "struct Solution;\nuse rustgym_util::*;\n\ntrait Postorder {\n    fn postorder(&self, max: &mut i32) -> Option<i32>;\n}\n\nimpl Postorder for TreeLink {\n    fn postorder(&self, max: &mut i32) -> Option<i32> {\n        if let Some(node) = self {\n            let node = node.borrow();\n            let val = node.val;\n            let left = &node.left;\n            let right = &node.right;\n            let left_max = left.postorder(max);\n            let right_max = right.postorder(max);\n            match (left_max, right_max) {\n                (Some(left_max), Some(right_max)) => {\n                    *max = (*max).max(val);\n                    *max = (*max).max(val + left_max);\n                    *max = (*max).max(val + right_max);\n                    *max = (*max).max(val + left_max + right_max);\n                    Some(val + 0.max(left_max.max(right_max)))\n                }\n                (Some(left_max), None) => {\n                    *max = (*max).max(val);\n                    *max = (*max).max(val + left_max);\n                    Some(val + 0.max(left_max))\n                }\n                (None, Some(right_max)) => {\n                    *max = (*max).max(val);\n                    *max = (*max).max(val + right_max);\n                    Some(val + 0.max(right_max))\n                }\n                (None, None) => {\n                    *max = (*max).max(val);\n                    Some(val)\n                }\n            }\n        } else {\n            None\n        }\n    }\n}\n\nimpl Solution {\n    fn max_path_sum(root: TreeLink) -> i32 {\n        let mut res: i32 = std::i32::MIN;\n        root.postorder(&mut res);\n        res as i32\n    }\n}\n\n#[test]\nfn test() {\n    let root = tree!(1, tree!(2), tree!(3));\n    let res = 6;\n    assert_eq!(Solution::max_path_sum(root), res);\n    let root = tree!(-10, tree!(9), tree!(20, tree!(15), tree!(7)));\n    let res = 42;\n    assert_eq!(Solution::max_path_sum(root), res);\n}\n"
    },
    {
        "input": "\n\nclass Solution(object):\n    def nextClosestTime(self, time):\n    \tcurrent_time = 60*int(time[:2]) + int(time[3:])\n    \tallowed = {int(x) for x in time if x != ':'}\n    \tresult = 24*60\n    \tans = current_time\n    \tfor h1, h2, m1, m2 in itertools.product(allowed, repeat=4):\n    \t\thours, minutes = 10*h1+h2, 10*m1+m2\n    \t\tif hours < 24 and minutes < 60:\n    \t\t\telapsed = 60*hours + minutes\n    \t\t\tdiff = (current_time - elapsed)%(24*60)\n    \t\t\tif 0 < diff < result:\n    \t\t\t\tresult = diff\n    \t\t\t\tans = elapsed\n\n    \treturn \"{:02d}:{:02d}\".format(divmod(ans, 60))\n",
        "output": "struct Solution;\n\nimpl Solution {\n    fn next_closest_time(time: String) -> String {\n        let h = time[..2].parse::<usize>().unwrap();\n        let m = time[3..].parse::<usize>().unwrap();\n        let a = h / 10;\n        let b = h % 10;\n        let c = m / 10;\n        let d = m % 10;\n        let set = 1 << a | 1 << b | 1 << c | 1 << d;\n        let mut found = false;\n        for _ in 0..2 {\n            for i in 0..24 {\n                for j in 0..60 {\n                    if !found {\n                        if i == h && j == m {\n                            found = true;\n                        }\n                    } else {\n                        let a = i / 10;\n                        let b = i % 10;\n                        let c = j / 10;\n                        let d = j % 10;\n                        let next_set = 1 << a | 1 << b | 1 << c | 1 << d;\n                        if (next_set | set) == set {\n                            return format!(\"{}{}:{}{}\", a, b, c, d);\n                        }\n                    }\n                }\n            }\n        }\n        \"\".to_string()\n    }\n}\n\n#[test]\nfn test() {\n    let time = \"19:34\".to_string();\n    let res = \"19:39\".to_string();\n    assert_eq!(Solution::next_closest_time(time), res);\n    let time = \"23:59\".to_string();\n    let res = \"22:22\".to_string();\n    assert_eq!(Solution::next_closest_time(time), res);\n}\n"
    },
    {
        "input": "\n\nclass Solution(object):\n    def findNumberOfLIS(self, nums):\n        length = [1]*len(nums)\n        count = [1]*len(nums)\n        result = 0\n        for end, num in enumerate(nums):\n            for start in range(end):\n                if num > nums[start]:\n                    if length[start] >= length[end]:\n                        length[end] = 1+length[start]\n                        count[end] = count[start]\n                    elif length[start] + 1 == length[end]:\n                        count[end] += count[start]\n        for index, max_subs in enumerate(count):\n            if length[index] == max(length):\n                result += max_subs\n        return result\n",
        "output": "struct Solution;\n\nimpl Solution {\n    fn find_number_of_lis(nums: Vec<i32>) -> i32 {\n        let n = nums.len();\n        let mut len: Vec<usize> = vec![1; n];\n        let mut cnt: Vec<usize> = vec![1; n];\n        for i in 0..n {\n            for j in 0..i {\n                if nums[j] < nums[i] {\n                    if len[j] + 1 == len[i] {\n                        cnt[i] += cnt[j];\n                    }\n                    if len[j] == len[i] {\n                        len[i] += 1;\n                        cnt[i] = cnt[j];\n                    }\n                }\n            }\n        }\n        let max_len = *len.iter().max().unwrap();\n        let mut res = 0;\n        for i in 0..n {\n            if len[i] == max_len {\n                res += cnt[i];\n            }\n        }\n        res as i32\n    }\n}\n\n#[test]\nfn test() {\n    let nums = vec![1, 3, 5, 4, 7];\n    let res = 2;\n    assert_eq!(Solution::find_number_of_lis(nums), res);\n    let nums = vec![2, 2, 2, 2, 2];\n    let res = 5;\n    assert_eq!(Solution::find_number_of_lis(nums), res);\n}\n"
    },
    {
        "input": "\n\nclass Solution(object):\n    def findLengthOfLCIS(self, nums):\n        \n        if not nums:\n            return 0\n        start, result = 0, 1\n        for end in range(1, len(nums)):\n            if nums[end-1] >= nums[end]:\n                start = end\n            result = max(result, end-start+1)\n        return result\n",
        "output": "struct Solution;\n\nimpl Solution {\n    fn find_length_of_lcis(nums: Vec<i32>) -> i32 {\n        let n = nums.len();\n        if n == 0 {\n            return 0;\n        }\n        let mut i: usize = 0;\n        let mut j: usize = i;\n        let mut res: usize = 1;\n        while i < n {\n            while j + 1 < n && nums[j + 1] > nums[j] {\n                j += 1;\n            }\n            res = usize::max(j - i + 1, res);\n            i = j + 1;\n            j = i;\n        }\n        res as i32\n    }\n}\n\n#[test]\nfn test() {\n    let nums = vec![1, 3, 5, 4, 7];\n    assert_eq!(Solution::find_length_of_lcis(nums), 3);\n    let nums = vec![2, 2, 2, 2, 2];\n    assert_eq!(Solution::find_length_of_lcis(nums), 1);\n}\n"
    },
    {
        "input": "\nclass Solution(object):\n    def smallestDivisor(self, nums, threshold):\n        \n        def getSum(divisor, xs):\n            return sum([x // divisor + 1 if x % divisor else x // divisor for x in xs])\n\t\t\n        left, right = 1, 10 ** 6\n        while left + 1 < right:\n            mid = (left + right) // 2            \n            if getSum(mid, nums) > threshold: \n                left = mid\n            else: \n                right = mid\n        \n        return left if getSum(left, nums) <= threshold else right\n",
        "output": "struct Solution;\n\nimpl Solution {\n    fn smallest_divisor(nums: Vec<i32>, threshold: i32) -> i32 {\n        let mut l = 1;\n        let mut r = 1_000_000;\n        while l < r {\n            let m = l + (r - l) / 2;\n            let mut sum = 0;\n            for &x in &nums {\n                if x % m == 0 {\n                    sum += x / m;\n                } else {\n                    sum += x / m + 1;\n                }\n            }\n            if sum > threshold {\n                l = m + 1;\n            } else {\n                r = m;\n            }\n        }\n        l\n    }\n}\n\n#[test]\nfn test() {\n    let nums = vec![1, 2, 5, 9];\n    let threshold = 6;\n    let res = 5;\n    assert_eq!(Solution::smallest_divisor(nums, threshold), res);\n    let nums = vec![2, 3, 5, 7, 11];\n    let threshold = 11;\n    let res = 3;\n    assert_eq!(Solution::smallest_divisor(nums, threshold), res);\n    let nums = vec![19];\n    let threshold = 5;\n    let res = 4;\n    assert_eq!(Solution::smallest_divisor(nums, threshold), res);\n}\n"
    },
    {
        "input": "\n\nclass Solution(object):\n    def minTimeToVisitAllPoints(self, points):\n        \n        if not points:\n            return 0\n        result = 0\n        for index in range(1, len(points)):\n            result += max(abs(points[index][0]-points[index-1][0]), abs(points[index][1]-points[index-1][1]))\n        return result\n",
        "output": "struct Solution;\n\nimpl Solution {\n    fn min_time_to_visit_all_points(points: Vec<Vec<i32>>) -> i32 {\n        let mut res = 0;\n        let n = points.len();\n        for i in 1..n {\n            let x1 = points[i - 1][0];\n            let y1 = points[i - 1][1];\n            let x2 = points[i][0];\n            let y2 = points[i][1];\n            res += i32::max((x2 - x1).abs(), (y2 - y1).abs());\n        }\n        res\n    }\n}\n\n#[test]\nfn test() {\n    let points = vec_vec_i32![[1, 1], [3, 4], [-1, 0]];\n    let res = 7;\n    assert_eq!(Solution::min_time_to_visit_all_points(points), res);\n}\n"
    },
    {
        "input": "\n\nclass Solution(object):\n    def countServers(self, grid):\n        \n        if not grid:\n            return 0\n        \n        row_count = [0] * len(grid)\n        col_count = [0] * len(grid[0])\n        for index_r in range(len(grid)):\n            for index_c in range(len(grid[0])):\n                if grid[index_r][index_c] == 1:\n                    row_count[index_r] += 1\n                    col_count[index_c] += 1\n                    \n        result = 0\n        for index_r in range(len(grid)):\n            for index_c in range(len(grid[0])):\n                if grid[index_r][index_c] == 1 and (row_count[index_r] > 1 or col_count[index_c] > 1):\n                    result += 1\n        return result\n",
        "output": "struct Solution;\n\nimpl Solution {\n    fn count_servers(grid: Vec<Vec<i32>>) -> i32 {\n        let n = grid.len();\n        let m = grid[0].len();\n        let mut rows = vec![0; n];\n        let mut cols = vec![0; m];\n        for i in 0..n {\n            for j in 0..m {\n                if grid[i][j] == 1 {\n                    rows[i] += 1;\n                    cols[j] += 1;\n                }\n            }\n        }\n        let mut res = 0;\n        for i in 0..n {\n            for j in 0..m {\n                if grid[i][j] == 1 && (rows[i] > 1 || cols[j] > 1) {\n                    res += 1;\n                }\n            }\n        }\n        res\n    }\n}\n\n#[test]\nfn test() {\n    let grid = vec_vec_i32![[1, 0], [0, 1]];\n    let res = 0;\n    assert_eq!(Solution::count_servers(grid), res);\n    let grid = vec_vec_i32![[1, 0], [1, 1]];\n    let res = 3;\n    assert_eq!(Solution::count_servers(grid), res);\n    let grid = vec_vec_i32![[1, 1, 0, 0], [0, 0, 1, 0], [0, 0, 1, 0], [0, 0, 0, 1]];\n    let res = 4;\n    assert_eq!(Solution::count_servers(grid), res);\n}\n"
    },
    {
        "input": "\n\n\n\n\n\n\n\nclass Solution(object):\n    def getDecimalValue(self, head):\n        \n        result = ''\n        if not head:\n            return 0\n        while head:\n            result+= str(head.val)\n            head = head.next\n        return int(result, 2)\n",
        "output": "struct Solution;\nuse rustgym_util::*;\n\nimpl Solution {\n    fn get_decimal_value(head: ListLink) -> i32 {\n        let mut p: &ListLink = &head;\n        let mut res = 0;\n        while let Some(n) = p {\n            res *= 2;\n            res += n.val;\n            p = &n.next;\n        }\n        res\n    }\n}\n\n#[test]\nfn test() {\n    let head = list!(1, 0, 1);\n    assert_eq!(Solution::get_decimal_value(head), 5);\n}\n"
    },
    {
        "input": "\nclass TrieNode(object):\n    def __init__(self):\n        self.words = []\n        self.children = {}\n        \nclass Trie(object):\n    def __init__(self):\n        self.root = TrieNode()\n        \n    def insert(self, word):\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                node.children[char] = TrieNode()\n            node = node.children[char]\n            node.words.append(word)\n            node.words.sort()\n            if len(node.words) > 3:\n                node.words = node.words[:3]\n                \n    def search(self, word):\n        result, node = [], self.root\n        for char in word:\n            if char not in node.children:\n                break\n            node = node.children[char]\n            result.append(node.words[:])\n        for _ in range(len(word) - len(result)):\n            result.append([])\n        return result\n            \nclass Solution(object):\n    def suggestedProducts(self, products, searchWord):\n        \n        trie = Trie()\n        for product in products:\n            trie.insert(product)\n        return trie.search(searchWord)\n",
        "output": "struct Solution;\nuse std::usize;\n\nimpl Solution {\n    fn suggested_products(mut products: Vec<String>, search_word: String) -> Vec<Vec<String>> {\n        let mut res = vec![];\n        products.sort_unstable();\n        let n = products.len();\n        let mut prefix = \"\".to_string();\n        let mut start = 0;\n        for c in search_word.chars() {\n            prefix.push(c);\n            start = start\n                + products[start..]\n                    .binary_search(&prefix)\n                    .unwrap_or_else(|p| p);\n            let mut list: Vec<String> = vec![];\n            let end = usize::min(start + 3, n);\n            for i in start..end {\n                if products[i].starts_with(&prefix) {\n                    list.push(products[i].clone());\n                }\n            }\n            res.push(list);\n        }\n        res\n    }\n}\n\n#[test]\nfn test() {\n    let products = vec_string![\"mobile\", \"mouse\", \"moneypot\", \"monitor\", \"mousepad\"];\n    let search_word = \"mouse\".to_string();\n    let res: Vec<Vec<String>> = vec_vec_string![\n        [\"mobile\", \"moneypot\", \"monitor\"],\n        [\"mobile\", \"moneypot\", \"monitor\"],\n        [\"mouse\", \"mousepad\"],\n        [\"mouse\", \"mousepad\"],\n        [\"mouse\", \"mousepad\"]\n    ];\n    assert_eq!(Solution::suggested_products(products, search_word), res);\n    let products = vec_string![\"havana\"];\n    let search_word = \"havana\".to_string();\n    let res: Vec<Vec<String>> = vec_vec_string![\n        [\"havana\"],\n        [\"havana\"],\n        [\"havana\"],\n        [\"havana\"],\n        [\"havana\"],\n        [\"havana\"]\n    ];\n    assert_eq!(Solution::suggested_products(products, search_word), res);\n    let products = vec_string![\"bags\", \"baggage\", \"banner\", \"box\", \"cloths\"];\n    let search_word = \"bags\".to_string();\n    let res: Vec<Vec<String>> = vec_vec_string![\n        [\"baggage\", \"bags\", \"banner\"],\n        [\"baggage\", \"bags\", \"banner\"],\n        [\"baggage\", \"bags\"],\n        [\"bags\"]\n    ];\n    assert_eq!(Solution::suggested_products(products, search_word), res);\n    let products = vec_string![\"havana\"];\n    let search_word = \"tatiana\".to_string();\n    let res: Vec<Vec<String>> = vec_vec_string![[], [], [], [], [], [], []];\n    assert_eq!(Solution::suggested_products(products, search_word), res);\n}\n"
    },
    {
        "input": "\nclass Solution(object):\n    def numOfBurgers(self, tomatoSlices, cheeseSlices):\n        \n        jumbo = tomatoSlices - 2*cheeseSlices\n        if jumbo >= 0 and jumbo%2 == 0:\n            x = jumbo/2\n            y = cheeseSlices-(jumbo/2)\n            if x >= 0 and y >= 0:\n                return [x, y]\n            else:\n                return []\n        return []\n        ",
        "output": "struct Solution;\n\nimpl Solution {\n    fn num_of_burgers(tomato_slices: i32, cheese_slices: i32) -> Vec<i32> {\n        if tomato_slices - 2 * cheese_slices < 0 {\n            return vec![];\n        }\n        if (tomato_slices - 2 * cheese_slices) % 2 != 0 {\n            return vec![];\n        }\n        if cheese_slices * 4 - tomato_slices < 0 {\n            return vec![];\n        }\n        if (cheese_slices * 4 - tomato_slices) % 2 != 0 {\n            return vec![];\n        }\n        let x = (tomato_slices - 2 * cheese_slices) / 2;\n        let y = (cheese_slices * 4 - tomato_slices) / 2;\n        vec![x, y]\n    }\n}\n\n#[test]\nfn test() {\n    let tomato_slices = 16;\n    let cheese_slices = 7;\n    let res = vec![1, 6];\n    assert_eq!(Solution::num_of_burgers(tomato_slices, cheese_slices), res);\n    let tomato_slices = 17;\n    let cheese_slices = 4;\n    let res: Vec<i32> = vec![];\n    assert_eq!(Solution::num_of_burgers(tomato_slices, cheese_slices), res);\n    let tomato_slices = 4;\n    let cheese_slices = 17;\n    let res: Vec<i32> = vec![];\n    assert_eq!(Solution::num_of_burgers(tomato_slices, cheese_slices), res);\n    let tomato_slices = 0;\n    let cheese_slices = 0;\n    let res = vec![0, 0];\n    assert_eq!(Solution::num_of_burgers(tomato_slices, cheese_slices), res);\n}\n"
    },
    {
        "input": "\nclass Solution(object):\n    def sequentialDigits(self, low, high):\n        \n        result = []\n        start = int(str(low)[0])\n        for val in range(1, len(str(low))):\n            new_val = start%10 + 1\n            start = start*10 + new_val\n        if start > high:\n            return result\n        \n        result.append(start)\n        \n        while result[-1] <= high:\n            temp = str(result[-1])\n            next_elem = int(temp[-1]) + 1\n\n            if next_elem > 9:\n                next_greater = 0\n                for index in range(len(temp) + 1):\n                    next_greater = next_greater*10 + (index+1)\n            else:\n                next_greater = int(temp[1:]) * 10 + next_elem\n            if next_greater <= high:\n                result.append(next_greater)\n            else:\n                break\n            \n        final_result = []\n        for val in result:\n            if '0' not in str(val) and val >= low:\n                final_result.append(val)\n        return final_result\n",
        "output": "struct Solution;\n\nimpl Solution {\n    fn sequential_digits(low: i32, high: i32) -> Vec<i32> {\n        let mut res = vec![];\n        for i in 1..10 {\n            Self::dfs(i, i, &mut res, low, high);\n        }\n        res.sort_unstable();\n        res\n    }\n    fn dfs(last_digit: i32, cur: i32, all: &mut Vec<i32>, low: i32, high: i32) {\n        if cur >= low && cur <= high {\n            all.push(cur);\n        }\n        if cur >= high {\n            return;\n        }\n        if last_digit < 9 {\n            Self::dfs(last_digit + 1, cur * 10 + last_digit + 1, all, low, high);\n        }\n    }\n}\n\n#[test]\nfn test() {\n    let low = 100;\n    let high = 300;\n    let res = vec![123, 234];\n    assert_eq!(Solution::sequential_digits(low, high), res);\n    let low = 1000;\n    let high = 13000;\n    let res = vec![1234, 2345, 3456, 4567, 5678, 6789, 12345];\n    assert_eq!(Solution::sequential_digits(low, high), res);\n}\n"
    },
    {
        "input": "\n\nclass Solution(object):\n    def tictactoe(self, moves):\n        \n        def check(grid):\n            for x in range(3):\n                row = set([grid[x][0],grid[x][1],grid[x][2]])\n                if len(row) == 1 and grid[x][0] != 0:\n                    return grid[x][0]\n\n            for x in range(3):\n                column = set([grid[0][x],grid[1][x],grid[2][x]])\n                if len(column) == 1 and grid[0][x] != 0:\n                    return grid[0][x]\n\n            diag1 = set([grid[0][0],grid[1][1],grid[2][2]])\n            diag2 = set([grid[0][2],grid[1][1],grid[2][0]])\n            if len(diag1) == 1 or len(diag2) == 1 and grid[1][1] != 0:\n                return grid[1][1]\n\n            return 0\n        \n        if not moves:\n            return \"\"\n        grid = [[0, 0, 0], [0, 0, 0], [0,0,0]]\n        user = 1\n        for move in moves:\n            grid[move[0]][move[1]] = user\n            if user == 1:\n                user = 2\n            else:\n                user = 1\n    \n        result = check(grid)\n        if result == 1:\n            return \"A\"\n        elif result == 2:\n            return \"B\"\n        else:\n            if len(moves) == 9:\n                return \"Draw\"\n            else:\n                return \"Pending\"\n",
        "output": "struct Solution;\n\nimpl Solution {\n    fn tictactoe(moves: Vec<Vec<i32>>) -> String {\n        let mut board = [[' '; 3]; 3];\n        let mut player = 'X';\n        let n = moves.len();\n        for m in moves {\n            let r = m[0] as usize;\n            let c = m[1] as usize;\n            board[r][c] = player;\n            player = if player == 'X' { 'O' } else { 'X' };\n        }\n        let ss = [\n            [(0, 0), (0, 1), (0, 2)],\n            [(1, 0), (1, 1), (1, 2)],\n            [(2, 0), (2, 1), (2, 2)],\n            [(0, 0), (1, 0), (2, 0)],\n            [(0, 1), (1, 1), (2, 1)],\n            [(0, 2), (1, 2), (2, 2)],\n            [(0, 0), (1, 1), (2, 2)],\n            [(0, 2), (1, 1), (2, 0)],\n        ];\n        for s in &ss {\n            let mut a = 0;\n            let mut b = 0;\n            for p in s {\n                let i = p.0;\n                let j = p.1;\n                match board[i][j] {\n                    'X' => a += 1,\n                    'O' => b += 1,\n                    _ => {}\n                }\n            }\n            if a == 3 {\n                return \"A\".to_string();\n            }\n            if b == 3 {\n                return \"B\".to_string();\n            }\n        }\n        if n == 9 {\n            return \"Draw\".to_string();\n        }\n        \"Pending\".to_string()\n    }\n}\n\n#[test]\nfn test() {\n    let moves = vec_vec_i32![[0, 0], [2, 0], [1, 1], [2, 1], [2, 2]];\n    let res = \"A\".to_string();\n    assert_eq!(Solution::tictactoe(moves), res);\n    let moves = vec_vec_i32![[0, 0], [1, 1], [0, 1], [0, 2], [1, 0], [2, 0]];\n    let res = \"B\".to_string();\n    assert_eq!(Solution::tictactoe(moves), res);\n    let moves = vec_vec_i32![\n        [0, 0],\n        [1, 1],\n        [2, 0],\n        [1, 0],\n        [1, 2],\n        [2, 1],\n        [0, 1],\n        [0, 2],\n        [2, 2]\n    ];\n    let res = \"Draw\".to_string();\n    assert_eq!(Solution::tictactoe(moves), res);\n    let moves = vec_vec_i32![[0, 0], [1, 1]];\n    let res = \"Pending\".to_string();\n    assert_eq!(Solution::tictactoe(moves), res);\n}\n"
    },
    {
        "input": "\nclass Solution(object):\n    def findNumbers(self, nums):\n        \n        return len([num for num in nums if len(str(num))%2 == 0])",
        "output": "struct Solution;\n\nimpl Solution {\n    fn digits(mut n: i32) -> i32 {\n        let mut res = 0;\n        while n != 0 {\n            n /= 10;\n            res += 1;\n        }\n        res\n    }\n    fn find_numbers(nums: Vec<i32>) -> i32 {\n        let mut res = 0;\n        for n in nums {\n            if Self::digits(n) % 2 == 0 {\n                res += 1;\n            }\n        }\n        res\n    }\n}\n\n#[test]\nfn test() {\n    assert_eq!(Solution::find_numbers(vec![12, 345, 2, 6, 7896]), 2);\n}\n"
    },
    {
        "input": "\nclass Solution(object):\n    def groupThePeople(self, groupSizes):\n        \n        count = collections.defaultdict(list)\n        for i, size in enumerate(groupSizes):\n            count[size].append(i)\n        result = []\n        for s, value in count.items():\n            for index in range(0, len(value), s):\n                result.append(value[index:index + s])\n        return result\n",
        "output": "struct Solution;\n\ntype Person = (i32, usize);\n\nimpl Solution {\n    fn group_the_people(group_sizes: Vec<i32>) -> Vec<Vec<i32>> {\n        let mut people: Vec<Person> = vec![];\n        let mut res: Vec<Vec<i32>> = vec![];\n        for (id, &group_size) in group_sizes.iter().enumerate() {\n            people.push((group_size, id))\n        }\n        people.sort_unstable();\n        let mut group: Vec<i32> = vec![];\n        for p in people {\n            group.push(p.1 as i32);\n            if group.len() == p.0 as usize {\n                res.push(group);\n                group = vec![];\n            }\n        }\n        res\n    }\n}\n\n#[test]\nfn test() {\n    let group_sizes = vec![3, 3, 3, 3, 3, 1, 3];\n    let res = vec_vec_i32![[5], [0, 1, 2], [3, 4, 6]];\n    assert_eq!(Solution::group_the_people(group_sizes), res);\n    let group_sizes = vec![2, 1, 3, 3, 3, 2];\n    let res = vec_vec_i32![[1], [0, 5], [2, 3, 4]];\n    assert_eq!(Solution::group_the_people(group_sizes), res);\n}\n"
    },
    {
        "input": "\n\nclass Solution(object):\n    def minimumAbsDifference(self, arr):\n        \n        if not arr:\n            return []\n        \n        arr.sort()\n        mindiff = arr[1] - arr[0]\n        for index in range(2, len(arr)):\n            mindiff = min(mindiff, (arr[index] - arr[index-1]))\n        \n        result = []\n        for index in range(1, len(arr)):\n            if arr[index] - arr[index-1] == mindiff:\n                result.append([arr[index-1], arr[index]])\n        return result\n ",
        "output": "struct Solution;\n\nuse std::i32;\n\nimpl Solution {\n    fn minimum_abs_difference(mut arr: Vec<i32>) -> Vec<Vec<i32>> {\n        arr.sort_unstable();\n        let min = arr\n            .windows(2)\n            .fold(i32::MAX, |x, v| i32::min(x, v[1] - v[0]));\n        let mut res: Vec<Vec<i32>> = vec![];\n        for v in arr.windows(2) {\n            if v[1] - v[0] == min {\n                res.push(v.to_vec())\n            }\n        }\n        res\n    }\n}\n\n#[test]\nfn test() {\n    let arr = vec![4, 2, 1, 3];\n    let res: Vec<Vec<i32>> = vec_vec_i32![[1, 2], [2, 3], [3, 4]];\n    assert_eq!(Solution::minimum_abs_difference(arr), res);\n    let arr = vec![1, 3, 6, 10, 15];\n    let res: Vec<Vec<i32>> = vec_vec_i32![[1, 3]];\n    assert_eq!(Solution::minimum_abs_difference(arr), res);\n    let arr = vec![3, 8, -10, 23, 19, -4, -14, 27];\n    let res: Vec<Vec<i32>> = vec_vec_i32![[-14, -10], [19, 23], [23, 27]];\n    assert_eq!(Solution::minimum_abs_difference(arr), res);\n}\n"
    },
    {
        "input": "\n\nclass Solution(object):\n    def subtractProductAndSum(self, n):\n        \n        \n        from functools import reduce\n        from operator import mul\n        digits = [int(x) for x in str(n)]\n        return reduce(mul, digits) - sum(digits)\n",
        "output": "struct Solution;\n\nimpl Solution {\n    fn subtract_product_and_sum(mut n: i32) -> i32 {\n        let mut product = 1;\n        let mut sum = 0;\n        while n != 0 {\n            let d = n % 10;\n            product *= d;\n            sum += d;\n            n /= 10;\n        }\n        product - sum\n    }\n}\n\n#[test]\nfn test() {\n    assert_eq!(Solution::subtract_product_and_sum(234), 15);\n}\n"
    },
    {
        "input": "\nclass Solution(object):\n    def countSquares(self, matrix):\n          \n    \n        p_arr = [[0 for i in range(len(matrix[0]))] for j in range(len(matrix))]  \n        result = 0\n\n        for index_i in range(1, len(matrix)):\n            for index_j in range(1, len(matrix[0])):\n                if matrix[index_i][index_j] == 1:\n                    matrix[index_i][index_j] = min(matrix[index_i-1][index_j-1], min(matrix[index_i-1][index_j], matrix[index_i][index_j-1]))+1\n        \n        return sum([ sum(x) for x in matrix])  ",
        "output": "struct Solution;\n\nimpl Solution {\n    fn count_squares(mut matrix: Vec<Vec<i32>>) -> i32 {\n        let n = matrix.len();\n        let m = matrix[0].len();\n        let mut res = 0;\n        for i in 0..n {\n            for j in 0..m {\n                if matrix[i][j] == 1 {\n                    matrix[i][j] = if i > 0 && j > 0 {\n                        1 + [matrix[i - 1][j], matrix[i][j - 1], matrix[i - 1][j - 1]]\n                            .iter()\n                            .min()\n                            .unwrap()\n                    } else {\n                        1\n                    };\n                }\n                res += matrix[i][j];\n            }\n        }\n        res\n    }\n}\n#[test]\nfn test() {\n    let matrix = vec_vec_i32![[0, 1, 1, 1], [1, 1, 1, 1], [0, 1, 1, 1]];\n    let res = 15;\n    assert_eq!(Solution::count_squares(matrix), res);\n    let matrix = vec_vec_i32![[1, 0, 1], [1, 1, 0], [1, 1, 0]];\n    let res = 7;\n    assert_eq!(Solution::count_squares(matrix), res);\n}\n"
    },
    {
        "input": "\nclass Solution(object):\n    def isPossibleDivide(self, nums, k):\n        \n        from collections import Counter\n        count_map = Counter(nums)\n        for num in sorted(count_map.keys()):\n            if count_map[num] <= 0:\n                continue\n            for index in range(1, k):\n                count_map[num+index] -= count_map[num]\n                if count_map[num+index] < 0:\n                    return False\n        return True\n",
        "output": "struct Solution;\nuse std::collections::BTreeMap;\nuse std::collections::VecDeque;\n\nimpl Solution {\n    fn is_possible_divide(nums: Vec<i32>, k: i32) -> bool {\n        let n = nums.len();\n        let k = k as usize;\n        if n % k != 0 {\n            return false;\n        }\n        let mut btm: BTreeMap<i32, usize> = BTreeMap::new();\n        for x in nums {\n            *btm.entry(x).or_default() += 1;\n        }\n        let mut queue: VecDeque<(i32, usize)> = VecDeque::new();\n        for (val, size) in btm {\n            queue.push_back((val, size));\n            if queue.len() == k {\n                let (first_val, first_size) = queue.pop_front().unwrap();\n                for i in 1..k {\n                    let (next_val, next_size) = queue.pop_front().unwrap();\n                    if next_val != first_val + i as i32 {\n                        return false;\n                    }\n                    if next_size < first_size {\n                        return false;\n                    }\n                    if next_size > first_size {\n                        queue.push_back((next_val, next_size - first_size));\n                    }\n                }\n            }\n        }\n        queue.is_empty()\n    }\n}\n\n#[test]\nfn test() {\n    let nums = vec![1, 2, 3, 3, 4, 4, 5, 6];\n    let k = 4;\n    let res = true;\n    assert_eq!(Solution::is_possible_divide(nums, k), res);\n    let nums = vec![3, 2, 1, 2, 3, 4, 3, 4, 5, 9, 10, 11];\n    let k = 3;\n    let res = true;\n    assert_eq!(Solution::is_possible_divide(nums, k), res);\n    let nums = vec![3, 3, 2, 2, 1, 1];\n    let k = 3;\n    let res = true;\n    assert_eq!(Solution::is_possible_divide(nums, k), res);\n    let nums = vec![1, 2, 3, 4];\n    let k = 3;\n    let res = false;\n    assert_eq!(Solution::is_possible_divide(nums, k), res);\n}\n"
    },
    {
        "input": "\n\nclass Solution(object):\n    def isInterleave(self, s1, s2, s3):\n        \n        \n        if len(s3) != len(s1) + len(s2):\n        \treturn False\n\n        dp = [[False for _ in range(len(s2)+1)] for _ in range(len(s1)+1)]\n        for row in range(len(s1)+1):\n        \tfor col in range(len(s2)+1):\n        \t\tif row == 0 and col == 0:\n        \t\t\tdp[row][col] = True \n        \t\telif row == 0:\n        \t\t\tdp[row][col] =dp[row][col-1] and s2[col-1] == s3[row+col-1]\n        \t\telif col == 0:\n        \t\t\tdp[row][col] = dp[row-1][col] and s1[row-1] == s3[row+col-1]\n        \t\telse:\n        \t\t\tdp[row][col] = (dp[row][col-1] and s2[col-1] == s3[row+col-1]) or (dp[row-1][col] and s1[row-1] == s3[row+col-1])\n\n        return dp[len(s1)][len(s2)]\n\n\n",
        "output": "struct Solution;\nuse std::collections::HashMap;\n\nimpl Solution {\n    fn is_interleave(s1: String, s2: String, s3: String) -> bool {\n        let n1 = s1.len();\n        let n2 = s2.len();\n        let n3 = s3.len();\n        let s1: Vec<char> = s1.chars().collect();\n        let s2: Vec<char> = s2.chars().collect();\n        let s3: Vec<char> = s3.chars().collect();\n        let mut memo: HashMap<(usize, usize, usize), bool> = HashMap::new();\n        Self::dp(0, 0, 0, &mut memo, &s1, &s2, &s3, n1, n2, n3)\n    }\n\n    fn dp(\n        i: usize,\n        j: usize,\n        k: usize,\n        memo: &mut HashMap<(usize, usize, usize), bool>,\n        s1: &[char],\n        s2: &[char],\n        s3: &[char],\n        n1: usize,\n        n2: usize,\n        n3: usize,\n    ) -> bool {\n        if i == n1 && j == n2 && k == n3 {\n            true\n        } else {\n            if let Some(&res) = memo.get(&(i, j, k)) {\n                return res;\n            }\n            let res = (i < n1\n                && k < n3\n                && s1[i] == s3[k]\n                && Self::dp(i + 1, j, k + 1, memo, s1, s2, s3, n1, n2, n3))\n                || (j < n2\n                    && k < n3\n                    && s2[j] == s3[k]\n                    && Self::dp(i, j + 1, k + 1, memo, s1, s2, s3, n1, n2, n3));\n            memo.insert((i, j, k), res);\n            res\n        }\n    }\n}\n\n#[test]\nfn test() {\n    let s1 = \"aabcc\".to_string();\n    let s2 = \"dbbca\".to_string();\n    let s3 = \"aadbbcbcac\".to_string();\n    let res = true;\n    assert_eq!(Solution::is_interleave(s1, s2, s3), res);\n    let s1 = \"aabcc\".to_string();\n    let s2 = \"dbbca\".to_string();\n    let s3 = \"aadbbbaccc\".to_string();\n    let res = false;\n    assert_eq!(Solution::is_interleave(s1, s2, s3), res);\n}\n"
    },
    {
        "input": "\n\nclass Solution(object):\n    def isValidSudoku(self, board):\n        \n        import collections\n        dict_row, dict_col, dict_cell = collections.defaultdict(set), collections.defaultdict(set), collections.defaultdict(set)\n        \n        for row_index in range(1, 4):\n            for col_index in range(1, 4):\n                for row in range(3*(row_index-1), 3*row_index):\n                    for col in range(3*(col_index-1), 3*col_index):\n                        cell_data = board[row][col]\n                        if cell_data == '.':\n                            continue\n                        if cell_data in dict_row[row] or cell_data in dict_col[col] or cell_data in dict_cell[(row_index, col_index)]:\n                            return False\n                        \n                        dict_row[row].add(cell_data)\n                        dict_col[col].add(cell_data)\n                        dict_cell[(row_index, col_index)].add(cell_data)\n        \n        return True\n",
        "output": "struct Solution;\n\nuse std::collections::HashSet;\n\nimpl Solution {\n    fn is_valid_sudoku(board: Vec<Vec<char>>) -> bool {\n        let mut rows: Vec<HashSet<char>> = vec![HashSet::new(); 9];\n        let mut cols: Vec<HashSet<char>> = vec![HashSet::new(); 9];\n        let mut boxes: Vec<HashSet<char>> = vec![HashSet::new(); 9];\n        for i in 0..9 {\n            for j in 0..9 {\n                let c = board[i][j];\n                if c == '.' {\n                    continue;\n                }\n                if !rows[i].insert(c) {\n                    return false;\n                }\n\n                if !cols[j].insert(c) {\n                    return false;\n                }\n\n                let k = (i / 3) * 3 + (j / 3);\n                if !boxes[k].insert(c) {\n                    return false;\n                }\n            }\n        }\n        true\n    }\n}\n\n#[test]\nfn test() {\n    let board = vec_vec_char![\n        ['5', '3', '.', '.', '7', '.', '.', '.', '.'],\n        ['6', '.', '.', '1', '9', '5', '.', '.', '.'],\n        ['.', '9', '8', '.', '.', '.', '.', '6', '.'],\n        ['8', '.', '.', '.', '6', '.', '.', '.', '3'],\n        ['4', '.', '.', '8', '.', '3', '.', '.', '1'],\n        ['7', '.', '.', '.', '2', '.', '.', '.', '6'],\n        ['.', '6', '.', '.', '.', '.', '2', '8', '.'],\n        ['.', '.', '.', '4', '1', '9', '.', '.', '5'],\n        ['.', '.', '.', '.', '8', '.', '.', '7', '9']\n    ];\n    assert_eq!(Solution::is_valid_sudoku(board), true);\n    let board = vec_vec_char![\n        ['8', '3', '.', '.', '7', '.', '.', '.', '.'],\n        ['6', '.', '.', '1', '9', '5', '.', '.', '.'],\n        ['.', '9', '8', '.', '.', '.', '.', '6', '.'],\n        ['8', '.', '.', '.', '6', '.', '.', '.', '3'],\n        ['4', '.', '.', '8', '.', '3', '.', '.', '1'],\n        ['7', '.', '.', '.', '2', '.', '.', '.', '6'],\n        ['.', '6', '.', '.', '.', '.', '2', '8', '.'],\n        ['.', '.', '.', '4', '1', '9', '.', '.', '5'],\n        ['.', '.', '.', '.', '8', '.', '.', '7', '9']\n    ];\n    assert_eq!(Solution::is_valid_sudoku(board), false);\n}\n"
    },
    {
        "input": "\n\nclass Solution(object):\n    def plusOne(self, digits):\n        \n        result = []\n        if not digits:\n        \treturn []\n\n        carry = 1\n        new_digits = digits[::-1]\n\n        for index in range(len(new_digits)):\n        \tnew_digits[index], carry = (new_digits[index] + carry)%10, (new_digits[index] + carry)/10\n\n        if carry > 0:\n        \tnew_digits.append(carry)\n        return new_digits[::-1]\n\nTime: O(N)\nSpace: O(1)",
        "output": "struct Solution;\n\nimpl Solution {\n    fn plus_one(digits: Vec<i32>) -> Vec<i32> {\n        let mut sum: Vec<i32> = vec![];\n        let mut carry: i32 = 0;\n        for (i, d) in digits.iter().rev().enumerate() {\n            let x = if i == 0 { d + 1 } else { d + carry };\n            carry = x / 10;\n            sum.insert(0, x % 10);\n        }\n        if carry != 0 {\n            sum.insert(0, carry);\n        }\n        sum\n    }\n}\n\n#[test]\nfn test() {\n    assert_eq!(Solution::plus_one(vec![9, 9, 9]), vec![1, 0, 0, 0])\n}\n"
    },
    {
        "input": "\n\nclass Solution(object):\n    def isMatch(self, s, p):\n        \n        \n        if len(p) == 0:\n        \treturn len(s) == 0\n\n        dp = [[False for _ in range(len(p) + 1)] for _ in range(len(s) + 1)]\n        dp[0][0] = True\n\n        for index in range(1,len(dp[0])):\n            if p[index-1] == '*':\n                dp[0][index] = dp[0][index-1]\n\n        for index_i in range(1, len(dp)):\n        \tfor index_j in range(1, len(dp[0])):\n        \t\tif s[index_i - 1] == p[index_j - 1] or p[index_j - 1] == '?':\n        \t\t\tdp[index_i][index_j] = dp[index_i-1][index_j-1]\n        \t\telif p[index_j-1] == '*':\n        \t\t\tdp[index_i][index_j] = dp[index_i][index_j-1] or dp[index_i-1][index_j]\n        \t\telse:\n        \t\t\tdp[index_i][index_j] = False\n        return dp[len(s)][len(p)]",
        "output": "struct Solution;\n\nimpl Solution {\n    fn is_match(s: String, p: String) -> bool {\n        let n = s.len();\n        let m = p.len();\n        let s: Vec<char> = s.chars().collect();\n        let p: Vec<char> = p.chars().collect();\n        let mut memo: Vec<Vec<Option<bool>>> = vec![vec![None; m + 1]; n + 1];\n        Self::is_match_dp(n, m, &mut memo, &s, &p)\n    }\n\n    fn is_match_dp(\n        n: usize,\n        m: usize,\n        memo: &mut Vec<Vec<Option<bool>>>,\n        s: &[char],\n        p: &[char],\n    ) -> bool {\n        if let Some(ans) = memo[n][m] {\n            ans\n        } else {\n            let res = if n == 0 && m == 0 {\n                true\n            } else if n == 0 && m != 0 {\n                if p[m - 1] == '*' {\n                    Self::is_match_dp(n, m - 1, memo, s, p)\n                } else {\n                    false\n                }\n            } else if n != 0 && m == 0 {\n                false\n            } else {\n                if s[n - 1] == p[m - 1] {\n                    Self::is_match_dp(n - 1, m - 1, memo, s, p)\n                } else {\n                    match p[m - 1] {\n                        '?' => Self::is_match_dp(n - 1, m - 1, memo, s, p),\n                        '*' => {\n                            Self::is_match_dp(n - 1, m, memo, s, p)\n                                || Self::is_match_dp(n, m - 1, memo, s, p)\n                        }\n                        _ => false,\n                    }\n                }\n            };\n\n            memo[n][m] = Some(res);\n            res\n        }\n    }\n}\n\n#[test]\nfn test() {\n    let s = \"aa\".to_string();\n    let p = \"a\".to_string();\n    let res = false;\n    assert_eq!(Solution::is_match(s, p), res);\n    let s = \"aa\".to_string();\n    let p = \"*\".to_string();\n    let res = true;\n    assert_eq!(Solution::is_match(s, p), res);\n    let s = \"cb\".to_string();\n    let p = \"?a\".to_string();\n    let res = false;\n    assert_eq!(Solution::is_match(s, p), res);\n    let s = \"adceb\".to_string();\n    let p = \"*a*b\".to_string();\n    let res = true;\n    assert_eq!(Solution::is_match(s, p), res);\n    let s = \"acdcb\".to_string();\n    let p = \"a*c?b\".to_string();\n    let res = false;\n    assert_eq!(Solution::is_match(s, p), res);\n}\n"
    },
    {
        "input": "\n\nclass Solution(object):\n    def climbStairs(self, n):\n        \n        if n == 0:\n        \treturn 0\n\n        dp = [0]*n\n        dp[0], dp[1] = 1, 2\n\n        for index in range(2, n):\n        \tdp[index] = dp[index-1] + dp[index-2]\n        return dp[n-1]\n\n\n\n",
        "output": "struct Solution;\n\nimpl Solution {\n    fn climb_stairs(n: i32) -> i32 {\n        match n {\n            1 | 2 => n,\n            k => (2..k).fold((1, 2), |acc, _| (acc.1, acc.0 + acc.1)).1,\n        }\n    }\n}\n\n#[test]\nfn test() {\n    assert_eq!(Solution::climb_stairs(3), 3);\n    assert_eq!(Solution::climb_stairs(2), 2);\n    assert_eq!(Solution::climb_stairs(1), 1);\n}\n"
    },
    {
        "input": "\nclass Solution(object):\n    def firstMissingPositive(self, nums):\n        \n        index_i = 0\n        for index_j in range(len(nums)):\n        \tif nums[index_j] <= 0:\n        \t\tnums[index_i], nums[index_j] = nums[index_j], nums[index_i]\n        \t\tindex_i += 1\n\n        for index in range(index_i, len(nums)):\n        \tif abs(nums[index]) - 1 < len(nums) and nums[abs(nums[index]) - 1] > 0:\n        \t\tnums[abs(nums[index]) - 1] =  -nums[abs(nums[index]) - 1]\n\n        for index in range(nums):\n        \tif nums[index] > 0:\n        \t\treturn index + 1\n        return len(nums) + 1",
        "output": "struct Solution;\n\nimpl Solution {\n    fn first_missing_positive(mut nums: Vec<i32>) -> i32 {\n        let n = nums.len();\n        for i in 0..n {\n            loop {\n                let j = nums[i] - 1;\n                if j >= 0 && j < n as i32 && nums[j as usize] != nums[i] {\n                    nums.swap(i, j as usize);\n                } else {\n                    break;\n                }\n            }\n        }\n        for i in 0..n {\n            if nums[i] != i as i32 + 1 {\n                return (i + 1) as i32;\n            }\n        }\n        (n + 1) as i32\n    }\n}\n\n#[test]\nfn test() {\n    let nums = vec![1, 2, 0];\n    let res = 3;\n    assert_eq!(Solution::first_missing_positive(nums), res);\n    let nums = vec![3, 4, -1, 1];\n    let res = 2;\n    assert_eq!(Solution::first_missing_positive(nums), res);\n    let nums = vec![7, 8, 9, 11, 12];\n    let res = 1;\n    assert_eq!(Solution::first_missing_positive(nums), res);\n}\n"
    },
    {
        "input": "\n\nclass Solution(object):\n    def threeSumClosest(self, nums, target):\n        \n        \n        nums.sort()\n        result, min_diff = 0, float('inf')\n\n        for index in range(len(nums)-1):\n        \tleft = index + 1\n        \tright = len(nums) - 1\n\n        \twhile left < right:\n        \t\tcurrSum = nums[index] + nums[left] + nums[right]\n        \t\tdiff = abs(target - currSum)\n\n        \t\tif diff == 0:\n        \t\t\treturn target\n        \t\tif diff < min_diff:\n        \t\t\tmin_diff = diff\n        \t\t\tresult = currSum\n\n        \t\tif currSum < target:\n        \t\t\tleft += 1\n        \t\telse:\n        \t\t\tright -= 1\n        return result\n\n\n\n",
        "output": "struct Solution;\n\nuse std::i32;\n\nimpl Solution {\n    fn three_sum_closest(mut nums: Vec<i32>, target: i32) -> i32 {\n        nums.sort_unstable();\n        let n = nums.len();\n        let mut res = 0;\n        let mut diff = i32::MAX;\n        for i in 0..n - 2 {\n            let mut l = i + 1;\n            let mut r = n - 1;\n            while l < r {\n                let sum = nums[l] + nums[r] + nums[i];\n                if sum == target {\n                    return target;\n                }\n                if (sum - target).abs() < diff {\n                    diff = (sum - target).abs();\n                    res = sum;\n                }\n                if nums[l] + nums[r] > target - nums[i] {\n                    r -= 1;\n                } else {\n                    l += 1;\n                }\n            }\n        }\n        res\n    }\n}\n\n#[test]\nfn test() {\n    let nums = vec![-1, 2, 1, -4];\n    let target = 1;\n    let res = 2;\n    assert_eq!(Solution::three_sum_closest(nums, target), res);\n}\n"
    },
    {
        "input": "    \nclass Solution(object):\n    def jump(self, nums):\n        \n        steps, lastRearch, maxReach = 0, 0 ,0\n\n        for index in range(len(nums)):\n        \tif index > lastRearch:\n        \t\tlastRearch = maxReach\n        \t\tsteps += 1\n        \tmaxReach = max(maxReach, index + nums[index])\n\n       \treturn steps if maxReach == len(nums) - 1 else 0\n",
        "output": "struct Solution;\n\nimpl Solution {\n    fn jump(nums: Vec<i32>) -> i32 {\n        let n = nums.len();\n        let mut end = 0;\n        let mut max = 0;\n        let mut res = 0;\n        for i in 0..n - 1 {\n            max = max.max(i + nums[i] as usize);\n            if i == end {\n                res += 1;\n                end = max;\n            }\n        }\n        res\n    }\n}\n\n#[test]\nfn test() {\n    let nums = vec![2, 3, 1, 1, 4];\n    let res = 2;\n    assert_eq!(Solution::jump(nums), res);\n}\n"
    },
    {
        "input": "class Solution(object):\n    def longestValidParentheses(self, s):\n        \n        stack, result = [-1], 0\n\n        for index in range(len(s)):\n        \tif s[index] == '(':\n        \t\tstack.append(index)\n        \telse:\n        \t\tcurrIndex = stack.pop()\n        \t\tif currIndex == -1:\n        \t\t\tstack.append(index)\n        \t\telse:\n        \t\t\tresult = max(result, index-currIndex+1)\n        return result",
        "output": "struct Solution;\n\n#[derive(Debug)]\nenum Tok {\n    Left,\n    Pair(i32),\n}\n\nimpl Solution {\n    fn longest_valid_parentheses(s: String) -> i32 {\n        let mut res = 0;\n        let mut stack: Vec<Tok> = vec![];\n        for c in s.chars() {\n            if c == '(' {\n                stack.push(Tok::Left)\n            } else {\n                match stack.pop() {\n                    Some(Tok::Left) => {\n                        if let Some(Tok::Pair(x)) = stack.last_mut() {\n                            *x += 2;\n                            res = res.max(*x);\n                        } else {\n                            stack.push(Tok::Pair(2));\n                            res = res.max(2);\n                        }\n                    }\n                    Some(Tok::Pair(x)) => {\n                        if let Some(Tok::Left) = stack.pop() {\n                            if let Some(Tok::Pair(y)) = stack.last_mut() {\n                                *y += x + 2;\n                                res = res.max(*y);\n                            } else {\n                                stack.push(Tok::Pair(x + 2));\n                                res = res.max(x + 2);\n                            }\n                        }\n                    }\n                    None => {}\n                }\n            }\n        }\n        if let Some(Tok::Pair(x)) = stack.pop() {\n            res = res.max(x);\n        }\n        res\n    }\n}\n\n#[test]\nfn test() {\n    let s = \"(()\".to_string();\n    let res = 2;\n    assert_eq!(Solution::longest_valid_parentheses(s), res);\n    let s = \")()())\".to_string();\n    let res = 4;\n    assert_eq!(Solution::longest_valid_parentheses(s), res);\n    let s = \"()(())\".to_string();\n    let res = 6;\n    assert_eq!(Solution::longest_valid_parentheses(s), res);\n}\n"
    },
    {
        "input": "\n\nclass Solution(object):\n    def isNumber(self, s):\n        \n        s = s.strip()\n        try:\n            if isinstance(float(s),float) or isinstance(int(s),int):\n                return True\n        except Exception as e:\n            return False\n\n\n",
        "output": "struct Solution;\n\nuse std::cmp::Ordering::*;\nuse std::iter::Peekable;\nuse std::vec::IntoIter;\n\n#[derive(PartialEq, Eq, Clone, Copy)]\nenum Tok {\n    Num(i32),\n    Op(char),\n}\n\nimpl Solution {\n    fn is_number(s: String) -> bool {\n        let s = s.trim();\n        let mut it = s.chars().peekable();\n        let mut tokens: Vec<Tok> = vec![];\n        let mut e_count = 0;\n        while let Some(c) = it.next() {\n            match c {\n                ' ' | '-' | '+' | '.' => {\n                    tokens.push(Tok::Op(c));\n                }\n                'e' => {\n                    e_count += 1;\n                    if e_count == 2 {\n                        return false;\n                    }\n                    tokens.push(Tok::Op(c));\n                }\n                '0'..='9' => {\n                    let mut x = (c as u8 - b'0') as i32;\n                    while let Some('0'..='9') = it.peek() {\n                        x *= 10;\n                        x += (it.next().unwrap() as u8 - b'0') as i32;\n                    }\n                    tokens.push(Tok::Num(x));\n                }\n                _ => {\n                    return false;\n                }\n            }\n        }\n\n        if let Some(e_pos) = tokens.iter().position(|&x| x == Tok::Op('e')) {\n            let mut left = vec![];\n            let mut right = vec![];\n            for (i, tok) in tokens.into_iter().enumerate() {\n                match i.cmp(&e_pos) {\n                    Less => {\n                        left.push(tok);\n                    }\n                    Greater => {\n                        right.push(tok);\n                    }\n                    _ => {}\n                }\n            }\n            Self::parse_float(&mut left.into_iter().peekable())\n                && Self::parse_int(&mut right.into_iter().peekable())\n        } else {\n            Self::parse_float(&mut tokens.into_iter().peekable())\n        }\n    }\n\n    fn parse_int(it: &mut Peekable<IntoIter<Tok>>) -> bool {\n        if let Some(Tok::Op('+')) | Some(Tok::Op('-')) = it.peek() {\n            it.next();\n        }\n        Self::parse_uint(it)\n    }\n\n    fn parse_uint(it: &mut Peekable<IntoIter<Tok>>) -> bool {\n        if let Some(Tok::Num(_)) = it.next() {\n            it.next().is_none()\n        } else {\n            false\n        }\n    }\n\n    fn parse_ufloat(it: &mut Peekable<IntoIter<Tok>>) -> bool {\n        match it.peek() {\n            Some(Tok::Op('.')) => {\n                it.next();\n                Self::parse_uint(it)\n            }\n            Some(Tok::Num(_)) => {\n                it.next();\n                match it.peek() {\n                    Some(Tok::Op('.')) => {\n                        it.next();\n                        if it.peek().is_none() {\n                            true\n                        } else {\n                            Self::parse_uint(it)\n                        }\n                    }\n                    None => true,\n                    _ => false,\n                }\n            }\n            _ => false,\n        }\n    }\n\n    fn parse_float(it: &mut Peekable<IntoIter<Tok>>) -> bool {\n        if let Some(Tok::Op('+')) | Some(Tok::Op('-')) = it.peek() {\n            it.next();\n        }\n\n        Self::parse_ufloat(it)\n    }\n}\n\n#[test]\nfn test() {\n    let s = \"0\".to_string();\n    let res = true;\n    assert_eq!(Solution::is_number(s), res);\n    let s = \" 0.1 \".to_string();\n    let res = true;\n    assert_eq!(Solution::is_number(s), res);\n    let s = \"abc\".to_string();\n    let res = false;\n    assert_eq!(Solution::is_number(s), res);\n    let s = \"1 a\".to_string();\n    let res = false;\n    assert_eq!(Solution::is_number(s), res);\n    let s = \"2e10\".to_string();\n    let res = true;\n    assert_eq!(Solution::is_number(s), res);\n    let s = \" -90e3\".to_string();\n    let res = true;\n    assert_eq!(Solution::is_number(s), res);\n    let s = \" 1e\".to_string();\n    let res = false;\n    assert_eq!(Solution::is_number(s), res);\n    let s = \"e3\".to_string();\n    let res = false;\n    assert_eq!(Solution::is_number(s), res);\n    let s = \" 6e-1\".to_string();\n    let res = true;\n    assert_eq!(Solution::is_number(s), res);\n    let s = \" 99e2.5\".to_string();\n    let res = false;\n    assert_eq!(Solution::is_number(s), res);\n    let s = \" 53.5e93\".to_string();\n    let res = true;\n    assert_eq!(Solution::is_number(s), res);\n    let s = \" --6 \".to_string();\n    let res = false;\n    assert_eq!(Solution::is_number(s), res);\n    let s = \"-+3\".to_string();\n    let res = false;\n    assert_eq!(Solution::is_number(s), res);\n    let s = \"95a54e53\".to_string();\n    let res = false;\n    assert_eq!(Solution::is_number(s), res);\n    let s = \".1\".to_string();\n    let res = true;\n    assert_eq!(Solution::is_number(s), res);\n    let s = \"3.\".to_string();\n    let res = true;\n    assert_eq!(Solution::is_number(s), res);\n    let s = \". 1\".to_string();\n    let res = false;\n    assert_eq!(Solution::is_number(s), res);\n}\n"
    },
    {
        "input": "\n\n\n\n\n\n\n\nclass Solution(object):\n    def deleteDuplicates(self, head):\n        \n        if not head:\n        \treturn None\n\n        result = ListNode(0)\n        ans = result\n        curr = head\n        while curr:\n        \tvalue = curr.val\n        \tcount = 0\n        \twhile curr and curr.val == value:\n        \t\tcurr = curr.next\n        \t\tcount += 1\n        \tif count == 1:\n        \t\tresult.next = ListNode(value)\n        \t\tresult = result.next\n        return ans.next",
        "output": "struct Solution;\nuse rustgym_util::*;\n\nimpl Solution {\n    fn delete_duplicates(mut head: ListLink) -> ListLink {\n        let mut res: ListLink = None;\n        let mut stack: Vec<(i32, usize)> = vec![];\n        while let Some(node) = head {\n            let val = node.val;\n            match stack.last() {\n                Some(&(pval, count)) if pval == val => {\n                    stack.pop();\n                    stack.push((val, count + 1));\n                }\n                _ => {\n                    stack.push((val, 1));\n                }\n            }\n            head = node.next;\n        }\n        while let Some((val, count)) = stack.pop() {\n            if count == 1 {\n                res = ListLink::link(val, res);\n            }\n        }\n        res\n    }\n}\n\n#[test]\nfn test() {\n    let head = list!(1, 2, 3, 3, 4, 4, 5);\n    let res = list!(1, 2, 5);\n    assert_eq!(Solution::delete_duplicates(head), res);\n    let head = list!(1, 1, 1, 2, 3);\n    let res = list!(2, 3);\n    assert_eq!(Solution::delete_duplicates(head), res);\n}\n"
    },
    {
        "input": "\n\nclass Solution(object):\n    def minDistance(self, word1, word2):\n        \n        m , n = len(word1), len(word2)\n\n        dp = [[0 for _ in range(n+1)] for _ in range(m+1)]\n        for index_i in range(m+1):\n        \tfor index_j in range(n+1):\n        \t\tif index_i == 0:\n        \t\t\tdp[index_i][index_j] = index_j\n        \t\telif index_j == 0:\n        \t\t\tdp[index_i][index_j] = index_i\n        \t\telif word1[index_i-1] == word2[index_j-1]:\n        \t\t\tdp[index_i][index_j] = dp[index_i-1][index_j-1]\n        \t\telse:\n        \t\t\tdp[index_i][index_j] = 1 + min(dp[index_i-1][index_j], dp[index_i-1][index_j-1], dp[index_i][index_j-1])\n\n        return dp[m][n]",
        "output": "struct Solution;\n\nimpl Solution {\n    fn min_distance(word1: String, word2: String) -> i32 {\n        let n = word1.len();\n        let m = word2.len();\n        let word1: Vec<char> = word1.chars().collect();\n        let word2: Vec<char> = word2.chars().collect();\n        let mut dp = vec![vec![0; m + 1]; n + 1];\n        for i in 0..=n {\n            dp[i][0] = i;\n        }\n        for j in 0..=m {\n            dp[0][j] = j;\n        }\n        for i in 1..=n {\n            for j in 1..=m {\n                if word1[i - 1] == word2[j - 1] {\n                    dp[i][j] = dp[i - 1][j - 1];\n                } else {\n                    dp[i][j] = dp[i - 1][j].min(dp[i][j - 1]).min(dp[i - 1][j - 1]) + 1;\n                }\n            }\n        }\n        dp[n][m] as i32\n    }\n}\n\n#[test]\nfn test() {\n    let word1 = \"horse\".to_string();\n    let word2 = \"ros\".to_string();\n    let res = 3;\n    assert_eq!(Solution::min_distance(word1, word2), res);\n    let word1 = \"intention\".to_string();\n    let word2 = \"execution\".to_string();\n    let res = 5;\n    assert_eq!(Solution::min_distance(word1, word2), res);\n}\n"
    },
    {
        "input": "\n\n\n\n\n\nclass Solution(object):\n    def rotateRight(self, head, k):\n        \n        if k == 0:\n        \treturn head\n        if not head:\n        \treturn None\n\n        tempHead, length = head, 1\n        while tempHead.next:\n        \tlength += 1\n        \ttempHead = tempHead.next\n\n        tempHead.next = head\n        jump = (length-k)%length\n\n        previous = tempHead\n        while jump > 0:\n        \tprevious = previous.next\n        \tjump -= 1\n        head = previous.next\n        previous.next = None\n\n        return head",
        "output": "struct Solution;\nuse rustgym_util::*;\n\nimpl Solution {\n    fn rotate_right(mut head: ListLink, k: i32) -> ListLink {\n        let mut p = head.as_ref();\n        let mut n = 0;\n        while let Some(node) = p {\n            p = node.next.as_ref();\n            n += 1;\n        }\n        if n < 2 {\n            return head;\n        }\n        let k = k as usize % n;\n        if k == 0 {\n            return head;\n        }\n        let mut i = 0;\n        let mut p = head.as_mut();\n        let mut new_head: ListLink = None;\n        while let Some(node) = p {\n            if i + k == n - 1 {\n                new_head = node.next.take();\n                break;\n            } else {\n                p = node.next.as_mut();\n            }\n            i += 1;\n        }\n        let mut p = new_head.as_mut();\n        while let Some(node) = p {\n            if node.next.is_none() {\n                node.next = head;\n                break;\n            }\n            p = node.next.as_mut();\n        }\n        new_head\n    }\n}\n\n#[test]\nfn test() {\n    let head = list!(1, 2, 3, 4, 5);\n    let k = 2;\n    let res = list!(4, 5, 1, 2, 3);\n    assert_eq!(Solution::rotate_right(head, k), res);\n    let head = list!(0, 1, 2);\n    let k = 4;\n    let res = list!(2, 0, 1);\n    assert_eq!(Solution::rotate_right(head, k), res);\n    let head = list!(1);\n    let k = 4;\n    let res = list!(1);\n    assert_eq!(Solution::rotate_right(head, k), res);\n}\n"
    },
    {
        "input": "\n\n\n\n\n\n\n\nclass Solution(object):\n    def insert(self, intervals, newInterval):\n        \n        result = []\n        for interval in intervals:\n        \tif newInterval.start > interval.end:\n        \t\tresult.append(interval)\n        \telif newInterval.end < interval.start:\n        \t\tresult.append(newInterval)\n        \t\tnewInterval = interval\n        \telif newInterval.start <= interval.end or newInterval.end >= interval.start:\n        \t\tnewInterval = Interval(min(newInterval.start, interval.start), max(interval.end, newInterval.end))\n\n        result.append(newInterval)\n       \treturn result",
        "output": "struct Solution;\n\nimpl Solution {\n    fn insert(intervals: Vec<Vec<i32>>, mut new_interval: Vec<i32>) -> Vec<Vec<i32>> {\n        let mut res = vec![];\n        for interval in intervals {\n            if interval[0] < new_interval[0] {\n                if interval[1] < new_interval[0] {\n                    res.push(interval);\n                } else {\n                    new_interval[0] = new_interval[0].min(interval[0]);\n                    new_interval[1] = new_interval[1].max(interval[1]);\n                }\n            } else {\n                if interval[0] > new_interval[1] {\n                    res.push(interval);\n                } else {\n                    new_interval[0] = new_interval[0].min(interval[0]);\n                    new_interval[1] = new_interval[1].max(interval[1]);\n                }\n            }\n        }\n        if let Err(i) = res.binary_search_by_key(&new_interval[0], |v| v[0]) {\n            res.insert(i, new_interval);\n        }\n        res\n    }\n}\n\n#[test]\nfn test() {\n    let intervals = vec_vec_i32![[1, 3], [6, 9]];\n    let new_interval = vec![2, 5];\n    let res = vec_vec_i32![[1, 5], [6, 9]];\n    assert_eq!(Solution::insert(intervals, new_interval), res);\n}\n"
    },
    {
        "input": "class Solution:\n    def myAtoi(self, str):\n        \n        str = str.strip()\n        number = \"\"\n        \n        \n        for x in str:\n            if x.isalpha() and number == \"\":\n                return 0\n            elif x.isalpha():\n                break\n            elif x == \".\":\n                break\n            elif x == \" \":\n                break\n            elif (x == \"+\" or x == \"-\") and number == \"\":\n                number = number + x\n            elif (x == \"+\" or x == \"-\") and number != \"\":\n                break\n            elif (x == \"+\" or x == \"-\") and (number[-1] == \"+\" or number[-1] == \"-\"):\n                return 0\n            elif (x == \"+\" or x == \"-\") and (\"+\" in number or \"-\" in number):\n                break\n            elif x.isdigit():\n                number = number + x\n        if number == \"\" or number == \"+\" or number == \"-\":\n            return 0\n        else:\n            if int(number) > ((2**31)-1):\n                return (2**31)-1\n            elif int(number) < -(2**31):\n                return -(2**31)\n            else:\n                return int(number)",
        "output": "struct Solution;\n\nimpl Solution {\n    fn gray_code(n: i32) -> Vec<i32> {\n        let mut res = vec![];\n        for i in 0..(1 << n) {\n            res.push(i ^ i >> 1);\n        }\n        res\n    }\n}\n\n#[test]\nfn test() {\n    let n = 2;\n    let res = vec![0, 1, 3, 2];\n    assert_eq!(Solution::gray_code(n), res);\n}\n"
    },
    {
        "input": "\n\nclass Solution(object):\n    def subsets(self, nums):\n        \n        result = [[]]\n        for num in nums:\n        \tfor j in range(len(result)):\n        \t\tresult.append(result[j] + [num])\n        return result",
        "output": "struct Solution;\n\nimpl Solution {\n    fn subsets(nums: Vec<i32>) -> Vec<Vec<i32>> {\n        let mut res: Vec<Vec<i32>> = vec![];\n        let mut v: Vec<i32> = vec![];\n        let n = nums.len();\n        Self::dfs(0, &mut res, &nums, &mut v, n);\n        res\n    }\n\n    fn dfs(i: usize, all: &mut Vec<Vec<i32>>, nums: &[i32], cur: &mut Vec<i32>, n: usize) {\n        if i == n {\n            all.push(cur.to_vec());\n        } else {\n            Self::dfs(i + 1, all, nums, cur, n);\n            cur.push(nums[i]);\n            Self::dfs(i + 1, all, nums, cur, n);\n            cur.pop();\n        }\n    }\n}\n\n#[test]\nfn test() {\n    let nums = vec![1, 2, 3];\n    let res = vec![\n        vec![],\n        vec![3],\n        vec![2],\n        vec![2, 3],\n        vec![1],\n        vec![1, 3],\n        vec![1, 2],\n        vec![1, 2, 3],\n    ];\n    assert_eq!(Solution::subsets(nums), res);\n}\n"
    },
    {
        "input": "\n\n\n\n\n\n\n\n\nclass Solution(object):\n    def isValidBST(self, root):\n        \n        if not root:\n\t        return True\n\n        stack, result = [], []\n        while stack or root:\n        \tif root:\n        \t\tstack.append(root)\n        \t\troot = root.left\n        \telse:\n        \t\troot = stack.pop()\n        \t\tresult.append(root.val)\n        \t\troot = root.right\n\n        previous = result[0]\n        for index in range(1, len(result)):\n        \tif previous >= result[index]:\n        \t\treturn False\n        \tprevious = result[index]\n        return True",
        "output": "struct Solution;\nuse rustgym_util::*;\n\ntrait Inorder {\n    fn inorder(&self, visit: &mut dyn FnMut(i32));\n}\n\nimpl Inorder for TreeLink {\n    fn inorder(&self, visit: &mut dyn FnMut(i32)) {\n        if let Some(node) = self {\n            let node = node.borrow();\n            Self::inorder(&node.left, visit);\n            visit(node.val);\n            Self::inorder(&node.right, visit);\n        }\n    }\n}\n\nimpl Solution {\n    fn is_valid_bst(root: TreeLink) -> bool {\n        let mut prev: Option<i32> = None;\n        let mut res = true;\n        root.inorder(&mut |x| {\n            if let Some(y) = prev {\n                if x <= y {\n                    res = false;\n                }\n            }\n            prev = Some(x);\n        });\n        res\n    }\n}\n\n#[test]\nfn test() {\n    let root = tree!(2, tree!(1), tree!(3));\n    let res = true;\n    assert_eq!(Solution::is_valid_bst(root), res);\n    let root = tree!(5, tree!(1), tree!(4, tree!(3), tree!(6)));\n    let res = false;\n    assert_eq!(Solution::is_valid_bst(root), res);\n}\n"
    },
    {
        "input": "\n\nclass Solution(object):\n    def largestRectangleArea(self, heights):\n        \n        if not heights:\n        \treturn 0\n\n        stack = []\n        result, index = 0, 0\n\n        while index < len(heights):\n        \tif not stack or heights[index] >= heights[stack[-1]]:\n        \t\tstack.append(index)\n        \t\tindex += 1\n        \telse:\n        \t\tcurr = stack.pop()\n        \t\tif not stack:\n        \t\t\tarea = heights[curr]*index\n        \t\telse:\n        \t\t\tarea = heights[curr] * (index-stack[-1]-1)\n        \t\tresult = max(result, area)\n\n        while stack:\n        \tcurr = stack.pop()\n        \tif not stack:\n        \t\tarea = heights[curr]*index\n        \telse:\n        \t\tarea = heights[curr] * (index-stack[-1]-1)\n        \tresult = max(result, area)\n        return result\n\n    def maximalRectangle(self, matrix):\n        \n        if not matrix:\n            return 0\n        m, n = len(matrix), len(matrix[0])\n        heights = [0 for index in range(n)]\n        result = 0\n        \n        for index_i in range(m):\n            for index_j in range(n):\n                if matrix[index_i][index_j] != '0':\n                    heights[index_j] = heights[index_j] + 1\n                else:\n                    heights[index_j] = 0\n                    \n            result = max(result, self.largestRectangleArea(heights))\n        return result\n        ",
        "output": "struct Solution;\n\nimpl Solution {\n    fn maximal_rectangle(matrix: Vec<Vec<char>>) -> i32 {\n        let n = matrix.len();\n        if n == 0 {\n            return 0;\n        }\n        let m = matrix[0].len();\n        let mut left = vec![0; m];\n        let mut right = vec![m; m];\n        let mut height = vec![0; m];\n        let mut res = 0;\n        for i in 0..n {\n            let mut l = 0;\n            let mut r = m;\n            for j in 0..m {\n                if matrix[i][j] == '1' {\n                    height[j] += 1;\n                } else {\n                    height[j] = 0;\n                }\n            }\n            for j in 0..m {\n                if matrix[i][j] == '1' {\n                    left[j] = left[j].max(l);\n                } else {\n                    left[j] = 0;\n                    l = j + 1;\n                }\n            }\n            for j in (0..m).rev() {\n                if matrix[i][j] == '1' {\n                    right[j] = right[j].min(r);\n                } else {\n                    right[j] = m;\n                    r = j;\n                }\n            }\n            for j in 0..m {\n                res = res.max((right[j] - left[j]) * height[j]);\n            }\n        }\n        res as i32\n    }\n}\n\n#[test]\nfn test() {\n    let matrix = vec_vec_char![\n        ['1', '0', '1', '0', '0'],\n        ['1', '0', '1', '1', '1'],\n        ['1', '1', '1', '1', '1'],\n        ['1', '0', '0', '1', '0']\n    ];\n    let res = 6;\n    assert_eq!(Solution::maximal_rectangle(matrix), res);\n}\n"
    },
    {
        "input": "\n\n\n\n\n\n\n\nclass Solution(object):\n    def reverseKGroup(self, head, k):\n        if head:\n            slow = head \n            while slow:\n                group = []\n                while slow and len(group) < k:\n                    group.append(slow)\n                    slow = slow.next\n                    if not slow and len(group) < k:\n                        return head\n                for i in range(k/2):\n                    print i,k-i-1\n                    group[i].val,group[k-i-1].val = group[k-i-1].val,group[i].val\n        return head\n\n\n",
        "output": "struct Solution;\nuse rustgym_util::*;\nuse std::collections::VecDeque;\n\nimpl Solution {\n    fn reverse_k_group(head: ListLink, k: i32) -> ListLink {\n        let mut p = head;\n        let mut count = 0;\n        let mut queue: VecDeque<ListLink> = VecDeque::new();\n        let k = k as usize;\n        while let Some(mut node) = p {\n            p = node.next.take();\n            queue.push_back(Some(node));\n            count += 1;\n            if count == k {\n                break;\n            }\n        }\n        if queue.len() == k {\n            let mut prev: ListLink = Self::reverse_k_group(p, k as i32);\n            while let Some(link) = queue.pop_front() {\n                if let Some(mut node) = link {\n                    node.next = prev;\n                    prev = Some(node);\n                }\n            }\n            prev\n        } else {\n            let mut prev: ListLink = None;\n            while let Some(link) = queue.pop_back() {\n                if let Some(mut node) = link {\n                    node.next = prev;\n                    prev = Some(node);\n                }\n            }\n            prev\n        }\n    }\n}\n\n#[test]\nfn test() {\n    let head = list!(1, 2, 3, 4, 5);\n    let k = 2;\n    let res = list!(2, 1, 4, 3, 5);\n    assert_eq!(Solution::reverse_k_group(head, k), res);\n    let head = list!(1, 2, 3, 4, 5);\n    let k = 3;\n    let res = list!(3, 2, 1, 4, 5);\n    assert_eq!(Solution::reverse_k_group(head, k), res);\n    let head = list!(1, 2);\n    let k = 2;\n    let res = list!(2, 1);\n    assert_eq!(Solution::reverse_k_group(head, k), res);\n}\n"
    },
    {
        "input": "\n\n\n\n\n\n\n\nclass Solution(object):\n    def swapPairs(self, head):\n        \n        \n        if head is None:\n            return head\n        \n        ref = head\n        \n        while ref is not None and ref.next is not None:\n            ref.val, ref.next.val = ref.next.val, ref.val\n            ref = ref.next.next\n            \n        return head",
        "output": "struct Solution;\nuse rustgym_util::*;\n\nimpl Solution {\n    fn swap_pairs(head: ListLink) -> ListLink {\n        if let Some(mut first) = head {\n            if let Some(mut second) = first.next.take() {\n                let rest = second.next.take();\n                first.next = Self::swap_pairs(rest);\n                second.next = Some(first);\n                Some(second)\n            } else {\n                Some(first)\n            }\n        } else {\n            None\n        }\n    }\n}\n\n#[test]\nfn test() {\n    let head = list!(1, 2, 3, 4);\n    let res = list!(2, 1, 4, 3);\n    assert_eq!(Solution::swap_pairs(head), res);\n}\n"
    },
    {
        "input": "\n\n\n\n\n\n\n\nclass Solution(object):\n    def reverseBetween(self, head, m, n):\n        \n        if m == n :\n        \treturn head\n\n        result = ListNode(0)\n        result.next = head\n\n        prev = result\n\n        for index in range(m-1):\n        \tprev = prev.next\n\n        reverse = None\n        curr = prev.next\n        for i in range(n-m+1):\n        \ttemp = curr.next\n        \tcurr.next = reverse\n        \treverse = curr\n        \tcurr = temp\n\n        prev.next.next = curr\n        prev.next = reverse\n        return result.next",
        "output": "struct Solution;\nuse rustgym_util::*;\n\nimpl Solution {\n    fn reverse_between(mut head: ListLink, m: i32, n: i32) -> ListLink {\n        let mut v1: Vec<ListLink> = vec![];\n        let mut v2: Vec<ListLink> = vec![];\n        let mut v3: Vec<ListLink> = vec![];\n        let mut i = 0;\n        while let Some(mut node) = head {\n            i += 1;\n            head = node.next.take();\n            if i < m {\n                v1.push(Some(node));\n            } else if i <= n {\n                v2.push(Some(node));\n            } else {\n                v3.push(Some(node));\n            }\n        }\n        let mut prev: ListLink = None;\n        for link in v3.into_iter().rev() {\n            let mut node = link.unwrap();\n            node.next = prev;\n            prev = Some(node);\n        }\n        for link in v2.into_iter() {\n            let mut node = link.unwrap();\n            node.next = prev;\n            prev = Some(node);\n        }\n        for link in v1.into_iter().rev() {\n            let mut node = link.unwrap();\n            node.next = prev;\n            prev = Some(node);\n        }\n        prev\n    }\n}\n\n#[test]\nfn test() {\n    let head = list!(1, 2, 3, 4, 5);\n    let m = 2;\n    let n = 4;\n    let res = list!(1, 4, 3, 2, 5);\n    assert_eq!(Solution::reverse_between(head, m, n), res);\n}\n"
    },
    {
        "input": "class Solution(object):\n    def permute(self, nums):\n        \n        \n        if len(nums) == 0:\n        \treturn []\n        if len(nums) == 1:\n        \treturn [nums]\n\n        result = []\n        for index in range(len(nums)):\n        \tfor p in self.permute(nums[0:index] + nums[index+1:]):\n        \t\tresult.append([nums[index]] + p)\n\n        return result",
        "output": "struct Solution;\n\nimpl Solution {\n    fn permute_r(arr: &mut Vec<i32>, start: usize, length: usize, res: &mut Vec<Vec<i32>>) {\n        if start == length {\n            res.push(arr.to_vec());\n            return;\n        }\n        for i in start..length {\n            arr.swap(start, i);\n            Self::permute_r(arr, start + 1, length, res);\n            arr.swap(start, i);\n        }\n    }\n\n    fn permute(mut nums: Vec<i32>) -> Vec<Vec<i32>> {\n        let mut res = vec![];\n        let n = nums.len();\n        Self::permute_r(&mut nums, 0, n, &mut res);\n        res\n    }\n}\n\n#[test]\nfn test() {\n    let nums = vec![1, 2, 3];\n    let mut ans: Vec<Vec<i32>> = [\n        [1, 2, 3],\n        [1, 3, 2],\n        [2, 1, 3],\n        [2, 3, 1],\n        [3, 1, 2],\n        [3, 2, 1],\n    ]\n    .iter()\n    .map(|v| v.to_vec())\n    .collect();\n    let mut res = Solution::permute(nums);\n    ans.sort_unstable();\n    res.sort_unstable();\n    assert_eq!(res, ans);\n}\n"
    },
    {
        "input": "\n\nclass Solution(object):\n    def restoreIpAddresses(self, s):\n        \n        result = []\n\n        def dfs(s, temp, count):\n            if count == 4:\n                if not s:\n                    result.append(temp[:-1])\n                    return\n\n            for index in range(1, 4):\n                if index <= len(s):\n                    if index == 1:\n                        dfs(s[index:], temp + s[:index] + \".\", count+1)\n                    elif index ==2 and s[0] != '0':\n                        dfs(s[index:], temp + s[:index] + \".\", count+1)\n                    elif index == 3 and s[0] != '0' and int(s[:3]) <= 255:\n                        dfs(s[index:], temp + s[:index] + \".\", count+1)\n\n        dfs(s, \"\", 0)\n        return result",
        "output": "struct Solution;\n\nimpl Solution {\n    fn restore_ip_addresses(s: String) -> Vec<String> {\n        let n = s.len();\n        let mut v: Vec<u8> = vec![0; 4];\n        let mut res: Vec<String> = vec![];\n        for i in 1..4 {\n            if i + 3 > n {\n                break;\n            }\n            if let Ok(a) = s[0..i].parse::<u8>() {\n                v[0] = a;\n            } else {\n                break;\n            }\n            for j in 1..4 {\n                if i + j + 2 > n {\n                    break;\n                }\n                if let Ok(b) = s[i..i + j].parse::<u8>() {\n                    v[1] = b;\n                } else {\n                    break;\n                }\n                for k in 1..4 {\n                    if i + j + k + 1 > n {\n                        break;\n                    }\n                    if let Ok(c) = s[i + j..i + j + k].parse::<u8>() {\n                        v[2] = c;\n                    } else {\n                        break;\n                    }\n                    for l in 1..4 {\n                        if i + j + k + l != n {\n                            continue;\n                        }\n                        if let Ok(d) = s[i + j + k..n].parse::<u8>() {\n                            v[3] = d;\n                            let ip = format!(\"{}.{}.{}.{}\", v[0], v[1], v[2], v[3]);\n                            if ip.len() == n + 3 {\n                                res.push(ip);\n                            }\n                        } else {\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n        res\n    }\n}\n\n#[test]\nfn test() {\n    let s = \"25525511135\".to_string();\n    let res: Vec<String> = vec_string![\"255.255.11.135\", \"255.255.111.35\"];\n    assert_eq!(Solution::restore_ip_addresses(s), res);\n    let s = \"010010\".to_string();\n    let res: Vec<String> = vec_string![\"0.10.0.10\", \"0.100.1.0\"];\n    assert_eq!(Solution::restore_ip_addresses(s), res);\n}\n"
    },
    {
        "input": "\n\nclass Solution(object):\n    def addBinary(self, a, b):\n        \n        \n        result = \"\"\n\n        carry = 0\n        index_a, index_b = len(a)-1, len(b)-1\n        while index_a >= 0 and index_b >= 0:\n        \tresult = (int(a[index_a]) + int(b[index_b]) + carry)%2 + result\n        \tcarry = (int(a[index_a]) + int(b[index_b]) + carry)%2\n        \tindex_a -= 1\n        \tindex_b -= 1\n\n        if index_a >= 0:\n        \twhile index_a >= 0:\n\t        \tresult = (int(a[index_a]) + carry)%2 + result\n\t        \tcarry = (int(a[index_a]) + carry)%2\n\t        \tindex_a -= 1\n\t    elif index_b >= 0:\n\t    \twhile index_b >= 0:\n\t    \t\tresult = (int(b[index_b]) + carry)%2 + result\n\t    \t\tcarry = (int(b[index_b]) + carry)%2\n\t    \t\tindex_b -= 1\n\t    else:\n\t    \tif carry == 1:\n\t    \t\tresult = str(carry) + result\n\t    return result",
        "output": "struct Solution;\n\nimpl Solution {\n    fn add_binary(a: String, b: String) -> String {\n        let aa = i128::from_str_radix(&a, 2).unwrap_or(0);\n        let bb = i128::from_str_radix(&b, 2).unwrap_or(0);\n        format!(\"{:b}\", aa + bb)\n    }\n}\n\n#[test]\nfn test() {\n    assert_eq!(\n        Solution::add_binary(\"1010\".to_string(), \"1011\".to_string()),\n        \"10101\".to_string()\n    );\n}\n"
    },
    {
        "input": "\n\nclass Solution(object):\n    def isMatch(self, s, p):\n        \n        dp = [[False for _ in range(len(p) + 1)] for _ in range(len(s) + 1)]\n        dp[0][0] = True\n\n \t\tfor index in range(1, len(dp[0])):\n            if p[index-1] == '*':\n                dp[0][index] = dp[0][index - 2]\n                \n        for index_i in range(1, len(dp)):\n        \tfor index_j in range(1, len(dp[0])):\n        \t\tif s[index_i - 1] == p[index_j - 1] or p[index_j - 1] == '.':\n        \t\t\tdp[index_i][index_j] = dp[index_i-1][index_j-1]\n        \t\telif p[index_j-1] == '*':\n        \t\t\tdp[index_i][index_j] = dp[index_i][index_j-2]\n\n        \t\t\tif s[index_i-1] == p[index_j-2] or p[index_j-2] == '.':\n        \t\t\t\tdp[index_i][index_j] = dp[index_i-1][index_j] or dp[index_i][index_j]\n\n        \t\telse:\n        \t\t\tdp[index_i][index_j] = False\n\n\n        return dp[len(s)][len(p)]\n        ",
        "output": "struct Solution;\n\nimpl Solution {\n    fn is_match(s: String, p: String) -> bool {\n        let n = s.len();\n        let m = p.len();\n        let s: Vec<char> = s.chars().collect();\n        let p: Vec<char> = p.chars().collect();\n        let mut memo: Vec<Vec<Option<bool>>> = vec![vec![None; m + 1]; n + 1];\n        Self::is_match_dp(n, m, &mut memo, &s, &p)\n    }\n\n    fn is_match_dp(\n        n: usize,\n        m: usize,\n        memo: &mut Vec<Vec<Option<bool>>>,\n        s: &[char],\n        p: &[char],\n    ) -> bool {\n        if let Some(ans) = memo[n][m] {\n            ans\n        } else {\n            let res = if n == 0 && m == 0 {\n                true\n            } else if n != 0 && m == 0 {\n                false\n            } else if n == 0 && m != 0 {\n                if p[m - 1] == '*' {\n                    Self::is_match_dp(n, m - 2, memo, s, p)\n                } else {\n                    false\n                }\n            } else {\n                if s[n - 1] == p[m - 1] {\n                    Self::is_match_dp(n - 1, m - 1, memo, s, p)\n                } else {\n                    match p[m - 1] {\n                        '*' => match p[m - 2] {\n                            '*' => false,\n                            '.' => {\n                                Self::is_match_dp(n - 1, m, memo, s, p)\n                                    || Self::is_match_dp(n, m - 2, memo, s, p)\n                            }\n                            _ => {\n                                if s[n - 1] != p[m - 2] {\n                                    Self::is_match_dp(n, m - 2, memo, s, p)\n                                } else {\n                                    Self::is_match_dp(n - 1, m, memo, s, p)\n                                        || Self::is_match_dp(n, m - 2, memo, s, p)\n                                }\n                            }\n                        },\n                        '.' => Self::is_match_dp(n - 1, m - 1, memo, s, p),\n                        _ => false,\n                    }\n                }\n            };\n\n            memo[n][m] = Some(res);\n            res\n        }\n    }\n}\n\n#[test]\nfn test() {\n    let s = \"aa\".to_string();\n    let p = \"a\".to_string();\n    let res = false;\n    assert_eq!(Solution::is_match(s, p), res);\n    let s = \"aa\".to_string();\n    let p = \"a*\".to_string();\n    let res = true;\n    assert_eq!(Solution::is_match(s, p), res);\n    let s = \"ab\".to_string();\n    let p = \".*\".to_string();\n    let res = true;\n    assert_eq!(Solution::is_match(s, p), res);\n    let s = \"aab\".to_string();\n    let p = \"c*a*b\".to_string();\n    let res = true;\n    assert_eq!(Solution::is_match(s, p), res);\n    let s = \"mississippi\".to_string();\n    let p = \"mis*is*p*.\".to_string();\n    let res = false;\n    assert_eq!(Solution::is_match(s, p), res);\n}\n"
    },
    {
        "input": "class Solution(object):\n    def setZeroes(self, matrix):\n        \n        col0 = 1\n        for row in range(len(matrix)):\n        \tif matrix[row][0] == 0:\n        \t\tcol0 = 0\n        \tfor col in range(1, len(matrix[0])):\n        \t\tif matrix[row][col] == 0:\n        \t\t\tmatrix[row][0] = 0\n        \t\t\tmatrix[0][col] = 0\n        for row in range(len(matrix)-1, -1, -1):\n        \tfor col in range(len(matrix[0])-1, 0, -1):\n        \t\tif matrix[row][0] == 0 or matrix[0][col] == 0:\n        \t\t\tmatrix[row][col] = 0\n        \tif col0 == 0:\n        \t\tmatrix[row][0] = 0\n\n",
        "output": "struct Solution;\nuse std::collections::HashSet;\n\nimpl Solution {\n    fn set_zeroes(matrix: &mut Vec<Vec<i32>>) {\n        let mut row: HashSet<usize> = HashSet::new();\n        let mut col: HashSet<usize> = HashSet::new();\n        let n = matrix.len();\n        let m = matrix[0].len();\n        for i in 0..n {\n            for j in 0..m {\n                if matrix[i][j] == 0 {\n                    row.insert(i);\n                    col.insert(j);\n                }\n            }\n        }\n        for i in 0..n {\n            for j in 0..m {\n                if row.contains(&i) || col.contains(&j) {\n                    matrix[i][j] = 0;\n                }\n            }\n        }\n    }\n}\n\n#[test]\nfn test() {\n    let mut matrix: Vec<Vec<i32>> = vec_vec_i32![[1, 1, 1], [1, 0, 1], [1, 1, 1]];\n    let res: Vec<Vec<i32>> = vec_vec_i32![[1, 0, 1], [0, 0, 0], [1, 0, 1]];\n    Solution::set_zeroes(&mut matrix);\n    assert_eq!(matrix, res);\n    let mut matrix: Vec<Vec<i32>> = vec_vec_i32![[0, 1, 2, 0], [3, 4, 5, 2], [1, 3, 1, 5]];\n    let res: Vec<Vec<i32>> = vec_vec_i32![[0, 0, 0, 0], [0, 4, 5, 0], [0, 3, 1, 0]];\n    Solution::set_zeroes(&mut matrix);\n    assert_eq!(matrix, res);\n}\n"
    },
    {
        "input": "\n\nclass Solution(object):\n\tdef __init__(self):\n\t\tself.cache = {}\n\n\tdef isScramble(self, s1, s2):\n\t\tif s1 == s2:\n\t\t\treturn True\n\t\tif s1+s2 in self.cache:\n\t\t\treturn self.cache[s1+s2]\n\t\tif len(s1) != len(s2) or sorted(s1) != sorted(s2):\n\t\t\tself.cache[s1+s2] = False\n\t\t\treturn False\n\t\tfor index in range(1, len(s1)):\n\t\t\tif self.isScramble(s1[:index], s2[:index]) and self.isScramble(s1[index:], s2[index:]):\n\t\t\t\tself.cache[s1+s2] =True\n\t\t\t\treturn True\n\t\t\tif self.isScramble(s1[:index], s2[-index:]) and self.isScramble(s1[index:], s2[0:-index]):\n\t\t\t\tself.cache[s1+s2] = True\n\t\t\t\treturn True\n\n\t\tself.cache[s1+s2] =False\n\t\treturn False  \t\t",
        "output": "struct Solution;\n\nuse std::collections::HashMap;\n\nimpl Solution {\n    fn is_scramble(s1: String, s2: String) -> bool {\n        let n = s1.len();\n        let mut memo: HashMap<(usize, usize, usize, usize), bool> = HashMap::new();\n        Self::dp(0, n, 0, n, &mut memo, &s1, &s2)\n    }\n    fn dp(\n        l_start: usize,\n        l_end: usize,\n        r_start: usize,\n        r_end: usize,\n        memo: &mut HashMap<(usize, usize, usize, usize), bool>,\n        s1: &str,\n        s2: &str,\n    ) -> bool {\n        if let Some(&res) = memo.get(&(l_start, l_end, r_start, r_end)) {\n            return res;\n        }\n        let res = if s1[l_start..l_end] == s2[r_start..r_end] {\n            true\n        } else {\n            let mut res = false;\n            let n = l_end - l_start;\n            for i in 1..n {\n                if Self::dp(l_start, l_start + i, r_start, r_start + i, memo, s1, s2)\n                    && Self::dp(l_start + i, l_end, r_start + i, r_end, memo, s1, s2)\n                    || Self::dp(l_start, l_start + i, r_end - i, r_end, memo, s1, s2)\n                        && Self::dp(l_start + i, l_end, r_start, r_end - i, memo, s1, s2)\n                {\n                    res = true;\n                    break;\n                }\n            }\n            res\n        };\n        memo.insert((l_start, l_end, r_start, r_end), res);\n        res\n    }\n}\n\n#[test]\nfn test() {\n    let s1 = \"great\".to_string();\n    let s2 = \"rgeat\".to_string();\n    let res = true;\n    assert_eq!(Solution::is_scramble(s1, s2), res);\n    let s1 = \"caebd\".to_string();\n    let s2 = \"rgeat\".to_string();\n    let res = false;\n    assert_eq!(Solution::is_scramble(s1, s2), res);\n}\n"
    },
    {
        "input": "\n\nclass Solution(object):\n    def findSubstring(self, s, words):\n        \n        if not str or not words:\n        \treturn []\n\n        counts = {}\n        for word in words:\n        \tif word in counts:\n        \t\tcounts[word] += 1\n        \telse:\n        \t\tcounts[word] = 1\n\n        result = []\n        n, numOfWords, fixLen = len(s), len(words),len(words[0])\n\n        for index in range(0, n-numOfWords*fixLen+1):\n        \tseen = {}\n\n        \tindex_j = 0\n        \twhile index_j < numOfWords:\n        \t\tword = s[index + index_j*fixLen: index + (index_j+1)*fixLen]\n        \t\tif word in counts:\n        \t\t\tif word in seen:\n        \t\t\t\tseen[word] += 1\n        \t\t\telse:\n        \t\t\t\tseen[word] = 1\n\n        \t\t\tif seen[word] > counts[word]:\n        \t\t\t\tbreak\n        \t\telse:\n        \t\t\tbreak\n        \t\tindex_j += 1\n\n        \tif index_j == numOfWords:\n        \t\tresult.append(index)\n\n    \treturn \n\n\n",
        "output": "struct Solution;\n\nuse std::collections::HashMap;\n\nimpl Solution {\n    fn find_substring(s: String, words: Vec<String>) -> Vec<i32> {\n        let n = s.len();\n        if n == 0 {\n            return vec![];\n        }\n        let mut count: HashMap<&str, usize> = HashMap::new();\n        let m = words.len();\n        if m == 0 {\n            return vec![];\n        }\n        let size = words[0].len();\n        if m * size > n {\n            return vec![];\n        }\n        for w in &words {\n            *count.entry(w).or_default() += 1;\n        }\n        let mut res = vec![];\n        'outer: for i in 0..=n - m * size {\n            let mut cur: HashMap<&str, usize> = HashMap::new();\n            for j in 0..m {\n                let w = &s[i + j * size..i + (j + 1) * size];\n                if let Some(x) = count.get(w) {\n                    let y = cur.entry(w).or_default();\n                    *y += 1;\n                    if *y > *x {\n                        continue 'outer;\n                    }\n                } else {\n                    continue 'outer;\n                }\n            }\n            res.push(i as i32);\n        }\n        res\n    }\n}\n\n#[test]\nfn test() {\n    let s = \"barfoothefoobarman\".to_string();\n    let words = vec_string![\"foo\", \"bar\"];\n    let res = vec![0, 9];\n    assert_eq!(Solution::find_substring(s, words), res);\n    let s = \"wordgoodgoodgoodbestword\".to_string();\n    let words = vec_string![\"word\", \"good\", \"best\", \"word\"];\n    let res: Vec<i32> = vec![];\n    assert_eq!(Solution::find_substring(s, words), res);\n    let s = \"wordgoodgoodgoodbestword\".to_string();\n    let words = vec_string![\"word\", \"good\", \"best\", \"good\"];\n    let res = vec![8];\n    assert_eq!(Solution::find_substring(s, words), res);\n}\n"
    },
    {
        "input": "\n\nclass Solution(object):\n    def combinationSum2(self, candidates, target):\n        \n        result = []\n        candidates.sort()\n\n        def recursive(candidates, target, currList, index):\n        \tif target < 0:\n        \t\treturn\n        \tif target == 0:\n        \t\tresult.append(currList)\n        \t\treturn\n\n        \tprevious = -1\n        \tfor start in range(index, len(candidates)):\n        \t\tif previous != candidates[start]:\n\t        \t\trecursive(candidates, target - candidates[start], currList + [candidates[start]], start+1)\n\t        \t\tprevious = candidates[start]\n\n\n        recursive(candidates, target, [], 0)\n        return result",
        "output": "struct Solution;\n\nimpl Solution {\n    fn combination_sum2(mut candidates: Vec<i32>, target: i32) -> Vec<Vec<i32>> {\n        let mut cur = vec![];\n        let mut res = vec![];\n        let n = candidates.len();\n        candidates.sort_unstable();\n        Self::dfs(0, target, &mut cur, &mut res, &candidates, n);\n        res\n    }\n    fn dfs(\n        start: usize,\n        target: i32,\n        cur: &mut Vec<i32>,\n        all: &mut Vec<Vec<i32>>,\n        candidates: &[i32],\n        n: usize,\n    ) {\n        use std::cmp::Ordering::*;\n        match target.cmp(&0) {\n            Equal => {\n                all.push(cur.to_vec());\n            }\n            Greater => {\n                for i in start..n {\n                    if i > start && candidates[i] == candidates[i - 1] {\n                        continue;\n                    }\n                    cur.push(candidates[i]);\n                    Self::dfs(i + 1, target - candidates[i], cur, all, candidates, n);\n                    cur.pop();\n                }\n            }\n            Less => {}\n        }\n    }\n}\n\n#[test]\nfn test() {\n    let candidates = vec![10, 1, 2, 7, 6, 1, 5];\n    let target = 8;\n    let mut res = vec_vec_i32![[1, 7], [1, 2, 5], [2, 6], [1, 1, 6]];\n    res.sort_unstable();\n    assert_eq!(Solution::combination_sum2(candidates, target), res);\n}\n"
    },
    {
        "input": "\n\n\n\n\n\n\n\n\nclass Solution(object):\n    def generateTrees(self, n):\n        \n        if n == 0:\n        \treturn []\n\n\n        def generate(start, end):\n        \tresult = []\n        \tif start > end:\n        \t\tresult.append(None)\n        \t\treturn result\n\n        \tfor index in range(start, end+1):\n        \t\tleft = generate(start, index-1)\n        \t\tright = generate(index+1, end)\n\n        \t\tfor l in left:\n        \t\t\tfor r in right:\n        \t\t\t\tcurrent = TreeNode(index)\n        \t\t\t\tcurrent.left = l\n        \t\t\t\tcurrent.right = r\n        \t\t\t\tresult.append(current)\n\n        \treturn result\n\n        return generate(1, n)",
        "output": "struct Solution;\nuse rustgym_util::*;\n\nimpl Solution {\n    fn generate_trees(n: i32) -> Vec<TreeLink> {\n        if n == 0 {\n            return vec![];\n        }\n        Self::generate(1, n)\n    }\n\n    fn generate(left: i32, right: i32) -> Vec<TreeLink> {\n        let mut res = vec![];\n        if left > right {\n            return vec![None];\n        }\n        if left == right {\n            return vec![tree!(left)];\n        }\n        for middle in left..=right {\n            for i in Self::generate(left, middle - 1) {\n                for j in Self::generate(middle + 1, right) {\n                    res.push(tree!(middle, i.clone(), j));\n                }\n            }\n        }\n        res\n    }\n}\n\n#[test]\nfn test() {\n    let n = 3;\n    let mut res = vec![\n        tree!(1, None, tree!(3, tree!(2), None)),\n        tree!(3, tree!(2, tree!(1), None), None),\n        tree!(3, tree!(1, None, tree!(2)), None),\n        tree!(2, tree!(1), tree!(3)),\n        tree!(1, None, tree!(2, None, tree!(3))),\n    ];\n    let mut ans = Solution::generate_trees(n);\n    ans.sort();\n    res.sort();\n    assert_eq!(ans, res);\n}\n"
    },
    {
        "input": "\n\nclass Solution(object):\n    def searchRange(self, nums, target):\n        \n        left, right = 0, len(nums)-1\n\n        while left <= right:\n        \tmid = (left + right) /  2\n        \tif target > nums[mid]:\n        \t\tleft = mid + 1\n        \telse:\n        \t\tright = mid\n\n        if left == len(nums) or nums[left] != target:\n        \treturn [-1, -1]\n\n        result = [left]\n        left, right = 0, len(nums) -1\n        while left <= right:\n        \tmid = (left + right) / 2\n        \tif nums[mid] > target:\n        \t\tright = mid\n        \telse:\n        \t\tleft = mid + 1\n\n        result.append(left + 1)\n        return result",
        "output": "struct Solution;\n\nimpl Solution {\n    fn search_range(nums: Vec<i32>, target: i32) -> Vec<i32> {\n        let n = nums.len();\n        match nums.binary_search(&target) {\n            Ok(i) => {\n                let mut l = i;\n                let mut r = i;\n                while l > 0 && nums[l - 1] == target {\n                    l -= 1;\n                }\n                while r + 1 < n && nums[r + 1] == target {\n                    r += 1;\n                }\n                vec![l as i32, r as i32]\n            }\n            Err(_) => vec![-1, -1],\n        }\n    }\n}\n\n#[test]\nfn test() {\n    let nums = vec![5, 7, 7, 8, 8, 10];\n    let target = 8;\n    let res = vec![3, 4];\n    assert_eq!(Solution::search_range(nums, target), res);\n}\n"
    },
    {
        "input": "\n\nclass Solution(object):\n    def spiralOrder(self, matrix):\n        \n        if not matrix:\n        \treturn []\n\n        R, C = len(matrix), len(matrix[0])\n        dr = [0, 1, 0, -1]\n        dc = [1, 0, -1, 0]\n\n        result = []\n        seen = [[False]*C for _ in range(R)]\n        row = 0\n        col = 0\n        di = 0\n        for _ in range(R*C):\n        \tresult.append(matrix[row][col])\n        \tseen[row][col] = True\n        \trr, cc = row + dr[di], col + dc[di]\n        \tif 0 <= rr < R and 0 <= cc < C and not seen[rr][cc]:\n        \t\trow, col = rr, cc\n        \telse:\n        \t\tdi = (di+1)%4\n        \t\trow, col = row + dr[di], col + dc[di]\n\n        return result",
        "output": "struct Solution;\n\nenum Direction {\n    Right,\n    Down,\n    Left,\n    Up,\n}\nimpl Solution {\n    fn spiral_order(matrix: Vec<Vec<i32>>) -> Vec<i32> {\n        let n = matrix.len();\n        if n == 0 {\n            return vec![];\n        }\n        let m = matrix[0].len();\n        if m == 0 {\n            return vec![];\n        }\n        let mut res: Vec<i32> = vec![];\n        let mut i = 0;\n        let mut j = 0;\n        let mut left = 0;\n        let mut top = 0;\n        let mut bottom = n - 1;\n        let mut right = m - 1;\n        let mut direction = Direction::Right;\n        loop {\n            res.push(matrix[i][j]);\n            match direction {\n                Direction::Right => {\n                    if j < right {\n                        j += 1;\n                    } else {\n                        if top < bottom {\n                            top += 1;\n                            direction = Direction::Down;\n                            i += 1;\n                        } else {\n                            break;\n                        }\n                    }\n                }\n                Direction::Down => {\n                    if i < bottom {\n                        i += 1;\n                    } else {\n                        if left < right {\n                            right -= 1;\n                            direction = Direction::Left;\n                            j -= 1;\n                        } else {\n                            break;\n                        }\n                    }\n                }\n                Direction::Left => {\n                    if j > left {\n                        j -= 1;\n                    } else {\n                        if top < bottom {\n                            bottom -= 1;\n                            direction = Direction::Up;\n                            i -= 1;\n                        } else {\n                            break;\n                        }\n                    }\n                }\n                Direction::Up => {\n                    if i > top {\n                        i -= 1;\n                    } else {\n                        if left < right {\n                            left += 1;\n                            direction = Direction::Right;\n                            j += 1;\n                        } else {\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n        res\n    }\n}\n\n#[test]\nfn test() {\n    let matrix: Vec<Vec<i32>> = vec_vec_i32![[1, 2, 3], [4, 5, 6], [7, 8, 9]];\n    let res = vec![1, 2, 3, 6, 9, 8, 7, 4, 5];\n    assert_eq!(Solution::spiral_order(matrix), res);\n    let matrix: Vec<Vec<i32>> = vec_vec_i32![[3], [2]];\n    let res = vec![3, 2];\n    assert_eq!(Solution::spiral_order(matrix), res);\n}\n"
    },
    {
        "input": "\n\n\n\n\n\n\n\nclass Solution(object):\n    def partition(self, head, x):\n        \n        if not head or not head.next:\n        \treturn head\n\n        left, right = ListNode(0), ListNode(0)\n        leftPtr, rightPtr = left, right\n\n        while head:\n        \tif head.val < x:\n        \t\tleftPtr.next = ListNode(head.val)\n        \t\tleftPtr = leftPtr.next\n        \telse:\n        \t\trightPtr.next = ListNode(head.val)\n        \t\trightPtr = rightPtr.next\n        \thead = head.next\n\n        if not left.next:\n        \treturn right.next\n        elif not right.next:\n        \treturn left.next\n        else:\n        \tleftPtr.next = right.next\n        \treturn left.next\n\n",
        "output": "struct Solution;\nuse rustgym_util::*;\n\nimpl Solution {\n    fn partition(mut head: ListLink, x: i32) -> ListLink {\n        let mut left: Vec<i32> = vec![];\n        let mut right: Vec<i32> = vec![];\n        while let Some(node) = head {\n            let val = node.val;\n            if val < x {\n                left.push(val);\n            } else {\n                right.push(val);\n            }\n            head = node.next;\n        }\n        let mut res = None;\n        while let Some(val) = right.pop() {\n            res = ListLink::link(val, res);\n        }\n        while let Some(val) = left.pop() {\n            res = ListLink::link(val, res);\n        }\n        res\n    }\n}\n\n#[test]\nfn test() {\n    let head = list!(1, 4, 3, 2, 5, 2);\n    let x = 3;\n    let res = list!(1, 2, 2, 4, 3, 5);\n    assert_eq!(Solution::partition(head, x), res);\n}\n"
    },
    {
        "input": "\n\nclass Solution(object):\n    def maxArea(self, height):\n        \n        left, right, maxArea = 0, len(height) - 1, 0 \n\n        while left < right:\n        \tmaxArea = max(maxArea, min(height[left], height[right])*(right-left))\n        \tif height[left] < height[right]:\n        \t\tleft += 1\n        \telse:\n        \t\tright -= 1\n\n        return maxArea \n\n\n",
        "output": "struct Solution;\n\nimpl Solution {\n    fn max_area(height: Vec<i32>) -> i32 {\n        let mut max = 0;\n        let mut l = 0;\n        let mut r = height.len() - 1;\n        while l < r {\n            max = i32::max(i32::min(height[l], height[r]) * (r - l) as i32, max);\n            if height[l] < height[r] {\n                l += 1;\n            } else {\n                r -= 1;\n            }\n        }\n        max\n    }\n}\n\n#[test]\nfn test() {\n    let height = vec![1, 8, 6, 2, 5, 4, 8, 3, 7];\n    assert_eq!(Solution::max_area(height), 49);\n}\n"
    },
    {
        "input": "\n\nclass Solution(object):\n    def uniquePaths(self, m, n):\n        \n        dp = [[0 for _ in range(n)] for _ in range(m)]\n        for index in range(m):\n        \tdp[index][0] = 1\n\n        for index in range(n):\n        \tdp[0][index] = 1\n\n        for index_i in range(1, m):\n        \tfor index_j in range(1, n):\n        \t\tdp[index_i][index_j] = dp[index_i-1][index_j] + dp[index_i][index_j-1]\n\n        return dp[m-1][n-1]",
        "output": "struct Solution;\n\nimpl Solution {\n    fn unique_paths(m: i32, n: i32) -> i32 {\n        let m = m as usize;\n        let n = n as usize;\n        let mut a = vec![vec![0; m + 1]; n + 1];\n        for i in 1..=n {\n            for j in 1..=m {\n                if i == 1 && j == 1 {\n                    a[i][j] = 1;\n                } else {\n                    a[i][j] = a[i - 1][j] + a[i][j - 1];\n                }\n            }\n        }\n        a[n][m]\n    }\n}\n\n#[test]\nfn test() {\n    let m = 3;\n    let n = 2;\n    let res = 3;\n    assert_eq!(Solution::unique_paths(m, n), res);\n    let m = 7;\n    let n = 3;\n    let res = 28;\n    assert_eq!(Solution::unique_paths(m, n), res);\n}\n"
    },
    {
        "input": "\n\n\n\n\n\n\n\nclass Solution(object):\n    def deleteDuplicates(self, head):\n        \n        if not head:\n        \treturn None\n\n        curr = head\n        while curr and curr.next:\n        \tif curr.val == curr.next.val:\n        \t\tcurr.next = curr.next.next\n        \telse:\n\t        \tcurr = curr.next\n\n        return head",
        "output": "struct Solution;\nuse rustgym_util::*;\n\nimpl Solution {\n    fn delete_duplicates(mut head: ListLink) -> ListLink {\n        let mut p = head.as_mut();\n        while let Some(n) = p {\n            while let Some(m) = n.next.as_mut() {\n                if m.val != n.val {\n                    break;\n                }\n                n.next = m.next.take();\n            }\n            p = n.next.as_mut();\n        }\n        head\n    }\n}\n\n#[test]\nfn test() {\n    let p = list!(1, 1, 2, 3, 3);\n    let q = list!(1, 2, 3);\n    assert_eq!(Solution::delete_duplicates(p), q);\n}\n"
    },
    {
        "input": "\n\nclass Solution(object):\n    def trap(self, height):\n        \n        if not height:\n        \treturn 0\n\n        left, right = 0, len(height) - 1\n        leftMax, rightMax = 0, 0\n        result = 0\n        while left < right:\n        \tif height[left] < height[right]:\n        \t\tif height[left] > leftMax:\n        \t\t\tleftMax = height[left]\n        \t\telse:\n        \t\t\tresult += (leftMax - height[left])\n        \t\tleft += 1\n        \telse:\n        \t\tif height[right] > rightMax:\n        \t\t\trightMax = height[right]\n        \t\telse:\n        \t\t\tresult += (rightMax - height[right])\n        \t\tright -= 1\n\n        return result ",
        "output": "struct Solution;\n\nimpl Solution {\n    fn trap(height: Vec<i32>) -> i32 {\n        let n = height.len();\n        if n == 0 {\n            return 0;\n        }\n        let mut l = 0;\n        let mut r = n - 1;\n        let mut level = 0;\n        let mut res = 0;\n        while l < r {\n            if height[l] < height[r] {\n                let lower = height[l];\n                level = level.max(lower);\n                res += level - lower;\n                l += 1;\n            } else {\n                let lower = height[r];\n                level = level.max(lower);\n                res += level - lower;\n                r -= 1;\n            }\n        }\n        res\n    }\n}\n\n#[test]\nfn test() {\n    let height = vec![0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1];\n    let res = 6;\n    assert_eq!(Solution::trap(height), res);\n}\n"
    },
    {
        "input": "\n\nclass Solution(object):\n    def countAndSay(self, n):\n        \n        \n        if n == 1:\n        \treturn \"1\"\n        new_num = \"\"\n        count_iter = 1\n        num = \"1\"\n\n        while count_iter < n:  \n        \tindex_i, index_j = 0, 0\n        \tcount, new_num = 0, \"\"\n\n        \twhile index_j < len(num):\n        \t\tif num[index_i] != num[index_j]:\n        \t\t\tnew_num += str(count) + str(num[index_i])\n        \t\t\tcount = 0\n        \t\t\tindex_i = index_j\n        \t\telse:\n        \t\t\tcount += 1\n        \t\t\tindex_j += 1\n\n        \tif count > 0:\n        \t\tnew_num += str(count) + str(num[index_i])\n        \tnum = new_num\n        \tcount_iter += 1\n\n        return new_num\n\n\n",
        "output": "struct Solution;\n\nstruct Pair {\n    digit: char,\n    count: usize,\n}\n\nimpl Solution {\n    fn next(nums: String) -> String {\n        let mut prev: Option<Pair> = None;\n        let mut s = String::from(\"\");\n        for c in nums.chars() {\n            if let Some(prev_pair) = prev {\n                if prev_pair.digit == c {\n                    prev = Some(Pair {\n                        digit: c,\n                        count: prev_pair.count + 1,\n                    });\n                } else {\n                    s.push_str(&prev_pair.count.to_string());\n                    s.push_str(&prev_pair.digit.to_string());\n                    prev = Some(Pair { digit: c, count: 1 });\n                }\n            } else {\n                prev = Some(Pair { digit: c, count: 1 });\n            }\n        }\n        if let Some(prev_pair) = prev {\n            s.push_str(&prev_pair.count.to_string());\n            s.push_str(&prev_pair.digit.to_string());\n        }\n        s\n    }\n\n    fn count_and_say(n: i32) -> String {\n        match n {\n            1 => String::from(\"1\"),\n            2..=30 => Self::next(Solution::count_and_say(n - 1)),\n            _ => String::from(\"\"),\n        }\n    }\n}\n\n#[test]\nfn test() {\n    assert_eq!(Solution::count_and_say(4), String::from(\"1211\"));\n    assert_eq!(Solution::count_and_say(1), String::from(\"1\"));\n}\n"
    },
    {
        "input": "\n\nclass Solution(object):\n    def removeDuplicates(self, nums):\n        \n        if len(nums) <= 2:\n        \treturn len(nums)\n\n        prev, curr = 1, 2\n\n        while curr < len(nums):\n        \tif nums[prev] == nums[curr] and nums[curr] == nums[prev-1]:\n        \t\tcurr += 1\n        \telse:\n        \t\tprev += 1\n        \t\tnums[prev] = nums[curr]\n        \t\tcurr += 1\n        return prev+1\n",
        "output": "struct Solution;\n\nimpl Solution {\n    fn remove_duplicates(nums: &mut Vec<i32>) -> i32 {\n        let n = nums.len();\n        let mut m = 0;\n        let mut prev: Option<(i32, usize)> = None;\n        for i in 0..n {\n            if let Some((value, count)) = prev {\n                if value == nums[i] {\n                    if count == 1 {\n                        prev = Some((nums[i], 2));\n                        nums[m] = nums[i];\n                        m += 1;\n                    }\n                } else {\n                    prev = Some((nums[i], 1));\n                    nums[m] = nums[i];\n                    m += 1;\n                }\n            } else {\n                prev = Some((nums[i], 1));\n                nums[m] = nums[i];\n                m += 1;\n            }\n        }\n        m as i32\n    }\n}\n\n#[test]\nfn test() {\n    let mut nums = vec![1, 1, 1, 2, 2, 3];\n    let res = 5;\n    assert_eq!(Solution::remove_duplicates(&mut nums), res);\n}\n"
    },
    {
        "input": "\nclass Solution(object):\n    def rotate(self, matrix):\n        \n        n = len(matrix)\n        if n%2 == 0:\n        \tm = n/2\n        else:\n        \tm = n/2 + 1\n\n        for i in range(n/2):\n        \tfor j in range(m):\n        \t\ttemp = matrix[i][j]\n        \t\tmatrix[i][j] = matrix[n-j-1][i]\n        \t\tmatrix[n-j-1][i] = matrix[n-i-1][n-j-1]\n        \t\tmatrix[n-i-1][n-j-1] = matrix[j][n-i-1]\n        \t\tmatrix[j][n-i-1] = temp\n",
        "output": "struct Solution;\n\nimpl Solution {\n    fn rotate(matrix: &mut Vec<Vec<i32>>) {\n        matrix.reverse();\n        let n = matrix.len();\n        for i in 0..n {\n            for j in i + 1..n {\n                let a = matrix[i][j];\n                let b = matrix[j][i];\n                matrix[i][j] = b;\n                matrix[j][i] = a;\n            }\n        }\n    }\n}\n\n#[test]\nfn test() {\n    let mut matrix: Vec<Vec<i32>> = vec_vec_i32![[1, 2, 3], [4, 5, 6], [7, 8, 9]];\n    let res: Vec<Vec<i32>> = vec_vec_i32![[7, 4, 1], [8, 5, 2], [9, 6, 3]];\n    Solution::rotate(&mut matrix);\n    assert_eq!(matrix, res);\n}\n"
    },
    {
        "input": "\n\nclass Solution(object):\n    def maxSubArray(self, nums):\n        \n        if not nums:\n        \treturn 0\n\n        currSum, result = nums[0], nums[0]\n\n        for index in range(1, len(nums)):\n        \tcurrSum = max(nums[index], currSum+nums[index])\n        \tresult = max(result, currSum)\n\n        return result",
        "output": "struct Solution;\n\nimpl Solution {\n    fn max_sub_array(nums: Vec<i32>) -> i32 {\n        let mut prev = 0;\n        let mut max = std::i32::MIN;\n        let n = nums.len();\n        for i in 0..n {\n            prev = nums[i].max(prev + nums[i]);\n            max = max.max(prev);\n        }\n        max\n    }\n}\n\n#[test]\nfn test() {\n    let nums = vec![-2, 1, -3, 4, -1, 2, 1, -5, 4];\n    assert_eq!(Solution::max_sub_array(nums), 6);\n    let nums = vec![-1];\n    assert_eq!(Solution::max_sub_array(nums), -1);\n    let nums = vec![1];\n    assert_eq!(Solution::max_sub_array(nums), 1);\n}\n"
    },
    {
        "input": "\nclass Solution(object):\n    def sortColors(self, nums):\n        \n        zero, last = 0, len(nums)-1\n        index = 0\n        while  index <= last:\n        \tif nums[index] == 1:\n        \t\tindex += 1\n        \telif nums[index] == 0:\n        \t\tnums[index], nums[zero] = nums[zero], nums[index]\n        \t\tindex += 1\n        \t\tzero += 1\n        \telif nums[index] == 2:\n        \t\tnums[last], nums[index] = nums[index], nums[last]\n        \t\tlast -= 1",
        "output": "struct Solution;\n\nimpl Solution {\n    fn sort_colors(nums: &mut Vec<i32>) {\n        let n = nums.len();\n        let mut l = 0;\n        let mut r = n - 1;\n        let mut i = 0;\n        while i <= r {\n            while nums[i] == 2 && i < r {\n                nums.swap(i, r);\n                r -= 1;\n            }\n            while nums[i] == 0 && i > l {\n                nums.swap(i, l);\n                l += 1;\n            }\n            i += 1;\n        }\n    }\n}\n\n#[test]\nfn test() {\n    let mut nums = vec![2, 0, 2, 1, 1, 0];\n    let res = vec![0, 0, 1, 1, 2, 2];\n    Solution::sort_colors(&mut nums);\n    assert_eq!(nums, res);\n}\n"
    },
    {
        "input": "\n\nclass Solution(object):\n    def simplifyPath(self, path):\n        \n\n        result = \"/\"\n        stack = []\n\n        index = 0\n        while index < len(path):\n        \tif path[index] == '/':\n        \t\tindex += 1\n        \t\tcontinue\n\n\n        \tcurr_str = \"\"\n        \twhile index < len(path) and path[index] != '/':\n        \t\tcurr_str += path[index]\n        \t\tindex += 1\n\n        \tif curr_str == '.' or curr_str == \"\":\n        \t\tindex += 1\n        \t\tcontinue\n        \telif curr_str == \"..\":\n        \t\tif stack:\n\t        \t\tstack.pop()\n        \t\tindex += 1\n        \telse:\n        \t\tstack.append(curr_str)\n        \t\tindex += 1\n\n        for index in range(len(stack)):\n        \tif index != len(stack) -1:\n        \t\tresult += stack[index] + '/'\n        \telse:\n        \t\tresult += stack[index]\n\n        return result\n\n\n",
        "output": "struct Solution;\n\nimpl Solution {\n    fn simplify_path(path: String) -> String {\n        let mut stack: Vec<&str> = vec![];\n        let mut res = \"\".to_string();\n        for s in path.split_terminator('/') {\n            match s {\n                \"..\" => {\n                    stack.pop();\n                }\n                \"\" | \".\" => {\n                    continue;\n                }\n                _ => {\n                    stack.push(s);\n                }\n            }\n        }\n        for s in stack {\n            res += \"/\";\n            res += s;\n        }\n        if res.is_empty() {\n            res += \"/\";\n        }\n        res\n    }\n}\n\n#[test]\nfn test() {\n    let path = \"/home/\".to_string();\n    let res = \"/home\".to_string();\n    assert_eq!(Solution::simplify_path(path), res);\n    let path = \"/../\".to_string();\n    let res = \"/\".to_string();\n    assert_eq!(Solution::simplify_path(path), res);\n    let path = \"/home\n    let res = \"/home/foo\".to_string();\n    assert_eq!(Solution::simplify_path(path), res);\n    let path = \"/a/./b/../../c/\".to_string();\n    let res = \"/c\".to_string();\n    assert_eq!(Solution::simplify_path(path), res);\n    let path = \"/a/../../b/../c\n    let res = \"/c\".to_string();\n    assert_eq!(Solution::simplify_path(path), res);\n    let path = \"/a\n    let res = \"/a/b/c\".to_string();\n    assert_eq!(Solution::simplify_path(path), res);\n}\n"
    },
    {
        "input": "\n\nclass Solution(object):\n    def search(self, nums, target):\n        \n        if not nums:\n        \treturn -1\n\n        left, right = 0, len(nums) - 1\n\n        while left <= right:\n        \tmid = (left + right) / 2\n        \tif nums[mid] == target:\n        \t\treturn mid\n\n        \tif nums[left] <= nums[mid]:\n        \t\tif target >= nums[left] and target <= nums[mid]:\n        \t\t\tright = mid - 1\n        \t\telse:\n        \t\t\tleft = mid + 1\n        \telse:\n        \t\tif target >= nums[mid] and target <= nums[right]:\n        \t\t\tleft = mid + 1\n        \t\telse:\n        \t\t\tright = mid - 1\n\n        return -1\n\n\nclass Solution(object):\n    def search(self, nums, target):\n        \n\n        def searchRecursive(nums, left, right, target):\n        \tif left > right:\n        \t\treturn -1\n\n        \tmid = (left + right) / 2\n        \tif nums[mid] == target:\n        \t\treturn mid\n\n        \tif nums[left] <= nums[mid]:\n        \t\tif nums[left] <= target < nums[mid]:\n        \t\t\treturn searchRecursive(nums, left, mid-1, target)\n        \t\telse:\n        \t\t\treturn searchRecursive(nums, mid+1, right, target)\n        \telse:\n        \t\tif nums[mid] < target <= nums[right]:\n        \t\t\treturn searchRecursive(nums, mid+1, right, target)\n        \t\telse:\n        \t\t\treturn searchRecursive(nums, left, mid-1, target)\n\n        return searchRecursive(nums, 0, len(nums)-1, target)",
        "output": "struct Solution;\n\nimpl Solution {\n    fn search(nums: Vec<i32>, target: i32) -> i32 {\n        let n = nums.len();\n        let mut l: i32 = 0;\n        let mut r: i32 = n as i32 - 1;\n        while l <= r {\n            let m = (l + r) / 2;\n            if target == nums[m as usize] {\n                return m as i32;\n            } else if nums[l as usize] <= nums[m as usize] {\n                if nums[l as usize] <= target && target <= nums[m as usize] {\n                    r = m - 1;\n                } else {\n                    l = m + 1;\n                }\n            } else {\n                if nums[m as usize] <= target && target <= nums[r as usize] {\n                    l = m + 1;\n                } else {\n                    r = m - 1;\n                }\n            }\n        }\n        -1\n    }\n}\n\n#[test]\nfn test() {\n    let nums = vec![4, 5, 6, 7, 0, 1, 2];\n    let target = 0;\n    assert_eq!(Solution::search(nums, target), 4);\n    let nums = vec![4, 5, 6, 7, 0, 1, 2];\n    let target = 3;\n    assert_eq!(Solution::search(nums, target), -1);\n    let nums = vec![3, 5, 1];\n    let target = 3;\n    assert_eq!(Solution::search(nums, target), 0);\n    let nums = vec![4, 5, 6, 7, 8, 1, 2, 3];\n    let target = 8;\n    assert_eq!(Solution::search(nums, target), 4);\n}\n"
    },
    {
        "input": "\n\nclass Solution(object):\n    def fourSum(self, nums, target):\n        \n        \n        sumMapping = {}\n        for index_i in range(len(nums)-1):\n        \tfor index_j in range(index_i+1, len(nums)):\n        \t\tcurrSum = nums[index_i] + nums[index_j]\n        \t\tif currSum in sumMapping:\n        \t\t\tsumMapping[currSum].append((index_i, index_j))\n        \t\telse:\n        \t\t\tsumMapping[currSum] = [(index_i, index_j)]\n\n        result = set()\n        for key, value in sumMapping.iteritems():\n        \tdiff = target - key\n        \tif diff in sumMapping:\n        \t\tfirstSet = value\n        \t\tsecondSet = sumMapping[diff]\n\n        \t\tfor (i, j) in firstSet:\n        \t\t\tfor (k, l) in secondSet:\n        \t\t\t\tfourlet = [i, j, k, l]\n        \t\t\t\tif len(set(fourlet)) != len(fourlet):\n        \t\t\t\t\tcontinue\n        \t\t\t\tfourlist = [nums[i], nums[j], nums[k], nums[l]]\n        \t\t\t\tfourlist.sort()\n        \t\t\t\tresult.add(tuple(fourlist))\n\n        return list(result)\n\n\n\n\n",
        "output": "struct Solution;\nuse std::cmp::Ordering::*;\n\nimpl Solution {\n    fn four_sum(mut nums: Vec<i32>, target: i32) -> Vec<Vec<i32>> {\n        let n = nums.len();\n        let mut res = vec![];\n        nums.sort_unstable();\n        let mut i = 0;\n        while i + 3 < n {\n            if i > 0 && nums[i - 1] == nums[i] {\n                i += 1;\n                continue;\n            }\n            if nums[i] + nums[i + 1] + nums[i + 2] + nums[i + 3] > target {\n                break;\n            }\n            if nums[n - 3] + nums[n - 2] + nums[n - 1] + nums[i] < target {\n                i += 1;\n                continue;\n            }\n            let mut j = i + 1;\n            while j + 2 < n {\n                if j > i + 1 && nums[j - 1] == nums[j] {\n                    j += 1;\n                    continue;\n                }\n                if nums[i] + nums[j] + nums[j + 1] + nums[j + 2] > target {\n                    break;\n                }\n                if nums[n - 2] + nums[n - 1] + nums[i] + nums[j] < target {\n                    j += 1;\n                    continue;\n                }\n                let sum2 = nums[i] + nums[j];\n                let mut l = j + 1;\n                let mut r = n - 1;\n                while l < r {\n                    let sum4 = sum2 + nums[l] + nums[r];\n                    match sum4.cmp(&target) {\n                        Less => {\n                            l += 1;\n                        }\n                        Greater => {\n                            r -= 1;\n                        }\n                        Equal => {\n                            res.push(vec![nums[i], nums[j], nums[l], nums[r]]);\n                            l += 1;\n                            r -= 1;\n                            while l < r && nums[l - 1] == nums[l] {\n                                l += 1;\n                            }\n                            while l < r && nums[r] == nums[r + 1] {\n                                r -= 1;\n                            }\n                        }\n                    }\n                }\n                j += 1\n            }\n            i += 1\n        }\n        res\n    }\n}\n\n#[test]\nfn test() {\n    let nums = vec![1, 0, -1, 0, -2, 2];\n    let target = 0;\n    let mut ans: Vec<Vec<i32>> = vec_vec_i32![[-1, 0, 0, 1], [-2, -1, 1, 2], [-2, 0, 0, 2]];\n    let mut res = Solution::four_sum(nums, target);\n    res.sort_unstable();\n    ans.sort_unstable();\n    assert_eq!(ans, res);\n}\n"
    },
    {
        "input": "\n\nclass Solution(object):\n    def letterCombinations(self, digits):\n        \n        \n        phoneMap = { '2': 'abc', '3': 'def', '4': 'ghi', '5': 'jkl', '6': 'mno', '7' : 'pqrs', '8': 'tuv', '9':'wxyz'}\n        number = str(digits)\n\n        if number == \"\":\n        \treturn []\n\n        result = ['']\n        for char in number:\n        \tvalues = phoneMap[char]\n        \tnew_result = []\n        \tfor prefix in result:\n        \t\tcurrElement = prefix\n        \t\tfor value in values:\n        \t\t\tnew_result.append(currElement+value)\n\n        \tresult = new_result\n        \t\n        return result\n\nprint Solution().letterCombinations(\"23\")",
        "output": "struct Solution;\n\nuse std::collections::HashMap;\n\nimpl Solution {\n    fn dfs(\n        hm: &HashMap<char, Vec<char>>,\n        digits: &[char],\n        s: &mut Vec<char>,\n        res: &mut Vec<String>,\n        index: usize,\n    ) {\n        if index == digits.len() {\n            res.push(s.iter().collect());\n        } else {\n            let d = digits[index];\n            for &c in hm[&d].iter() {\n                s.push(c);\n                Self::dfs(hm, digits, s, res, index + 1);\n                s.pop();\n            }\n        }\n    }\n    fn letter_combinations(digits: String) -> Vec<String> {\n        if digits.is_empty() {\n            return vec![];\n        }\n        let digits: Vec<char> = digits.chars().collect();\n        let hm: HashMap<char, Vec<char>> = [\n            ('2', \"abc\"),\n            ('3', \"def\"),\n            ('4', \"ghi\"),\n            ('5', \"jkl\"),\n            ('6', \"mno\"),\n            ('7', \"pqrs\"),\n            ('8', \"tuv\"),\n            ('9', \"wxyz\"),\n        ]\n        .iter()\n        .map(|(d, v)| (*d, v.chars().collect()))\n        .collect();\n        let mut s: Vec<char> = vec![];\n        let mut res: Vec<String> = vec![];\n        Self::dfs(&hm, &digits, &mut s, &mut res, 0);\n        res\n    }\n}\n\n#[test]\nfn test() {\n    let digits = \"23\".to_string();\n    let res: Vec<String> = vec_string![\"ad\", \"ae\", \"af\", \"bd\", \"be\", \"bf\", \"cd\", \"ce\", \"cf\"];\n    assert_eq!(Solution::letter_combinations(digits), res);\n}\n"
    },
    {
        "input": "\n\n\n\n\n\n\n\nclass compare(object):\n\tdef __init__(self, interval):\n\t\tself.interval = interval\n\n\tdef __lt__(self, other):\n\t\tif self.interval.start == other.interval.start:\n\t\t\treturn self.interval.end < other.interval.end\n\t\treturn self.interval.start < other.interval.end\n\nclass Solution(object):\n    def merge(self, intervals):\n        \n        \n        intervals = sorted(intervals, key= compare)\n        \n        merged = []\n        for interval in intervals:\n        \tif not merged or merged[-1].end < interval.start:\n        \t\tmerged.append(interval)\n        \telse:\n        \t\tmerged[-1].end = max(merged[-1].end, interval.end)\n        return merged\n\n\n",
        "output": "struct Solution;\n\nimpl Solution {\n    fn merge(mut intervals: Vec<Vec<i32>>) -> Vec<Vec<i32>> {\n        intervals.sort_unstable_by(|a, b| a[0].cmp(&b[0]));\n        let mut res: Vec<Vec<i32>> = vec![];\n        let mut temp: Option<Vec<i32>> = None;\n        for v in intervals {\n            if let Some(t) = temp.clone() {\n                if v[0] <= t[1] {\n                    temp = Some(vec![t[0], i32::max(t[1], v[1])]);\n                } else {\n                    temp = Some(v);\n                    res.push(t);\n                }\n            } else {\n                temp = Some(v);\n            }\n        }\n        if let Some(t) = temp {\n            res.push(t);\n        }\n        res\n    }\n}\n\n#[test]\nfn test() {\n    let intervals: Vec<Vec<i32>> = vec_vec_i32![[1, 3], [2, 6], [8, 10], [15, 18]];\n    let res: Vec<Vec<i32>> = vec_vec_i32![[1, 6], [8, 10], [15, 18]];\n    assert_eq!(Solution::merge(intervals), res);\n    let intervals: Vec<Vec<i32>> = vec_vec_i32![[1, 4], [4, 5]];\n    let res: Vec<Vec<i32>> = vec_vec_i32![[1, 5]];\n    assert_eq!(Solution::merge(intervals), res);\n}\n"
    },
    {
        "input": "\n\nclass Solution(object):\n    def combinationSum(self, candidates, target):\n          \n\n        result = []\n\n        def recursive(candidates, target, currList, index):\n        \tif target < 0:\n        \t\treturn\n        \tif target == 0:\n        \t\tresult.append(currList)\n        \t\treturn\n\n        \tfor start in range(index, len(candidates)):\n        \t\trecursive(candidates, target - candidates[start], currList + [candidates[start]], start)\n\n        recursive(candidates, target, [], 0)\n        return result\n",
        "output": "struct Solution;\n\nimpl Solution {\n    fn combination_sum(mut candidates: Vec<i32>, target: i32) -> Vec<Vec<i32>> {\n        let n = candidates.len();\n        candidates.sort_unstable();\n        let mut combination: Vec<i32> = vec![];\n        let mut res: Vec<Vec<i32>> = vec![];\n        Self::backtrack(0, target, &mut combination, &mut res, &candidates, n);\n        res\n    }\n    fn backtrack(\n        start: usize,\n        target: i32,\n        combination: &mut Vec<i32>,\n        all: &mut Vec<Vec<i32>>,\n        candidates: &[i32],\n        n: usize,\n    ) {\n        if target == 0 {\n            all.push(combination.to_vec());\n        } else {\n            for i in start..n {\n                if candidates[i] > target {\n                    break;\n                } else {\n                    combination.push(candidates[i]);\n                    Self::backtrack(i, target - candidates[i], combination, all, candidates, n);\n                    combination.pop();\n                }\n            }\n        }\n    }\n}\n\n#[test]\nfn test() {\n    let candidates = vec![2, 3, 6, 7];\n    let target = 7;\n    let res = vec![vec![2, 2, 3], vec![7]];\n    assert_eq!(Solution::combination_sum(candidates, target), res);\n    let candidates = vec![2, 3, 5];\n    let target = 8;\n    let res = vec![vec![2, 2, 2, 2], vec![2, 3, 3], vec![3, 5]];\n    assert_eq!(Solution::combination_sum(candidates, target), res);\n}\n"
    },
    {
        "input": "\n\nclass Solution(object):\n    def findMedianSortedArrays(self, nums1, nums2):\n        \n        \n        if len(nums1) > len(nums2):\n        \tnums1, nums2 = nums2, nums1\n\n        x, y = len(nums1), len(nums2)\n        low , high = 0, x\n\n        while  low <= high:\n        \tpartitionx = (low+high)/2\n        \tpartitiony = (x+y+1)/2 - partitionx\n        \tif partitionx == 0:\n        \t\tmaxLeftX = float('-inf')\n        \telse:\n\t        \tmaxLeftX = nums1[partitionx-1]\n\n\t        if partitionx == x:\n\t        \tminRightX = float('inf')\n\t        else:\n\t        \tminRightX = nums1[partitionx]\n\n\t        if partitiony == 0:\n\t        \tmaxLeftY = float('-inf')\n\t        else:\n\t        \tmaxLeftY = nums2[partitiony-1]\n\n\t        if partitiony == y:\n\t        \tminRightY = float('inf')\n\t        else:\n\t        \tminRightY = nums2[partitiony]\n\n\t        if maxLeftX <= minRightY and maxLeftY <= minRightX:\n\t        \tif((x+y)%2 == 0):\n\t        \t\treturn (max(maxLeftX, maxLeftY) + min(minRightX, minRightY))/2.0\n\t        \telse:\n\t        \t\treturn max(maxLeftY, maxLeftX)\n\t        elif maxLeftX > minRightY:\n\t        \thigh = partitionx - 1\n\t        else:\n\t        \tlow = partitionx + 1\n\n\nprint Solution().findMedianSortedArrays([1,2], [3, 4])",
        "output": "struct Solution;\n\nimpl Solution {\n    fn find_median_sorted_arrays(nums1: Vec<i32>, nums2: Vec<i32>) -> f64 {\n        let n1 = nums1.len();\n        let n2 = nums2.len();\n        if n1 < n2 {\n            return Self::find_median_sorted_arrays(nums2, nums1);\n        }\n        let mut lo = 0;\n        let mut hi = n2 * 2;\n        while lo <= hi {\n            let mid2 = (lo + hi) / 2;\n            let mid1 = n1 + n2 - mid2;\n            let l1 = if mid1 == 0 {\n                std::i32::MIN\n            } else {\n                nums1[(mid1 - 1) / 2]\n            };\n            let l2 = if mid2 == 0 {\n                std::i32::MIN\n            } else {\n                nums2[(mid2 - 1) / 2]\n            };\n            let r1 = if mid1 == n1 * 2 {\n                std::i32::MAX\n            } else {\n                nums1[mid1 / 2]\n            };\n            let r2 = if mid2 == n2 * 2 {\n                std::i32::MAX\n            } else {\n                nums2[mid2 / 2]\n            };\n\n            if l1 > r2 {\n                lo = mid2 + 1;\n            } else if l2 > r1 {\n                hi = mid2 - 1;\n            } else {\n                return (l1.max(l2) + r1.min(r2)) as f64 / 2.0;\n            }\n        }\n        panic!()\n    }\n}\n\n#[test]\nfn test() {\n    use assert_approx_eq::assert_approx_eq;\n    let nums1 = vec![1, 3];\n    let nums2 = vec![2];\n    let res = 2.0;\n    assert_approx_eq!(Solution::find_median_sorted_arrays(nums1, nums2), res);\n    let nums1 = vec![1, 2];\n    let nums2 = vec![3, 4];\n    let res = 2.5;\n    assert_approx_eq!(Solution::find_median_sorted_arrays(nums1, nums2), res);\n    let nums1 = vec![1];\n    let nums2 = vec![2, 3];\n    let res = 2.0;\n    assert_approx_eq!(Solution::find_median_sorted_arrays(nums1, nums2), res);\n}\n"
    },
    {
        "input": "\n\nclass Solution(object):\n    def exist(self, board, word):\n        \n\n        result = False\n        for row in range(len(board)):\n        \tfor col in range(len(board[0])):\n        \t\tif self.dfs(board, word, row, col, 0):\n        \t\t\treturn True\n        return False\n\n    def dfs(self, board, word, row, col, curr_len):\n    \tif row < 0 or col < 0 or row >= len(board) or col >= len(board[0]):\n    \t\treturn False\n    \tif board[row][col] == word[curr_len]:\n    \t\tc = board[row][col]\n    \t\tboard[row][col] = '\n\n    \t\tif curr_len == len(word) - 1:\n    \t\t\treturn True\n    \t\telif (self.dfs(board, word, row-1, col, curr_len+1) or self.dfs(board, word, row+1, col, curr_len+1) or self.dfs(board, word, row, col-1, curr_len+1) or self.dfs(board, word, row, col+1, curr_len+1)):\n    \t\t\treturn True\n\n    \t\tboard[row][col] = c\n    \treturn False",
        "output": "struct Solution;\n\nimpl Solution {\n    fn exist(board: Vec<Vec<char>>, word: String) -> bool {\n        if let Some(mut word_search) = WordSearch::new(board, word) {\n            word_search.exist()\n        } else {\n            false\n        }\n    }\n}\n\n#[derive(Debug)]\nstruct WordSearch {\n    n: usize,\n    m: usize,\n    visited: Vec<Vec<bool>>,\n    board: Vec<Vec<char>>,\n    word: Vec<char>,\n}\n\nimpl WordSearch {\n    fn new(board: Vec<Vec<char>>, word: String) -> Option<Self> {\n        let n = board.len();\n        if n == 0 {\n            return None;\n        }\n        let m = board[0].len();\n        if m == 0 {\n            return None;\n        }\n        if word.is_empty() {\n            return None;\n        }\n        let visited = vec![vec![false; m]; n];\n        let word = word.chars().collect();\n\n        Some(Self {\n            n,\n            m,\n            visited,\n            board,\n            word,\n        })\n    }\n\n    fn dfs(&mut self, i: usize, j: usize, k: usize) -> bool {\n        if self.visited[i][j] || self.word[k] != self.board[i][j] {\n            return false;\n        }\n        if k == self.word.len() - 1 {\n            return true;\n        } else {\n            self.visited[i][j] = true;\n            if (j > 0 && self.dfs(i, j - 1, k + 1))\n                || (j < self.m - 1 && self.dfs(i, j + 1, k + 1))\n                || (i > 0 && self.dfs(i - 1, j, k + 1))\n                || (i < self.n - 1 && self.dfs(i + 1, j, k + 1))\n            {\n                return true;\n            }\n            self.visited[i][j] = false;\n        }\n        false\n    }\n\n    fn exist(&mut self) -> bool {\n        for i in 0..self.n {\n            for j in 0..self.m {\n                if self.dfs(i, j, 0) {\n                    return true;\n                }\n            }\n        }\n        false\n    }\n}\n\n#[test]\nfn test() {\n    let board = vec_vec_char![];\n    let word = \"AC\".to_string();\n    let res = false;\n    assert_eq!(Solution::exist(board, word), res);\n    let board = vec_vec_char![['A', 'C'], ['A', 'D']];\n    let word = \"\".to_string();\n    let res = false;\n    assert_eq!(Solution::exist(board, word), res);\n}\n"
    },
    {
        "input": "\n\nclass Solution(object):\n    def uniquePathsWithObstacles(self, obstacleGrid):\n        \n        m, n = len(obstacleGrid), len(obstacleGrid[0])\n        dp = [[0 for _ in range(n)] for _ in range(m)]\n\n        if obstacleGrid[0][0] == 1 or obstacleGrid[m-1][n-1] == 1:\n        \treturn 0\n\n        dp[0][0] = 1\n        for index in range(1, m):\n        \tif obstacleGrid[index][0] == 1:\n        \t\tdp[index][0] = 0\n        \telse:\n        \t\tdp[index][0] = dp[index-1][0]\n\n        for index in range(1, n):\n        \tif obstacleGrid[0][index] == 1:\n        \t\tdp[0][index] = 0\n        \telse:\n        \t\tdp[0][index] = dp[0][index-1]\n\n        for index_i in range(1, m):\n        \tfor index_j in range(1, n):\n        \t\tif obstacleGrid[index_i][index_j] == 1:\n        \t\t\tdp[index_i][index_j] = 0\n        \t\telse:\n        \t\t\tdp[index_i][index_j] = dp[index_i-1][index_j] + dp[index_i][index_j-1]\n\n        return dp[m-1][n-1]\n",
        "output": "struct Solution;\n\nimpl Solution {\n    fn unique_paths_with_obstacles(obstacle_grid: Vec<Vec<i32>>) -> i32 {\n        let n = obstacle_grid.len();\n        let m = obstacle_grid[0].len();\n        let mut dp = vec![vec![0; m]; n];\n        dp[0][0] = 1;\n        for i in 0..n {\n            for j in 0..m {\n                if obstacle_grid[i][j] == 0 {\n                    if i > 0 {\n                        dp[i][j] += dp[i - 1][j];\n                    }\n                    if j > 0 {\n                        dp[i][j] += dp[i][j - 1];\n                    }\n                } else {\n                    dp[i][j] = 0;\n                }\n            }\n        }\n        dp[n - 1][m - 1]\n    }\n}\n\n#[test]\nfn test() {\n    let obstacle_grid = vec_vec_i32![[0, 0, 0], [0, 1, 0], [0, 0, 0]];\n    let res = 2;\n    assert_eq!(Solution::unique_paths_with_obstacles(obstacle_grid), res);\n    let obstacle_grid = vec_vec_i32![[1]];\n    let res = 0;\n    assert_eq!(Solution::unique_paths_with_obstacles(obstacle_grid), res);\n}\n"
    },
    {
        "input": "class Solution(object):\n    def getPermutation(self, n, k):\n        \n        \n        nums = []\n        for index in range(1, n+1):\n        \tnums.append(index)\n\n        def permute(nums):\n        \tif len(nums) == 0:\n        \t\treturn []\n        \tif len(nums) == 1:\n        \t\treturn [nums]\n\n        \tresult = []\n        \tfor index in range(len(nums)):\n        \t\tfor p in permute(nums[0:index] + nums[index+1:]):\n        \t\t\tresult.append([nums[index]] + p)\n\n        \treturn result\n\n        value = permute(nums)[k-1]\n        result = \"\"\n        for val in value:\n        \tresult += str(val)\n        return result",
        "output": "struct Solution;\n\nimpl Solution {\n    fn get_permutation(n: i32, k: i32) -> String {\n        let n = n as usize;\n        let mut k = k as usize - 1;\n        let mut nums: Vec<usize> = (1..=n).collect();\n        let mut factorial = vec![1];\n        let mut prev = 1;\n        for x in 1..n {\n            prev *= x;\n            factorial.push(prev);\n        }\n        let mut res = vec![];\n        for i in 0..n {\n            let index = k / factorial[n - 1 - i];\n            res.push(nums.remove(index));\n            k %= factorial[n - 1 - i];\n        }\n        res.into_iter().map(|x| (x as u8 + b'0') as char).collect()\n    }\n}\n\n#[test]\nfn test() {\n    let n = 3;\n    let k = 3;\n    let res = \"213\".to_string();\n    assert_eq!(Solution::get_permutation(n, k), res);\n    let n = 4;\n    let k = 9;\n    let res = \"2314\".to_string();\n    assert_eq!(Solution::get_permutation(n, k), res);\n    let n = 3;\n    let k = 5;\n    let res = \"312\".to_string();\n    assert_eq!(Solution::get_permutation(n, k), res);\n}\n"
    },
    {
        "input": "\n\nclass Solution(object):\n    def nextPermutation(self, nums):\n        \n\n        index_i = len(nums) - 2\n        while index_i >= 0 and nums[index_i] >= nums[index_i+1]:\n        \tindex_i -= 1\n\n        if index_i >= 0:\n        \tindex_j = len(nums) - 1\n        \twhile index_j >= index_i and nums[index_j] <= nums[index_i]:\n        \t\tindex_j -= 1\n\n        \tnums[index_i], nums[index_j] = nums[index_j], nums[index_i]\n            \n        start = index_i + 1\n        end = len(nums) - 1\n            \n        while start < end:\n            nums[start], nums[end] = nums[end], nums[start]\n            start += 1\n            end -= 1\n                \n            \n        ",
        "output": "struct Solution;\n\nimpl Solution {\n    fn next_permutation(nums: &mut Vec<i32>) {\n        let n = nums.len();\n        let mut i = n - 1;\n        while i > 0 && nums[i - 1] >= nums[i] {\n            i -= 1;\n        }\n        let mut j = i;\n        let mut k = n - 1;\n        while j < k {\n            nums.swap(j, k);\n            j += 1;\n            k -= 1;\n        }\n        if i > 0 {\n            k = i;\n            i -= 1;\n            while nums[k] <= nums[i] {\n                k += 1;\n            }\n            nums.swap(i, k)\n        }\n    }\n}\n\n#[test]\nfn test() {\n    let mut nums = vec![1, 2, 3];\n    let res = vec![1, 3, 2];\n    Solution::next_permutation(&mut nums);\n    assert_eq!(nums, res);\n    let mut nums = vec![3, 2, 1];\n    let res = vec![1, 2, 3];\n    Solution::next_permutation(&mut nums);\n    assert_eq!(nums, res);\n    let mut nums = vec![1, 1, 5];\n    let res = vec![1, 5, 1];\n    Solution::next_permutation(&mut nums);\n    assert_eq!(nums, res);\n}\n"
    },
    {
        "input": "\nclass Solution(object):\n    def threeSum(self, nums):\n        \n        nums.sort()\n\n        if (len(nums) >= 3) and (nums[0] == nums[len(nums) -1]) and (nums[0] == 0):\n            return [[0, 0, 0]]\n\n        result = []\n        for index in range(len(nums) - 1):\n        \tleft = index+1\n        \tright = len(nums) - 1\n\n        \twhile left < right:\n        \t\tcurrSum = nums[index] + nums[left] + nums[right]\n        \t\tif currSum == 0:\n        \t\t\tresult.append([nums[index], nums[left], nums[right]])\n        \t\t\tleft += 1\n        \t\t\tright -= 1\n        \t\telif currSum < 0:\n        \t\t\tleft += 1\n        \t\telse:\n        \t\t\tright -= 1\n        return  [list(t) for t in set(tuple(element) for element in result)]\n\n\n",
        "output": "struct Solution;\n\nimpl Solution {\n    fn three_sum(mut nums: Vec<i32>) -> Vec<Vec<i32>> {\n        let mut res: Vec<Vec<i32>> = vec![];\n        let n = nums.len();\n        if n < 3 {\n            return res;\n        }\n        nums.sort_unstable();\n        for i in 0..n - 2 {\n            let a = nums[i];\n            if nums[i] > 0 {\n                break;\n            }\n            if i > 0 && nums[i] == nums[i - 1] {\n                continue;\n            }\n            let mut j = i + 1;\n            let mut k = n - 1;\n            while j < k {\n                let b = nums[j];\n                let c = nums[k];\n                let sum = a + b + c;\n                if sum == 0 {\n                    res.push(vec![a, b, c]);\n                    j += 1;\n                    k -= 1;\n                    while j < k && nums[j] == nums[j - 1] {\n                        j += 1;\n                    }\n                    while j < k && nums[k] == nums[k + 1] {\n                        k -= 1;\n                    }\n                } else {\n                    if sum < 0 {\n                        j += 1;\n                    } else {\n                        k -= 1;\n                    }\n                }\n            }\n        }\n        res\n    }\n}\n\n#[test]\nfn test() {\n    let nums = vec![-1, 0, 1, 2, -1, -4];\n    let res: Vec<Vec<i32>> = vec_vec_i32![[-1, -1, 2], [-1, 0, 1]];\n    assert_eq!(Solution::three_sum(nums), res);\n    let nums = vec![-2, 0, 1, 1, 2];\n    let res: Vec<Vec<i32>> = vec_vec_i32![[-2, 0, 2], [-2, 1, 1]];\n    assert_eq!(Solution::three_sum(nums), res);\n}\n"
    },
    {
        "input": "\n\nclass Solution(object):\n    def subsetsWithDup(self, nums):\n           \n        result = [[]]\n        for num in nums:\n        \tfor index in range(len(result)):\n        \t\tnew_list = result[index] + [num]\n        \t\tnew_list.sort()\n        \t\tresult.append(new_list)\n        unique = set(tuple(val) for val in result)\n        return list(list(val) for val in unique)",
        "output": "struct Solution;\n\nimpl Solution {\n    fn subsets_with_dup(mut nums: Vec<i32>) -> Vec<Vec<i32>> {\n        nums.sort_unstable();\n        let n = nums.len();\n        let mut cur = vec![];\n        let mut res = vec![];\n        Self::dfs(0, &mut cur, &mut res, &nums, n);\n        res\n    }\n\n    fn dfs(start: usize, cur: &mut Vec<i32>, all: &mut Vec<Vec<i32>>, nums: &[i32], n: usize) {\n        all.push(cur.to_vec());\n        if start == n {\n            return;\n        }\n        for i in start..n {\n            if i > start && nums[i] == nums[i - 1] {\n                continue;\n            }\n            cur.push(nums[i]);\n            Self::dfs(i + 1, cur, all, nums, n);\n            cur.pop();\n        }\n    }\n}\n\n#[test]\nfn test() {\n    let nums = vec![1, 2, 2];\n    let mut res = vec_vec_i32![[2], [1], [1, 2, 2], [2, 2], [1, 2], []];\n    res.sort_unstable();\n    assert_eq!(Solution::subsets_with_dup(nums), res);\n}\n"
    },
    {
        "input": "\n\nclass Solution(object):\n    def removeDuplicates(self, nums):\n        \n        if not nums:\n        \treturn 0\n        \t\n        index_i = 0\n\n        for index_j in range(1, len(nums)):\n        \tif nums[index_i] != nums[index_j]:\n        \t\tindex_i += 1\n        \t\tnums[index_i] = nums[index_j]\n\n        return index_i + 1",
        "output": "struct Solution;\n\nimpl Solution {\n    fn remove_duplicates(nums: &mut Vec<i32>) -> i32 {\n        let n = nums.len();\n        if n == 0 {\n            return 0;\n        }\n        let mut last = nums[0];\n        let mut size = 1;\n        for i in 1..n {\n            if nums[i] != last {\n                last = nums[i];\n                nums[size] = nums[i];\n                size += 1;\n            }\n        }\n        nums.resize(size, 0);\n        nums.shrink_to_fit();\n        size as i32\n    }\n}\n\n#[test]\nfn test() {\n    let mut nums = vec![1, 1, 2];\n    assert_eq!(Solution::remove_duplicates(&mut nums), 2);\n    let mut nums = vec![0, 0, 1, 1, 1, 2, 2, 3, 3, 4];\n    assert_eq!(Solution::remove_duplicates(&mut nums), 5);\n}\n"
    },
    {
        "input": "\n\nclass Solution(object):\n    def mergeKLists(self, lists):\n        \n\n        from heapq import heappush, heappop\n\n        heap = []\n        head = point = ListNode(0)\n        for element in lists:\n        \tif element:\n        \t\theapq.heappush(heap, (element.val, element))\n\n        while heap:\n        \tvalue, node = heapq.heappop(heap)\n        \thead.next = ListNode(value)\n        \thead = head.next\n        \tnode = node.next\n        \tif node:\n        \t\theapq.heappush(heap, (node.val, node))\n\n        return point.next\n\n\n\n\nclass Solution(object):\n    def mergeKLists(self, lists):\n        \n\n        def merge2Lists(l1, l2):\n        \thead = point = ListNode(0)\n        \twhile l1 and l2:\n        \t\tif l1.val <= l2.val:\n        \t\t\tpoint.next = ListNode(l1.val)\n        \t\t\tl1 = l1.next\n        \t\telse:\n        \t\t\tpoint.next = ListNode(l2.val)\n        \t\t\tl2 = l2.next\n        \t\tpoint = point.next\n\n        \tif l1:\n        \t\tpoint.next = l1\n        \telse:\n        \t\tpoint.next = l2\n        \treturn head.next\n\n        if not lists:\n        \treturn lists\n\n        interval = 1\n        while interval < len(lists):\n        \tfor index in range(0, len(lists) - interval ,interval*2):\n        \t\tlists[index] = merge2Lists(lists[index], lists[index+interval])\n\n        \tinterval *= 2\n\n        return lists[0]\n\n\n\n\n",
        "output": "struct Solution;\nuse rustgym_util::*;\nuse std::collections::VecDeque;\n\nimpl Solution {\n    fn merge_k_lists(lists: Vec<ListLink>) -> ListLink {\n        if lists.is_empty() {\n            return None;\n        }\n        let mut queue: VecDeque<ListLink> = lists.into_iter().collect();\n        while queue.len() > 1 {\n            let merged_list = Self::merge(queue.pop_front().unwrap(), queue.pop_front().unwrap());\n            queue.push_back(merged_list);\n        }\n        queue.pop_back().unwrap()\n    }\n\n    fn merge(a: ListLink, b: ListLink) -> ListLink {\n        if a.is_none() && b.is_none() {\n            return None;\n        }\n        if a.is_none() {\n            return b;\n        }\n        if b.is_none() {\n            return a;\n        }\n        let mut a = a.unwrap();\n        let mut b = b.unwrap();\n        if a.val < b.val {\n            a.next = Self::merge(a.next.take(), Some(b));\n            Some(a)\n        } else {\n            b.next = Self::merge(Some(a), b.next.take());\n            Some(b)\n        }\n    }\n}\n\n#[test]\nfn test() {\n    let lists = vec![list!(1, 4, 5), list!(1, 3, 4), list!(2, 6)];\n    let res = list!(1, 1, 2, 3, 4, 4, 5, 6);\n    assert_eq!(Solution::merge_k_lists(lists), res);\n}\n"
    },
    {
        "input": "\n\n\n\n\n\n\n\nclass Solution(object):\n    def recoverTree(self, root):\n        \n\n        first, second, prev = None, None, None\n        def inorder(root):\n        \tif root:\n        \t\tinorder(root.left)\n        \t\tif prev is not None and root.val < prev.val:\n        \t\t\tif first is None:\n        \t\t\t\tfirst = root\n        \t\t\telse:\n        \t\t\t\tsecond = root\n        \t\tprev = root\n        \t\tinorder(root.right)\n\n\n        inorder(root)\n        if first and second:\n        \tfirst.val, second.val = second.val, first.val",
        "output": "struct Solution;\nuse rustgym_util::*;\nuse std::mem::swap;\n\ntrait Inorder {\n    fn inorder(&self, prev: &mut TreeLink, first: &mut TreeLink, second: &mut TreeLink);\n}\n\nimpl Inorder for TreeLink {\n    fn inorder(&self, prev: &mut TreeLink, first: &mut TreeLink, second: &mut TreeLink) {\n        if let Some(node) = self {\n            let node = node.borrow();\n            node.left.inorder(prev, first, second);\n            if let Some(prev_val) = prev.clone() {\n                if prev_val.borrow().val >= node.val {\n                    if first.is_none() {\n                        *first = prev.clone();\n                    }\n                    *second = self.clone();\n                }\n            }\n            *prev = self.clone();\n            node.right.inorder(prev, first, second);\n        }\n    }\n}\n\nimpl Solution {\n    fn recover_tree(root: &mut TreeLink) {\n        let mut prev = None;\n        let mut first = None;\n        let mut second = None;\n        root.inorder(&mut prev, &mut first, &mut second);\n        swap(\n            &mut first.unwrap().borrow_mut().val,\n            &mut second.unwrap().borrow_mut().val,\n        )\n    }\n}\n\n#[test]\nfn test() {\n    let mut root = tree!(1, tree!(3, None, tree!(2)), None);\n    Solution::recover_tree(&mut root);\n    let res = tree!(3, tree!(1, None, tree!(2)), None);\n    assert_eq!(root, res);\n    let mut root = tree!(3, tree!(1), tree!(4, tree!(2), None));\n    Solution::recover_tree(&mut root);\n    let res = tree!(2, tree!(1), tree!(4, tree!(3), None));\n    assert_eq!(root, res);\n}\n"
    },
    {
        "input": "\n\nclass Solution(object):\n    def numDecodings(self, s):\n        \n        if not s or s[0] == '0':\n        \treturn 0\n        if len(s) == 1:\n        \treturn 1\n\n        dp = [0]*len(s)\n        dp[0] = 1\n\n        if int(s[:2]) > 26:\n        \tif s[1] != '0':\n        \t\tdp[1] = 1\n        \telse:\n        \t\tdp[0] = 0\n        else:\n        \tif s[1] != '0':\n        \t\tdp[1] = 2\n        \telse:\n        \t\tdp[1] = 1\n\n        for index in range(2, len(s)):\n        \tif s[index] != '0':\n        \t\tdp[index] += dp[index-1]\n\n        \tval = int(s[index-1:index+1])\n        \tif val >= 10 and val <= 26:\n        \t\tdp[index] += dp[index-2]\n        return dp[len(s)-1]\n\n\n",
        "output": "struct Solution;\n\nimpl Solution {\n    fn num_decodings(s: String) -> i32 {\n        let s: Vec<u8> = s.bytes().map(|b| b - b'0').collect();\n        let n = s.len();\n        let mut a: Vec<i32> = vec![0; n + 1];\n        if n == 0 {\n            return 0;\n        }\n        a[0] = 1;\n        a[1] = if s[0] > 0 { 1 } else { 0 };\n        for i in 1..n {\n            let first = s[i];\n            let second = s[i - 1] * 10 + s[i];\n            if (1..=9).contains(&first) {\n                a[i + 1] += a[i];\n            }\n            if (10..=26).contains(&second) {\n                a[i + 1] += a[i - 1];\n            }\n        }\n        a[n]\n    }\n}\n\n#[test]\nfn test() {\n    let s = \"12\".to_string();\n    assert_eq!(Solution::num_decodings(s), 2);\n    let s = \"226\".to_string();\n    assert_eq!(Solution::num_decodings(s), 3);\n}\n"
    },
    {
        "input": "\n\nclass Solution(object):\n    def search(self, nums, target):\n        \n        left, right = 0, len(nums) -1\n        while left <= right: \t\n        \tmid = (left + right) / 2\n        \tif nums[mid] == target:\n        \t\treturn True\n        \tif nums[left] < nums[mid]:\n        \t\tif nums[left] <= target < nums[mid]:\n        \t\t\tright = mid - 1\n        \t\telse:\n        \t\t\tleft = mid + 1\n        \telif nums[mid] < nums[left]:\n        \t\tif nums[mid] < target <= nums[right]:\n        \t\t\tleft = mid + 1\n        \t\telse:\n        \t\t\tright = mid -1\n        \telse:\n        \t\tleft += 1\n\n        return False",
        "output": "struct Solution;\nuse std::cmp::Ordering::*;\n\nimpl Solution {\n    fn search(nums: Vec<i32>, target: i32) -> bool {\n        let n = nums.len();\n        if n == 0 {\n            return false;\n        }\n        let mut l = 0;\n        let mut r = n - 1;\n        while l < r {\n            let m = l + (r - l) / 2;\n            if nums[m] == target {\n                return true;\n            }\n            match nums[m].cmp(&nums[r]) {\n                Equal => {\n                    r -= 1;\n                }\n                Less => {\n                    if nums[m] < target && nums[r] >= target {\n                        l = m + 1;\n                    } else {\n                        r = m;\n                    }\n                }\n                Greater => {\n                    if nums[m] > target && nums[l] <= target {\n                        r = m;\n                    } else {\n                        l = m + 1;\n                    }\n                }\n            }\n        }\n        nums[l] == target\n    }\n}\n\n#[test]\nfn test() {\n    let nums = vec![2, 5, 6, 0, 0, 1, 2];\n    let target = 0;\n    let res = true;\n    assert_eq!(Solution::search(nums, target), res);\n    let nums = vec![2, 5, 6, 0, 0, 1, 2];\n    let target = 3;\n    let res = false;\n    assert_eq!(Solution::search(nums, target), res);\n    let nums = vec![1, 1];\n    let target = 0;\n    let res = false;\n    assert_eq!(Solution::search(nums, target), res);\n    let nums = vec![1, 3, 1, 1];\n    let target = 3;\n    let res = true;\n    assert_eq!(Solution::search(nums, target), res);\n}\n"
    },
    {
        "input": "\nclass Solution(object):\n    def minPathSum(self, grid):\n        \n        if not grid:\n        \treturn 0\n\n        row, col = len(grid), len(grid[0])\n        dp = [[0 for _ in range(col)] for _ in range(row)]\n        dp[0][0] = grid[0][0]\n\n        for index in range(1, row):\n        \tdp[index][0] = dp[index-1][0] + grid[index][0]\n\n        for index in range(1, col):\n        \tdp[0][index] = dp[0][index-1] + grid[0][index]\n\n        print dp\n        for index_i in range(1, row):\n        \tfor index_j in range(1, col):\n        \t\tdp[index_i][index_j] = min(dp[index_i-1][index_j], dp[index_i][index_j-1]) + grid[index_i][index_j]\n\n        return dp[row-1][col-1]",
        "output": "struct Solution;\n\nimpl Solution {\n    fn min_path_sum(grid: Vec<Vec<i32>>) -> i32 {\n        let n = grid.len();\n        let m = grid[0].len();\n        let mut dp: Vec<Vec<i32>> = vec![vec![0; m]; n];\n        dp[0][0] = grid[0][0];\n        for j in 1..m {\n            dp[0][j] = dp[0][j - 1] + grid[0][j];\n        }\n        for i in 1..n {\n            dp[i][0] = dp[i - 1][0] + grid[i][0];\n        }\n        for i in 1..n {\n            for j in 1..m {\n                dp[i][j] = i32::min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j];\n            }\n        }\n        dp[n - 1][m - 1]\n    }\n}\n\n#[test]\nfn test() {\n    let grid: Vec<Vec<i32>> = vec_vec_i32![[1, 3, 1], [1, 5, 1], [4, 2, 1]];\n    let res = 7;\n    assert_eq!(Solution::min_path_sum(grid), res);\n}\n"
    },
    {
        "input": "\n\nclass Solution(object):\n    def longestCommonPrefix(self, strs):\n        \n        def prefix(strs, index):\n            check_prefix = strs[0][:index]\n            for index in range(1, len(strs)):\n                if not strs[index].startswith(check_prefix):\n                    return False\n            return True\n                \n                    \n        if not strs:\n            return \"\"\n        \n        minLength = float('inf')\n        for string in strs:\n            minLength = min(minLength, len(string))\n            \n        low, high = 0, minLength\n        \n        while low <= high:\n            mid = (low+high)/2\n            if (prefix(strs, mid)):\n                low = mid + 1\n            else:\n                high = mid - 1\n        \n        return strs[0][:(low+high)/2]\n",
        "output": "struct Solution;\n\nimpl Solution {\n    fn longest_common_prefix(strs: Vec<String>) -> String {\n        if strs.is_empty() {\n            return String::from(\"\");\n        }\n        let ss: Vec<Vec<char>> = strs.iter().map(|s| s.chars().collect()).collect();\n        let n = ss.iter().map(|s| s.len()).min().unwrap();\n        let mut prefix: Vec<char> = vec![];\n        for i in 0..n {\n            let c = ss[0][i];\n            if ss.iter().all(|s| s[i] == c) {\n                prefix.push(c);\n            } else {\n                break;\n            }\n        }\n        prefix.iter().collect()\n    }\n}\n\n#[test]\nfn test() {\n    let ss: Vec<String> = vec_string![\"flower\", \"flow\", \"flight\"];\n    assert_eq!(Solution::longest_common_prefix(ss), String::from(\"fl\"));\n}\n"
    },
    {
        "input": "\nclass Solution(object):\n    def searchMatrix(self, matrix, target):\n        \n\n        if not matrix:\n        \treturn 0\n        left, right = 0, len(matrix[0])-1\n\n        while left < len(matrix) and right >= 0:\n        \tif matrix[left][right] == target:\n        \t\treturn True \n        \telif matrix[left][right] < target:\n        \t\tleft += 1\n        \telse:\n        \t\tright -= 1\n        return False",
        "output": "struct Solution;\n\nimpl Solution {\n    fn search_matrix(matrix: Vec<Vec<i32>>, target: i32) -> bool {\n        let mut a = vec![];\n        for row in matrix {\n            for x in row {\n                a.push(x);\n            }\n        }\n        a.binary_search(&target).is_ok()\n    }\n}\n\n#[test]\nfn test() {\n    let matrix: Vec<Vec<i32>> = vec_vec_i32![[1, 3, 5, 7], [10, 11, 16, 20], [23, 30, 34, 50]];\n    let target = 3;\n    let res = true;\n    assert_eq!(Solution::search_matrix(matrix, target), res);\n}\n"
    },
    {
        "input": "\n\n\n\n\n\n\n\n\nclass Solution(object):\n    def inorderTraversal(self, root):\n        \n        if not root:\n            return []\n        \n        stack, result = [root], []\n        while stack:\n            if root.left:\n                stack.append(root.left)\n                root = root.left\n            else:\n                node = stack.pop()\n                result.append(node.val)\n                \n                if node.right:\n                    stack.append(node.right)\n                    root = node.right\n        return result",
        "output": "struct Solution;\nuse rustgym_util::*;\n\nimpl Solution {\n    fn inorder_traversal(root: TreeLink) -> Vec<i32> {\n        let mut cur = root;\n        let mut stack: Vec<TreeLink> = vec![];\n        let mut res = vec![];\n        while cur.is_some() || !stack.is_empty() {\n            while let Some(node) = cur {\n                let left = node.borrow_mut().left.take();\n                stack.push(Some(node));\n                cur = left;\n            }\n            let node = stack.pop().unwrap().unwrap();\n            res.push(node.borrow().val);\n            cur = node.borrow_mut().right.take();\n        }\n        res\n    }\n}\n\n#[test]\nfn test() {\n    let root = tree!(1, None, tree!(2, tree!(3), None));\n    let res = vec![1, 3, 2];\n    assert_eq!(Solution::inorder_traversal(root), res);\n}\n"
    },
    {
        "input": "\n\n\n\n\n\n\n\nclass Solution(object):\n    def removeNthFromEnd(self, head, n):\n        \n        if not head:\n        \treturn None\n\n        ref = head\n        while n > 0:\n        \tref = ref.next\n        \tn -= 1\n\n        if ref is None:\n        \treturn head.next\n        else:\n        \tmain = head\n        \twhile ref.next:\n        \t\tmain = main.next\n        \t\tref = ref.next\n\n        \tmain.next = main.next.next\n        \treturn head",
        "output": "struct Solution;\nuse rustgym_util::*;\n\nimpl Solution {\n    fn remove_nth_from_end(mut head: ListLink, n: i32) -> ListLink {\n        let mut v: Vec<ListLink> = vec![];\n        while let Some(mut node) = head {\n            head = node.next.take();\n            v.push(Some(node));\n        }\n        let mut res = None;\n        for (i, link) in v.into_iter().rev().enumerate() {\n            if i != (n - 1) as usize {\n                let mut node = link.unwrap();\n                node.next = res;\n                res = Some(node);\n            }\n        }\n        res\n    }\n}\n\n#[test]\nfn test() {\n    let head = list![1, 2, 3, 4, 5];\n    let res = list![1, 2, 3, 5];\n    let n = 2;\n    assert_eq!(Solution::remove_nth_from_end(head, n), res);\n}\n"
    },
    {
        "input": "\n\nclass Solution(object):\n    def generateParenthesis(self, n):\n        \n\n        result = []\n\n        def backtracking(S, left, right):\n        \tif len(S) == 2*n:\n        \t\tresult.append(S)\n        \t\treturn \n\n        \tif left < n:\n        \t\tbacktracking(S+'(', left+1, right)\n\n        \tif right < left:\n        \t\tbacktracking(S+')', left, right+1)\n\n        backtracking('', 0, 0)\n        return result",
        "output": "struct Solution;\n\nimpl Solution {\n    fn generate_parenthesis(n: i32) -> Vec<String> {\n        let mut res: Vec<String> = vec![];\n        let mut cur: String = \"\".to_string();\n        Self::dfs(n, n, &mut cur, &mut res);\n        res\n    }\n    fn dfs(left: i32, right: i32, cur: &mut String, all: &mut Vec<String>) {\n        if left == 0 && right == 0 {\n            all.push(cur.to_string());\n        } else {\n            if left > 0 {\n                cur.push('(');\n                Self::dfs(left - 1, right, cur, all);\n                cur.pop();\n            }\n            if right > left {\n                cur.push(')');\n                Self::dfs(left, right - 1, cur, all);\n                cur.pop();\n            }\n        }\n    }\n}\n\n#[test]\nfn test() {\n    let res: Vec<String> = vec_string![\"((()))\", \"(()())\", \"(())()\", \"()(())\", \"()()()\"];\n    assert_eq!(Solution::generate_parenthesis(3), res);\n}\n"
    },
    {
        "input": "\n\nclass Solution(object):\n\tdef maxKilledEnemies(self, grid):\n\t\tif not grid or len(grid) == 0 or len(grid[0]) == 0:\n\t\t\treturn 0\n\n\t\tresult, row_count = float('-inf'), 0\n\t\tcolumn_count = [0]*len(grid[0])\n\t\tfor row in range(len(grid)):\n\t\t\tfor column in range(len(grid[0])):\n\t\t\t\tif column == 0 or grid[row][column-1] == 'W':\n\t\t\t\t\trow_count = 0\n\t\t\t\t\tfor index in range(column, len(grid[0])):\n\t\t\t\t\t\tif grid[row][index] == 'W':\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\trow_count += 1 if grid[row][index] == 'E' else 0\n\n\t\t\t\tif row == 0 or grid[row-1][column] == 'W':\n\t\t\t\t\tcolumn_count[column] = 0\n\t\t\t\t\tfor index in range(row, len(grid)):\n\t\t\t\t\t\tif grid[index][column] == 'W':\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\tcolumn_count[column] += 1 if grid[index][column] == 'E' else 0\n\n\t\t\t\tif grid[row][column] == '0':\n\t\t\t\t\tresult = max(result, row_count + column_count[column])\n\t\treturn result\n\n\nsolution = Solution()\ngrid = [['0', 'E', '0', '0'],\n['E', '0', 'W', 'E'],\n['0', 'E', '0', '0']]\nprint solution.maxKilledEnemies(grid)",
        "output": "struct Solution;\n\nimpl Solution {\n    fn max_killed_enemies(grid: Vec<Vec<char>>) -> i32 {\n        let n = grid.len();\n        if n == 0 {\n            return 0;\n        }\n        let m = grid[0].len();\n        let mut left = vec![vec![0; m]; n];\n        let mut top = vec![vec![0; m]; n];\n        let mut bottom = vec![vec![0; m]; n];\n        let mut right = vec![vec![0; m]; n];\n        for i in 0..n {\n            for j in 0..m {\n                match grid[i][j] {\n                    'E' => {\n                        top[i][j] = if i > 0 { top[i - 1][j] } else { 0 } + 1;\n                        left[i][j] = if j > 0 { left[i][j - 1] } else { 0 } + 1;\n                    }\n                    'W' => {\n                        top[i][j] = 0;\n                        left[i][j] = 0;\n                    }\n                    _ => {\n                        top[i][j] = if i > 0 { top[i - 1][j] } else { 0 };\n                        left[i][j] = if j > 0 { left[i][j - 1] } else { 0 };\n                    }\n                }\n            }\n        }\n        for i in (0..n).rev() {\n            for j in (0..m).rev() {\n                match grid[i][j] {\n                    'E' => {\n                        bottom[i][j] = if i + 1 < n { bottom[i + 1][j] } else { 0 } + 1;\n                        right[i][j] = if j + 1 < m { right[i][j + 1] } else { 0 } + 1;\n                    }\n                    'W' => {\n                        bottom[i][j] = 0;\n                        right[i][j] = 0;\n                    }\n                    _ => {\n                        bottom[i][j] = if i + 1 < n { bottom[i + 1][j] } else { 0 };\n                        right[i][j] = if j + 1 < m { right[i][j + 1] } else { 0 };\n                    }\n                }\n            }\n        }\n        let mut res = 0;\n        for i in 0..n {\n            for j in 0..m {\n                if grid[i][j] == '0' {\n                    res = res.max(top[i][j] + left[i][j] + bottom[i][j] + right[i][j]);\n                }\n            }\n        }\n        res\n    }\n}\n\n#[test]\nfn test() {\n    let grid = vec_vec_char![\n        ['0', 'E', '0', '0'],\n        ['E', '0', 'W', 'E'],\n        ['0', 'E', '0', '0']\n    ];\n    let res = 3;\n    assert_eq!(Solution::max_killed_enemies(grid), res);\n}\n"
    },
    {
        "input": "\n\nfrom collections import defaultdict\nclass Solution(object):\n    def findItinerary(self, tickets):\n        \n        n = len(tickets)\n        trips = defaultdict(list)\n        for x in tickets:\n            trips[x[0]].append(x[1])\n        for x in trips:\n            trips[x].sort()\n        iter = [\"JFK\"]\n        \n        def dfs(curr_iter):\n            if len(curr_iter) == n+1: \n                return curr_iter\n            curr_stop = curr_iter[-1]\n            \n            if trips[curr_stop] == []: \n                return None\n            \n            next_stops = trips[curr_stop]\n            i = 0\n            for stop in next_stops:\n                curr_iter.append(stop)\n                del trips[curr_stop][i]\n                \n                if dfs(curr_iter): \n                    return curr_iter\n                \n                curr_iter.pop()\n                trips[curr_stop].insert(i, stop)\n                i += 1\n            return None\n        \n        return dfs(iter)  ",
        "output": "struct Solution;\nuse std::cmp::Reverse;\nuse std::collections::BinaryHeap;\nuse std::collections::HashMap;\n\ntype G = HashMap<String, BinaryHeap<Reverse<String>>>;\n\nimpl Solution {\n    fn find_itinerary(tickets: Vec<Vec<String>>) -> Vec<String> {\n        let mut res: Vec<String> = vec![];\n        let mut g: G = HashMap::new();\n        for ticket in tickets {\n            g.entry(ticket[0].clone())\n                .or_default()\n                .push(Reverse(ticket[1].clone()));\n        }\n        let mut stack: Vec<String> = vec![\"JFK\".to_string()];\n        while !stack.is_empty() {\n            while g.contains_key(stack.last().unwrap())\n                && !g.get(stack.last().unwrap()).unwrap().is_empty()\n            {\n                let airports = g.get_mut(stack.last().unwrap()).unwrap();\n                let airport = airports.pop().unwrap().0;\n                stack.push(airport);\n            }\n            res.insert(0, stack.pop().unwrap());\n        }\n        res\n    }\n}\n\n#[test]\nfn test() {\n    let tickets: Vec<Vec<String>> = vec_vec_string![\n        [\"MUC\", \"LHR\"],\n        [\"JFK\", \"MUC\"],\n        [\"SFO\", \"SJC\"],\n        [\"LHR\", \"SFO\"]\n    ];\n    let res: Vec<String> = vec_string![\"JFK\", \"MUC\", \"LHR\", \"SFO\", \"SJC\"];\n    assert_eq!(Solution::find_itinerary(tickets), res);\n}\n"
    },
    {
        "input": "\n\nclass Solution(object):\n    def kthSmallest(self, matrix, k):\n        \n        \n        if not matrix:\n        \treturn 0 \n\n        import heapq\n        heap = []\n        for col in range(len(matrix[0])):\n        \theapq.heappush(heap, (matrix[0][col], 0, col))\n\n        val = 0\n        for index in range(k):\n        \tval, row, col = heapq.heappop(heap)\n        \tnew_val = float('inf')\n        \tif row < len(matrix)-1:\n        \t\tnew_val = matrix[row+1][col]\n        \theapq.heappush(heap, (new_val, row+1, col))\n        return val",
        "output": "struct Solution;\nuse std::collections::BinaryHeap;\n\nimpl Solution {\n    fn kth_smallest(matrix: Vec<Vec<i32>>, k: i32) -> i32 {\n        let mut pq: BinaryHeap<i32> = BinaryHeap::new();\n        for row in matrix {\n            for x in row {\n                pq.push(x);\n                if pq.len() > k as usize {\n                    pq.pop();\n                }\n            }\n        }\n        pq.pop().unwrap()\n    }\n}\n\n#[test]\nfn test() {\n    let matrix = vec_vec_i32![[1, 5, 9], [10, 11, 13], [12, 13, 15]];\n    let k = 8;\n    let res = 13;\n    assert_eq!(Solution::kth_smallest(matrix, k), res);\n    let matrix = vec_vec_i32![[1, 2], [1, 3]];\n    let k = 3;\n    let res = 2;\n    assert_eq!(Solution::kth_smallest(matrix, k), res);\n}\n"
    },
    {
        "input": "\n\nclass Solution(object):\n\tdef __init__(self):\n\t\tself.queue = []\n\t\tself.curr_sum = 0\n\n\tdef movingAverage(self, num, size):\n\t\tif len(self.queue) >= size:\n\t\t\tval = self.queue.pop(0)\n\t\t\tself.curr_sum -= val\n\n\t\tself.curr_sum += num\n\t\tself.queue.append(num)\n\t\treturn float(self.curr_sum)/len(self.queue)\n\n\t\n\nsolution = Solution()\nwindow_size = int(input())\nnum = int(input())\nwhile num != -1:\n\tprint solution.movingAverage(num, window_size)\n\tnum = int(input())",
        "output": "use std::collections::VecDeque;\n\nstruct MovingAverage {\n    queue: VecDeque<i32>,\n    sum: i32,\n    size: usize,\n}\n\nimpl MovingAverage {\n    fn new(size: i32) -> Self {\n        MovingAverage {\n            queue: VecDeque::new(),\n            sum: 0,\n            size: size as usize,\n        }\n    }\n\n    fn next(&mut self, val: i32) -> f64 {\n        self.sum += val;\n        self.queue.push_back(val);\n        if self.queue.len() > self.size {\n            if let Some(front) = self.queue.pop_front() {\n                self.sum -= front;\n            }\n        }\n        self.sum as f64 / self.queue.len() as f64\n    }\n}\n\n#[test]\nfn test() {\n    use assert_approx_eq::assert_approx_eq;\n    let mut m = MovingAverage::new(3);\n    assert_approx_eq!(m.next(1), 1f64);\n    assert_approx_eq!(m.next(10), 5.5f64);\n    assert_approx_eq!(m.next(3), 14f64 / 3f64);\n    assert_approx_eq!(m.next(5), 6f64);\n}\n"
    },
    {
        "input": "\n\nclass Solution(object):\n    def lengthLongestPath(self, input):\n        \n        if not input:\n            return 0\n        directories = input.split('\\n')\n        stack = [[-1, 0]] \n        result = 0\n        for direct in directories:\n            n_tabs = direct.count('\\t')\n            while stack and stack[-1][0] >= n_tabs:\n                stack.pop()\n            if \".\" in direct:\n                result = max(result, stack[-1][1] + len(direct)-n_tabs)\n            stack.append([n_tabs, stack[-1][1] + len(direct) + 1 -n_tabs])\n        return result\n",
        "output": "struct Solution;\n\nstruct Folder {\n    level: usize,\n    length: usize,\n}\n\nimpl Solution {\n    fn length_longest_path(input: String) -> i32 {\n        let mut stack: Vec<Folder> = vec![];\n        let mut folder_length = 0;\n        let mut max = 0;\n        for line in input.split('\\n') {\n            let s = line.chars();\n            let mut level: usize = 0;\n            let mut is_folder = true;\n            for c in s {\n                match c {\n                    '\\t' => {\n                        level += 1;\n                    }\n                    '.' => {\n                        is_folder = false;\n                        break;\n                    }\n                    _ => {}\n                }\n            }\n            let name = line[level..].to_string();\n            while let Some(top) = stack.pop() {\n                if top.level >= level {\n                    folder_length -= top.length;\n                } else {\n                    stack.push(top);\n                    break;\n                }\n            }\n            if is_folder {\n                let length = name.len() + 1;\n                let folder = Folder { level, length };\n                stack.push(folder);\n                folder_length += length;\n            } else {\n                max = max.max(name.len() + folder_length);\n            }\n        }\n        max as i32\n    }\n}\n\n#[test]\nfn test() {\n    let input =\n        \"dir\\n\\tsubdir1\\n\\t\\tfile1.ext\\n\\t\\tsubsubdir1\\n\\tsubdir2\\n\\t\\tsubsubdir2\\n\\t\\t\\tfile2.ext\"\n            .to_string();\n    let res = 32;\n    assert_eq!(Solution::length_longest_path(input), res);\n}\n"
    },
    {
        "input": "\n\nclass Solution(object):\n\tdef lengthOfLongestSubstringKDistinct(self, S, K):\n\t\tcharMapping, start = {}, 0\n\t\tresult = 0\n\t\tfor end, s in enumerate(S):\n\t\t\tif s in charMapping:\n\t\t\t\tcharMapping[s] += 1\n\t\t\telse:\n\t\t\t\tcharMapping[s] = 1\n\n\t\t\tif len(charMapping) <= K:\n\t\t\t\tresult = max(result, end-start+1)\n\t\t\telse:\n\t\t\t\twhile len(charMapping) > K :\n\t\t\t\t\tcharacter = S[start]\n\t\t\t\t\tfreq = charMapping[character]\n\t\t\t\t\tif freq == 1:\n\t\t\t\t\t\tdel charMapping[character]\n\t\t\t\t\telse:\n\t\t\t\t\t\tcharMapping[character] -= 1\n\t\t\t\t\tstart += 1\n\t\treturn result\n\nif __name__ == '__main__':\n\tprint Solution().lengthOfLongestSubstringKDistinct(\"abcadcacacaca\", 3)",
        "output": "struct Solution;\n\nuse std::collections::HashMap;\n\nimpl Solution {\n    fn length_of_longest_substring_k_distinct(s: String, k: i32) -> i32 {\n        let k = k as usize;\n        let n = s.len();\n        let mut start = 0;\n        let mut end = 0;\n        let s: Vec<char> = s.chars().collect();\n        let mut count: HashMap<char, usize> = HashMap::new();\n        let mut res = 0;\n        while end < n {\n            *count.entry(s[end]).or_default() += 1;\n            end += 1;\n            while count\n                .values()\n                .fold(0, |acc, &v| acc + if v > 0 { 1 } else { 0 })\n                > k\n            {\n                *count.get_mut(&s[start]).unwrap() -= 1;\n                start += 1;\n            }\n            res = res.max(end - start);\n        }\n        res as i32\n    }\n}\n\n#[test]\nfn test() {\n    let s = \"eceba\".to_string();\n    let k = 2;\n    let res = 3;\n    assert_eq!(Solution::length_of_longest_substring_k_distinct(s, k), res);\n    let s = \"aa\".to_string();\n    let k = 1;\n    let res = 2;\n    assert_eq!(Solution::length_of_longest_substring_k_distinct(s, k), res);\n}\n"
    },
    {
        "input": "\n\n\nclass Solution(object):\n\tdef shortestDistance(self, grid):\n\t\tif not grid:\n\t\t\treturn -1\n\n\t\tdef bfs(grid, distance_reach_map, row, col):\n\t\t\tif(row < 0 or row > len(grid) or col < 0 or col > len(grid[0])):\n\t\t\t\treturn\n\t\t\tqueue = [[row, col]]\n\t\t\tqdist = [1]\n\n\t\t\tdirection = [[-1, 0], [0, 1], [1, 0], [0, -1]]\n\t\t\twhile queue:\n\t\t\t\tx, y = queue.pop(0)\n\t\t\t\tcurr_dist = qdist.pop(0)\n\n\t\t\t\tfor dx, dy in direction:\n\t\t\t\t\tnew_x, new_y = x+dx, y+dy\n\t\t\t\t\tif((0 <= new_x < len(grid)) and (0 <= new_y < len(grid[0])) and grid[new_x][new_y] == 0):\n\t\t\t\t\t\tgrid[new_x][new_y] = -1\n\t\t\t\t\t\tqueue.append([new_x, new_y])\n\n\t\t\t\t\t\t\n\t\t\t\t\t\ttemp = distance_reach_map[new_x][new_y]\n\t\t\t\t\t\tdist, reach = temp[0], temp[1]\n\t\t\t\t\t\tdist += curr_dist\n\t\t\t\t\t\treach += 1\n\t\t\t\t\t\tdistance_reach_map[new_x][new_y] = [dist, reach]\n\t\t\t\t\t\tqdist.append(curr_dist+1)\n\n\t\t\tfor row in range(len(grid)):\n\t\t\t\tfor col in range(len(grid[0])):\n\t\t\t\t\tif grid[row][col] == -1:\n\t\t\t\t\t\tgrid[row][col] =0\n\n\t\tr_len, c_len = len(grid), len(grid[0])\n\t\tdistance_reach_map = [[[0, 0]]*c_len for _ in range(r_len)]\n\t\tbuildings = 0\n\t\tfor row in range(len(grid)):\n\t\t\tfor col in range(len(grid[0])):\n\t\t\t\tif grid[row][col] == 1:\n\t\t\t\t\tbfs(grid, distance_reach_map, row, col)\n\t\t\t\t\tbuildings += 1\n\n\t\tresult = float('inf')\n\t\tfor row in range(r_len):\n\t\t\tfor col in range(c_len):\n\t\t\t\tdist, reach = distance_reach_map[row][col]\n\t\t\t\tif reach == buildings:\n\t\t\t\t\tresult = min(result, dist)\n\t\treturn result\n\nsolution = Solution()\ngrid = [[1, 0, 2, 0, 1], \n\t\t[0, 0, 0, 0, 0], \n\t\t[0, 0, 1, 0 ,0]]\nprint solution.shortestDistance(grid)\n\n\n\n\n\n",
        "output": "struct Solution;\n\nuse std::collections::VecDeque;\n\nimpl Solution {\n    fn shortest_distance(grid: Vec<Vec<i32>>) -> i32 {\n        let n = grid.len();\n        let m = grid[0].len();\n        let mut dist = vec![vec![0; m]; n];\n        let mut count = vec![vec![0; m]; n];\n        let mut building = 0;\n        for i in 0..n {\n            for j in 0..m {\n                if grid[i][j] == 1 {\n                    building += 1;\n                }\n            }\n        }\n        for i in 0..n {\n            for j in 0..m {\n                if grid[i][j] == 1 {\n                    Self::bfs(i, j, &mut dist, &mut count, &grid, m, n)\n                }\n            }\n        }\n        let mut res = std::usize::MAX;\n        for i in 0..n {\n            for j in 0..m {\n                if grid[i][j] == 0 && count[i][j] == building {\n                    res = res.min(dist[i][j]);\n                }\n            }\n        }\n        if res == std::usize::MAX {\n            -1\n        } else {\n            res as i32\n        }\n    }\n\n    fn bfs(\n        i: usize,\n        j: usize,\n        dist: &mut Vec<Vec<usize>>,\n        count: &mut Vec<Vec<usize>>,\n        grid: &[Vec<i32>],\n        m: usize,\n        n: usize,\n    ) {\n        let mut visited = vec![vec![false; m]; n];\n        let mut queue: VecDeque<(usize, usize, usize)> = VecDeque::new();\n        queue.push_back((i, j, 0));\n        while let Some((i, j, d)) = queue.pop_front() {\n            if i > 0 && grid[i - 1][j] == 0 && !visited[i - 1][j] {\n                visited[i - 1][j] = true;\n                dist[i - 1][j] += d + 1;\n                count[i - 1][j] += 1;\n                queue.push_back((i - 1, j, d + 1));\n            }\n            if j > 0 && grid[i][j - 1] == 0 && !visited[i][j - 1] {\n                visited[i][j - 1] = true;\n                dist[i][j - 1] += d + 1;\n                count[i][j - 1] += 1;\n                queue.push_back((i, j - 1, d + 1));\n            }\n            if i + 1 < n && grid[i + 1][j] == 0 && !visited[i + 1][j] {\n                visited[i + 1][j] = true;\n                dist[i + 1][j] += d + 1;\n                count[i + 1][j] += 1;\n                queue.push_back((i + 1, j, d + 1));\n            }\n            if j + 1 < m && grid[i][j + 1] == 0 && !visited[i][j + 1] {\n                visited[i][j + 1] = true;\n                dist[i][j + 1] += d + 1;\n                count[i][j + 1] += 1;\n                queue.push_back((i, j + 1, d + 1));\n            }\n        }\n    }\n}\n\n#[test]\nfn test() {\n    let grid = vec_vec_i32![[1, 0, 2, 0, 1], [0, 0, 0, 0, 0], [0, 0, 1, 0, 0]];\n    let res = 7;\n    assert_eq!(Solution::shortest_distance(grid), res);\n    let grid = vec_vec_i32![\n        [1, 1, 1, 1, 1, 0],\n        [0, 0, 0, 0, 0, 1],\n        [0, 1, 1, 0, 0, 1],\n        [1, 0, 0, 1, 0, 1],\n        [1, 0, 1, 0, 0, 1],\n        [1, 0, 0, 0, 0, 1],\n        [0, 1, 1, 1, 1, 0]\n    ];\n    let res = 88;\n    assert_eq!(Solution::shortest_distance(grid), res);\n}\n"
    },
    {
        "input": "\n\nclass TreeNode(object):\n    def __init__(self, val):\n        self.right = None\n        self.left = None\n        self.val = val\n        self.count = 1\n        \nclass Solution(object):\n    def countSmaller(self, nums):\n        \n        if len(nums) == 0:\n            return []\n        \n        node = TreeNode(nums[len(nums)-1])\n        result = [0]\n        for index in range(len(nums)-2, -1, -1):\n            result.append(self.insertNode(node, nums[index]))\n            \n        return result[::-1]\n    \n    def insertNode(self, node, val):\n        totalCount = 0\n        while True:\n            if val <= node.val:\n                node.count += 1\n                if node.left is None:\n                    node.left = TreeNode(val)\n                    break\n                else:\n                    node = node.left\n            else:\n                totalCount += node.count\n                if node.right is None:\n                    node.right = TreeNode(val)\n                    break\n                else:\n                    node = node.right\n                    \n        return totalCount\n                ",
        "output": "struct Solution;\n\nuse std::collections::BTreeMap;\n\nimpl Solution {\n    fn count_smaller(nums: Vec<i32>) -> Vec<i32> {\n        let mut count: BTreeMap<i32, usize> = BTreeMap::new();\n        let n = nums.len();\n        let mut res = vec![0; n];\n        for i in (0..n).rev() {\n            let mut sum = 0;\n            let x = nums[i];\n            for (_, v) in count.range(..x) {\n                sum += v;\n            }\n            *count.entry(x).or_default() += 1;\n            res[i] = sum as i32;\n        }\n        res\n    }\n}\n\n#[test]\nfn test() {\n    let nums = vec![5, 2, 6, 1];\n    let res = vec![2, 1, 1, 0];\n    assert_eq!(Solution::count_smaller(nums), res);\n}\n"
    },
    {
        "input": "\n\nclass Solution(object):\n    def isPowerOfThree(self, n):\n        \n        if n <= 0:\n        \treturn False\n\n        import math\n        return (math.log10(n)/math.log10(3))%1 == 0",
        "output": "struct Solution;\n\nimpl Solution {\n    fn is_power_of_three(n: i32) -> bool {\n        n > 0 && 1_162_261_467 % n == 0\n    }\n}\n\n#[test]\nfn test() {\n    assert_eq!(Solution::is_power_of_three(27), true);\n    assert_eq!(Solution::is_power_of_three(0), false);\n    assert_eq!(Solution::is_power_of_three(9), true);\n    assert_eq!(Solution::is_power_of_three(45), false);\n}\n"
    },
    {
        "input": "\n\nclass Solution(object):\n    def longestIncreasingPath(self, matrix):\n        \n        result = 0\n        dp = [[0 for col in range(len(matrix[0]))] for row in range(len(matrix))]\n        for row in range(len(matrix)):\n            for col in range(len(matrix[0])):\n                result = max(result, self.dfs(matrix, dp, row, col))\n                \n        return result\n    \n    def dfs(self, matrix, dp, i, j):\n        if dp[i][j]:\n            return dp[i][j]\n        max_depth = 0\n        direction = [[0, 1], [0, -1], [1, 0], [-1, 0]]\n        for d in direction:\n            x, y = i + d[0], j + d[1]\n            if 0 <= x < len(matrix) and 0 <= y < len(matrix[0]) and matrix[x][y] < matrix[i][j] :\n                max_depth = max(max_depth, self.dfs(matrix, dp, x, y))\n                \n        dp[i][j] = max_depth + 1\n        return dp[i][j]\n        ",
        "output": "struct Solution;\n\nimpl Solution {\n    fn longest_increasing_path(matrix: Vec<Vec<i32>>) -> i32 {\n        let n = matrix.len();\n        if n == 0 {\n            return 0;\n        }\n        let m = matrix[0].len();\n        let mut memo = vec![vec![0; m]; n];\n        let mut res = 0;\n        for i in 0..n {\n            for j in 0..m {\n                if memo[i][j] == 0 {\n                    memo[i][j] = Self::dfs(i, j, &mut memo, &matrix);\n                    res = res.max(memo[i][j]);\n                }\n            }\n        }\n        res\n    }\n\n    fn dfs(i: usize, j: usize, memo: &mut Vec<Vec<i32>>, matrix: &[Vec<i32>]) -> i32 {\n        if memo[i][j] != 0 {\n            return memo[i][j];\n        }\n        let n = matrix.len();\n        let m = matrix[0].len();\n        let mut res = 1;\n        if i > 0 && matrix[i - 1][j] > matrix[i][j] {\n            res = res.max(Self::dfs(i - 1, j, memo, matrix) + 1);\n        }\n        if j > 0 && matrix[i][j - 1] > matrix[i][j] {\n            res = res.max(Self::dfs(i, j - 1, memo, matrix) + 1);\n        }\n        if i + 1 < n && matrix[i + 1][j] > matrix[i][j] {\n            res = res.max(Self::dfs(i + 1, j, memo, matrix) + 1);\n        }\n        if j + 1 < m && matrix[i][j + 1] > matrix[i][j] {\n            res = res.max(Self::dfs(i, j + 1, memo, matrix) + 1);\n        }\n        memo[i][j] = res;\n        res\n    }\n}\n\n#[test]\nfn test() {\n    let matrix = vec_vec_i32![[9, 9, 4], [6, 6, 8], [2, 1, 1]];\n    let res = 4;\n    assert_eq!(Solution::longest_increasing_path(matrix), res);\n}\n"
    },
    {
        "input": "\n\nclass Solution(object):\n    def intersect(self, nums1, nums2):\n        \n        \n        nums1.sort()\n        nums2.sort()\n\n        index_i, index_j = 0, 0\n        result = []\n        while index_i < len(nums1) and index_j < len(nums2):\n        \tif nums1[index_i] == nums2[index_j]:\n        \t\tresult.append(nums1[index_i])\n        \t\tindex_i += 1\n        \t\tindex_j += 1\n        \telif nums1[index_i] > nums2[index_j]:\n        \t\tindex_j += 1\n        \telse:\n        \t\tindex_i += 1\n        return result",
        "output": "struct Solution;\n\nuse std::collections::HashMap;\nuse std::collections::HashSet;\n\nimpl Solution {\n    fn intersect(nums1: Vec<i32>, nums2: Vec<i32>) -> Vec<i32> {\n        let mut hm1: HashMap<i32, i32> = HashMap::new();\n        let hs1: HashSet<i32> = nums1.clone().into_iter().collect();\n        nums1.iter().for_each(|&x| {\n            *hm1.entry(x).or_default() += 1;\n        });\n        let mut hm2: HashMap<i32, i32> = HashMap::new();\n        let hs2: HashSet<i32> = nums2.clone().into_iter().collect();\n        nums2.iter().for_each(|&x| {\n            *hm2.entry(x).or_default() += 1;\n        });\n        let bitand = &hs1 & &hs2;\n        let mut res: Vec<i32> = vec![];\n        bitand.iter().for_each(|&x| {\n            let c1 = hm1[&x];\n            let c2 = hm2[&x];\n            let min = i32::min(c1, c2);\n            (0..min).for_each(|_| {\n                res.push(x);\n            });\n        });\n        res\n    }\n}\n\n#[test]\nfn test() {\n    let nums1 = vec![1, 2, 2, 1];\n    let nums2 = vec![2, 2];\n    assert_eq!(Solution::intersect(nums1, nums2), vec![2, 2]);\n}\n"
    },
    {
        "input": "\n\nclass Solution(object):\n    def longestSubstring(self, s, k):\n        \n        dict = {}\n        for c in s:\n            if c not in dict:\n                dict[c] = 0\n            dict[c] += 1\n        if all(dict[i] >= k for i in dict):\n            return len(s)\n        \n        \n        longest = 0\n        start = 0\n        for i in range(len(s)):\n            c = s[i]\n            if dict[c] < k:\n                longest = max(longest, self.longestSubstring(s[start:i], k))\n                start = i + 1\n                \n        return max(longest, self.longestSubstring(s[start:], k))\n\t\t\t\t",
        "output": "struct Solution;\nuse std::collections::HashMap;\n\nimpl Solution {\n    fn longest_substring(s: String, k: i32) -> i32 {\n        let mut hm: HashMap<char, usize> = HashMap::new();\n        for c in s.chars() {\n            *hm.entry(c).or_default() += 1;\n        }\n        for (c, v) in hm {\n            if v < k as usize {\n                return s\n                    .split_terminator(c)\n                    .map(|s| Self::longest_substring(s.to_string(), k))\n                    .max()\n                    .unwrap();\n            }\n        }\n        s.len() as i32\n    }\n}\n\n#[test]\nfn test() {\n    let s = \"aaabb\".to_string();\n    let k = 3;\n    let res = 3;\n    assert_eq!(Solution::longest_substring(s, k), res);\n    let s = \"ababbc\".to_string();\n    let k = 2;\n    let res = 5;\n    assert_eq!(Solution::longest_substring(s, k), res);\n    let s = \"ababbc\".to_string();\n    let k = 3;\n    let res = 0;\n    assert_eq!(Solution::longest_substring(s, k), res);\n}\n"
    },
    {
        "input": "\n\nclass Solution(object):\n    def increasingTriplet(self, nums):\n        \n        \n        first, second = float('inf'), float('inf')\n        for val in nums:\n        \tif val <= first:\n        \t\tfirst = val\n        \telif val <= second:\n        \t\tsecond = val\n        \telse:\n        \t\treturn True\n\n        return False",
        "output": "struct Solution;\n\nimpl Solution {\n    fn increasing_triplet(nums: Vec<i32>) -> bool {\n        let mut dp: Vec<i32> = vec![];\n        for x in nums {\n            if let Err(i) = dp.binary_search(&x) {\n                if i == dp.len() {\n                    dp.push(x)\n                } else {\n                    dp[i] = x;\n                }\n            }\n            if dp.len() == 3 {\n                return true;\n            }\n        }\n        false\n    }\n}\n\n#[test]\nfn test() {\n    let nums = vec![1, 2, 3, 4, 5];\n    let res = true;\n    assert_eq!(Solution::increasing_triplet(nums), res);\n    let nums = vec![5, 4, 3, 2, 1];\n    let res = false;\n    assert_eq!(Solution::increasing_triplet(nums), res);\n}\n"
    },
    {
        "input": "\n\nclass Solution(object):\n\tdef numberOfPatterns(self, m, n):\n\t\tdef dfs(reamin, current, visited, skip):\n\t\t\tif reamin < 0:\n\t\t\t\treturn 0\n\t\t\tif reamin == 0:\n\t\t\t\treturn 1\n\t\t\tvisited[current] = True \n\t\t\tresult = 0\n\t\t\tfor index in range(1, 10):\n\t\t\t\tif not visited[index] and (skip[current][index] == 0 || visited[skip[current][index]])\n\t\t\t\t\tresult += dfs(reamin-1, index, visited, skip)\n\t\t\tvisited[current] = False\n\t\t\treturn result\n\n\t\tskip = [[0 for _ in range(10)] for _ in range(10)]\n\t\tskip[1][3] = skip[3][1] = 2\n        skip[1][7] = skip[7][1] = 4\n        skip[3][9] = skip[9][3] = 6\n        skip[7][9] = skip[9][7] = 8\n        skip[1][9] = skip[9][1] = skip[2][8] = skip[8][2] = skip[3][7] = skip[7][3] = skip[4][6] = skip[6][4] = 5\n        visited = [False for _ in range(10)]\n\n\t\tresult = 0\n\t\tfor index in range(m, n):\n\t\t\tresult += dfs(index-1, 1, visited, skip)\n\t\t\tresult += dfs(index-1, 2, visited, skip)\n\t\t\tresult += dfs(index-1, 5, visited, skip)\n\t\treturn result",
        "output": "struct Solution;\n\nimpl Solution {\n    fn number_of_patterns(m: i32, n: i32) -> i32 {\n        let mut res = 0;\n        let mut visited = vec![vec![false; 3]; 3];\n        Self::dfs(0, None, &mut visited, &mut res, m as usize, n as usize);\n        res as i32\n    }\n\n    fn dfs(\n        start: usize,\n        prev: Option<(usize, usize)>,\n        visited: &mut Vec<Vec<bool>>,\n        all: &mut usize,\n        m: usize,\n        n: usize,\n    ) {\n        if start >= m {\n            *all += 1;\n        }\n        if start == n {\n            return;\n        }\n        if let Some((r, c)) = prev {\n            for i in 0..3 {\n                for j in 0..3 {\n                    if !visited[i][j] {\n                        if ((i == r && j + c == 2)\n                            || (j == c && i + r == 2)\n                            || (i + r == 2 && j + c == 2))\n                            && !visited[(i + r) / 2][(j + c) / 2]\n                        {\n                            continue;\n                        }\n                        visited[i][j] = true;\n                        Self::dfs(start + 1, Some((i, j)), visited, all, m, n);\n                        visited[i][j] = false;\n                    }\n                }\n            }\n        } else {\n            for i in 0..3 {\n                for j in 0..3 {\n                    visited[i][j] = true;\n                    Self::dfs(start + 1, Some((i, j)), visited, all, m, n);\n                    visited[i][j] = false;\n                }\n            }\n        }\n    }\n}\n\n#[test]\nfn test() {\n    let m = 1;\n    let n = 1;\n    let res = 9;\n    assert_eq!(Solution::number_of_patterns(m, n), res);\n    let m = 1;\n    let n = 2;\n    let res = 65;\n    assert_eq!(Solution::number_of_patterns(m, n), res);\n}\n"
    },
    {
        "input": "\n\nclass Solution(object):\n    def firstUniqChar(self, s):\n        \n        letters='abcdefghijklmnopqrstuvwxyz'\n        index=[s.index(l) for l in letters if s.count(l) == 1]\n        return min(index) if len(index) > 0 else -1",
        "output": "struct Solution;\n\nuse std::collections::HashMap;\n\nimpl Solution {\n    fn first_uniq_char(s: String) -> i32 {\n        let mut hm: HashMap<char, i32> = HashMap::new();\n        for c in s.chars() {\n            let e = hm.entry(c).or_default();\n            *e += 1;\n        }\n        for (i, c) in s.chars().enumerate() {\n            if let Some(1) = hm.get(&c) {\n                return i as i32;\n            }\n        }\n        -1\n    }\n}\n\n#[test]\nfn test() {\n    assert_eq!(Solution::first_uniq_char(\"leetcode\".to_string()), 0);\n    assert_eq!(Solution::first_uniq_char(\"loveleetcode\".to_string()), 2);\n}\n"
    },
    {
        "input": "\n\nclass Solution(object):\n    def removeInvalidParentheses(self, s):\n        \n        if not s:\n        \treturn [\"\"]\n\n        def isValid(s):\n        \tcount = 0\n        \tfor char in s:\n        \t\tif char == '(':\n        \t\t\tcount += 1\n        \t\telif char == ')':\n        \t\t\tcount -= 1\n        \t\tif count < 0:\n        \t\t\treturn False\n        \treturn (count==0)\n\n        queue, result = [s], []\n        visited = set()\n        visited.add(s)\n        level = False\n\n        while queue:\n        \tnew_str = queue.pop(0)\n        \tif isValid(new_str):\n        \t\tresult.append(new_str)\n        \t\tlevel = True\n\n        \tif level:\n        \t\tcontinue\n\n        \tfor index in range(len(new_str)):\n        \t\tif not (new_str[index] == \"(\" or new_str[index] == \")\"):\n        \t\t\tcontinue\n        \t\tpartition_str = new_str[0:index] + new_str[index+1:]\n        \t\tif partition_str not in visited:\n\t        \t\tqueue.append(partition_str)\n\t        \t\tvisited.add(partition_str)\n        return result\n\n\n",
        "output": "struct Solution;\n\nuse std::collections::HashSet;\n\nimpl Solution {\n    fn remove_invalid_parentheses(s: String) -> Vec<String> {\n        let mut cur = vec![];\n        let s: Vec<char> = s.chars().collect();\n        let n = s.len();\n        let mut min = std::usize::MAX;\n        let mut res: HashSet<String> = HashSet::new();\n        Self::dfs(0, 0, 0, &mut cur, &mut res, &mut min, &s, n);\n        res.into_iter().collect()\n    }\n\n    fn dfs(\n        start: usize,\n        left: usize,\n        remove: usize,\n        cur: &mut Vec<char>,\n        all: &mut HashSet<String>,\n        min: &mut usize,\n        s: &[char],\n        n: usize,\n    ) {\n        if start == n {\n            if left != 0 {\n                return;\n            }\n            if remove > *min {\n                return;\n            }\n            if remove < *min {\n                *min = remove;\n                all.clear();\n            }\n            let s = cur.iter().copied().collect();\n            all.insert(s);\n        } else {\n            match s[start] {\n                '(' => {\n                    cur.push('(');\n                    Self::dfs(start + 1, left + 1, remove, cur, all, min, s, n);\n                    cur.pop();\n                    Self::dfs(start + 1, left, remove + 1, cur, all, min, s, n);\n                }\n                ')' => {\n                    if left > 0 {\n                        cur.push(')');\n                        Self::dfs(start + 1, left - 1, remove, cur, all, min, s, n);\n                        cur.pop();\n                    }\n                    Self::dfs(start + 1, left, remove + 1, cur, all, min, s, n);\n                }\n                _ => {\n                    cur.push(s[start]);\n                    Self::dfs(start + 1, left, remove, cur, all, min, s, n);\n                    cur.pop();\n                }\n            }\n        }\n    }\n}\n\n#[test]\nfn test() {\n    let s = \"()())()\".to_string();\n    let mut res = vec_string![\"()()()\", \"(())()\"];\n    let mut ans = Solution::remove_invalid_parentheses(s);\n    ans.sort();\n    res.sort();\n    assert_eq!(ans, res);\n    let s = \"(a)())()\".to_string();\n    let mut res = vec_string![\"(a)()()\", \"(a())()\"];\n    let mut ans = Solution::remove_invalid_parentheses(s);\n    ans.sort();\n    res.sort();\n    assert_eq!(ans, res);\n    let s = \")(\".to_string();\n    let mut res = vec_string![\"\"];\n    let mut ans = Solution::remove_invalid_parentheses(s);\n    ans.sort();\n    res.sort();\n    assert_eq!(ans, res);\n    let s = \")(f\".to_string();\n    let mut res = vec_string![\"f\"];\n    let mut ans = Solution::remove_invalid_parentheses(s);\n    ans.sort();\n    res.sort();\n    assert_eq!(ans, res);\n}\n"
    },
    {
        "input": "\n\n\n\n\n\n\n\nclass Solution(object):\n    def oddEvenList(self, head):\n        \n        if  not head:\n        \treturn None\n\n        odd, even = head, head.next\n        evenHead = even\n        while even and even.next:\n        \todd.next = even.next\n        \todd = odd.next\n        \teven.next = odd.next\n        \teven = even.next\n\n        odd.next = evenHead\n        return head",
        "output": "struct Solution;\nuse rustgym_util::*;\n\nimpl Solution {\n    fn odd_even_list(mut head: ListLink) -> ListLink {\n        let mut odd: Vec<ListLink> = vec![];\n        let mut even: Vec<ListLink> = vec![];\n        let mut i = 1;\n        while let Some(mut node) = head {\n            head = node.next.take();\n            if i % 2 == 1 {\n                odd.push(Some(node));\n            } else {\n                even.push(Some(node));\n            }\n            i += 1;\n        }\n        let mut res: ListLink = None;\n        while let Some(mut link) = even.pop() {\n            link.as_mut().unwrap().next = res;\n            res = link;\n        }\n        while let Some(mut link) = odd.pop() {\n            link.as_mut().unwrap().next = res;\n            res = link;\n        }\n        res\n    }\n}\n\n#[test]\nfn test() {\n    let head = list![1, 2, 3, 4, 5];\n    let res = list![1, 3, 5, 2, 4];\n    assert_eq!(Solution::odd_even_list(head), res);\n    let head = list![2, 1, 3, 5, 6, 4, 7];\n    let res = list![2, 3, 6, 7, 1, 5, 4];\n    assert_eq!(Solution::odd_even_list(head), res);\n}\n"
    },
    {
        "input": "\n\nclass Solution(object):\n    def validUtf8(self, data):\n        \n        seveneth_mask = 1 << 7\n        sixth_mask = 1 << 6\n        no_bytes = 0\n        \n        if len(data) == 1:\n            return not(data[0] & seveneth_mask)\n        \n        for num in data:\n            if no_bytes == 0:\n                mask = 1 << 7\n                \n                while num & mask:\n                    no_bytes += 1\n                    mask >>= 1\n                    \n                if no_bytes == 0:\n                    continue\n                    \n                if no_bytes == 1 or no_bytes > 4:\n                    return False\n            else:\n                if not(num & seveneth_mask and not(num & sixth_mask)):\n                    return False\n            no_bytes -= 1\n        return no_bytes == 0\n",
        "output": "struct Solution;\n\nimpl Solution {\n    fn valid_utf8(data: Vec<i32>) -> bool {\n        let mut count = 0;\n        for x in data {\n            if count == 0 {\n                if x >> 3 & 0b11111 == 0b11110 {\n                    count += 3;\n                    continue;\n                }\n                if x >> 4 & 0b1111 == 0b1110 {\n                    count += 2;\n                    continue;\n                }\n                if x >> 5 & 0b111 == 0b110 {\n                    count += 1;\n                    continue;\n                }\n                if x >> 7 & 0b1 == 0 {\n                    continue;\n                }\n            } else {\n                if x >> 6 & 0b11 == 0b10 {\n                    count -= 1;\n                    continue;\n                }\n            }\n            return false;\n        }\n        count == 0\n    }\n}\n\n#[test]\nfn test() {\n    let data = vec![197, 130, 1];\n    assert_eq!(Solution::valid_utf8(data), true);\n    let data = vec![235, 140, 4];\n    assert_eq!(Solution::valid_utf8(data), false);\n}\n"
    },
    {
        "input": "\n\nclass RandomizedSet(object):\n\n    def __init__(self):\n        \n        self.values = []\n        self.positions = {}\n        \n\n    def insert(self, val):\n        \n        if val not in self.positions:\n        \tself.values.append(val)\n        \tself.positions[val] = len(self.values) - 1\n        \treturn True\n        return False\n        \n\n    def remove(self, val):\n        \n        if val in self.positions:\n        \tvalIdx, lastEle = self.positions[val], self.values[-1]\n        \tself.positions[lastEle], self.values[valIdx] = valIdx, lastEle\n        \tself.values.pop()\n        \tself.positions.pop(val, 0)\n        \treturn True\n        return False\n\n    def getRandom(self):\n        \n        return self.values[random.randint(0, len(self.values)-1)]\n\n\n\n\n\n\n",
        "output": "extern crate rand;\nuse rand::prelude::*;\nuse std::collections::HashMap;\n\n#[derive(Default)]\nstruct RandomizedSet {\n    rng: ThreadRng,\n    indexes: HashMap<i32, usize>,\n    values: Vec<i32>,\n}\n\nimpl RandomizedSet {\n    fn new() -> Self {\n        RandomizedSet {\n            rng: rand::thread_rng(),\n            indexes: HashMap::new(),\n            values: vec![],\n        }\n    }\n    fn insert(&mut self, val: i32) -> bool {\n        if self.indexes.get(&val).is_some() {\n            false\n        } else {\n            self.indexes.insert(val, self.values.len());\n            self.values.push(val);\n            true\n        }\n    }\n    fn remove(&mut self, val: i32) -> bool {\n        if let Some(index) = self.indexes.remove(&val) {\n            let last_index = self.values.len() - 1;\n            let last_value = self.values[last_index];\n            if index != last_index {\n                self.values.swap(index, last_index);\n                let old_index = self.indexes.get_mut(&last_value).unwrap();\n                *old_index = index;\n            }\n            self.values.pop();\n            true\n        } else {\n            false\n        }\n    }\n\n    fn get_random(&mut self) -> i32 {\n        let index = self.rng.gen_range(0, self.values.len()) as usize;\n        self.values[index]\n    }\n}\n\n#[test]\nfn test() {\n    let mut obj = RandomizedSet::new();\n    assert_eq!(obj.insert(1), true);\n    assert_eq!(obj.remove(2), false);\n    assert_eq!(obj.insert(2), true);\n    assert_eq!(obj.remove(1), true);\n    assert_eq!(obj.insert(2), false);\n}\n"
    },
    {
        "input": "\n\nclass Solution(object):\n    def topKFrequent(self, nums, k):\n        \n        if not nums:\n        \treturn []\n        frequency = {}\n        for num in nums:\n        \tif num in frequency:\n        \t\tfrequency[num] += 1\n        \telse:\n        \t\tfrequency[num] = 1\n\n       \tresult = []\n       \timport heapq\n       \theap = []\n\n       \tfor key, value in frequency.iteritems():\n       \t\theapq.heappush(heap, (-value, key))\n\n       \tfor _ in range(k):\n       \t\tresult.append(heapq.heappop(heap)[1])\n       \treturn result",
        "output": "struct Solution;\nuse std::cmp::Reverse;\nuse std::collections::BinaryHeap;\nuse std::collections::HashMap;\n\ntype Pair = (Reverse<usize>, i32);\n\nimpl Solution {\n    fn top_k_frequent(nums: Vec<i32>, k: i32) -> Vec<i32> {\n        let k = k as usize;\n        let mut hm: HashMap<i32, usize> = HashMap::new();\n        let mut pq: BinaryHeap<Pair> = BinaryHeap::new();\n        for x in nums {\n            *hm.entry(x).or_default() += 1;\n        }\n        for (x, f) in hm {\n            pq.push((Reverse(f), x));\n            if pq.len() > k {\n                pq.pop();\n            }\n        }\n        pq.into_iter().map(|p| p.1).rev().collect()\n    }\n}\n\n#[test]\nfn test() {\n    let nums = vec![1, 1, 1, 2, 2, 3];\n    let k = 2;\n    let res = vec![1, 2];\n    assert_eq!(Solution::top_k_frequent(nums, k), res);\n}\n"
    },
    {
        "input": "\n\nclass Node(object):\n    def __init__(self, val ,start, end):\n        self.sum = val\n        self.right, self.left = None, None\n        self.range= [start, end]\n        \nclass SegementTree(object):\n    def __init__(self, size):\n        self.root = self._build_segment_tree(0, size-1)\n        \n    def _build_segment_tree(self, start, end):\n        if start > end:\n            return None\n        node = Node(0, start, end)\n        if start == end:\n            return node\n        mid = (start+end)/2\n        node.left, node.right = self._build_segment_tree(start, mid), self._build_segment_tree(mid+1, end)\n        return node\n    \n    def update(self, index, val, root=None):\n        root = root or self.root\n        if index < root.range[0] or index > root.range[1]:\n            return\n        root.sum += val\n        if index == root.range[0] == root.range[1]:\n            return \n        self.update(index, val, root.left)\n        self.update(index, val, root.right)\n            \n    def range_sum(self, start, end, root=None):\n        root = root or self.root\n        if end < root.range[0] or start > root.range[1]:\n            return 0\n        if start <= root.range[0] and end >= root.range[1]:\n            return root.sum\n        return self.range_sum(start, end, root.left) + self.range_sum(start, end, root.right)\n        \n        \nclass NumArray(object):\n\n    def __init__(self, nums):\n        \n        self.nums = nums\n        self.segment_tree = SegementTree(len(nums))\n        for index, num in enumerate(nums):\n            self.segment_tree.update(index, num)\n        \n\n    def update(self, i, val):\n        \n        diff = val-self.nums[i]\n        self.segment_tree.update(i, diff)\n        self.nums[i] = val\n        \n\n    def sumRange(self, i, j):\n        \n        return self.segment_tree.range_sum(i, j)\n\n\n\n\n\n",
        "output": "struct BitTree {\n    tree: Vec<i32>,\n    data: Vec<i32>,\n    n: usize,\n}\n\nimpl BitTree {\n    fn new(n: usize) -> Self {\n        let tree = vec![0; n];\n        let data = vec![0; n];\n        let n = n;\n        BitTree { tree, data, n }\n    }\n\n    fn get(&self, i: usize) -> i32 {\n        self.data[i]\n    }\n\n    fn sum(&self, i: usize) -> i32 {\n        let mut res = 0;\n        let down_iter = std::iter::successors(Some(i), |&i| {\n            let j = i & (i + 1);\n            if j > 0 {\n                Some(j - 1)\n            } else {\n                None\n            }\n        });\n        for j in down_iter {\n            res += self.tree[j];\n        }\n        res\n    }\n\n    fn add(&mut self, i: usize, v: i32) {\n        self.data[i] += v;\n        let n = self.n;\n        let up_iter = std::iter::successors(Some(i), |&i| {\n            let j = i | (i + 1);\n            if j < n {\n                Some(j)\n            } else {\n                None\n            }\n        });\n        for j in up_iter {\n            self.tree[j] += v;\n        }\n    }\n}\n\nstruct NumArray {\n    bit_tree: BitTree,\n}\n\nimpl NumArray {\n    fn new(nums: Vec<i32>) -> Self {\n        let n = nums.len();\n        let mut bit_tree = BitTree::new(n);\n        for i in 0..n {\n            bit_tree.add(i, nums[i]);\n        }\n        NumArray { bit_tree }\n    }\n\n    fn update(&mut self, i: i32, val: i32) {\n        let i = i as usize;\n        self.bit_tree.add(i as usize, val - self.bit_tree.get(i))\n    }\n\n    fn sum_range(&self, i: i32, j: i32) -> i32 {\n        let i = i as usize;\n        let j = j as usize;\n        if i > 0 {\n            self.bit_tree.sum(j) - self.bit_tree.sum(i - 1)\n        } else {\n            self.bit_tree.sum(j)\n        }\n    }\n}\n\n#[test]\nfn test() {\n    let nums = vec![1, 3, 5];\n    let mut obj = NumArray::new(nums);\n    assert_eq!(obj.sum_range(0, 2), 9);\n    obj.update(1, 2);\n    assert_eq!(obj.sum_range(0, 2), 8);\n}\n"
    },
    {
        "input": "\n\nclass Solution(object):\n    def coinChange(self, coins, amount):\n        \n        if not coins:\n        \treturn 0\n\n        dp = [float('inf') for _ in range(amount+1)]\n        dp[0] = 0\n\n        for val in range(1, amount+1):\n        \tfor coin in coins:\n        \t\tif coin <= val:\n        \t\t\tdp[val] = min(dp[val-coin]+1, dp[val])\n        return dp[amount] if dp[amount] != float('inf') else -1",
        "output": "struct Solution;\n\nimpl Solution {\n    fn coin_change(coins: Vec<i32>, amount: i32) -> i32 {\n        let n = (amount + 1) as usize;\n        let mut a = vec![-1; n];\n        a[0] = 0;\n        for i in 1..n {\n            for &coin in &coins {\n                if coin as usize <= i {\n                    let j = i - coin as usize;\n                    if a[j] != -1 {\n                        if a[i] == -1 {\n                            a[i] = a[j] + 1\n                        } else {\n                            a[i] = i32::min(a[i], a[j] + 1);\n                        }\n                    }\n                }\n            }\n        }\n        a[amount as usize]\n    }\n}\n\n#[test]\nfn test() {\n    let coins = vec![1, 2, 5];\n    let amount = 11;\n    let res = 3;\n    assert_eq!(Solution::coin_change(coins, amount), res);\n    let coins = vec![2];\n    let amount = 3;\n    let res = -1;\n    assert_eq!(Solution::coin_change(coins, amount), res);\n}\n"
    },
    {
        "input": "\n\nclass Solution(object):\n    def splitArray(self, nums, m):\n        \n        \n        left, right = max(nums), sum(nums)\n        \n        while left < right:\n            mid = left + ((right-left) >> 1)\n            curr_sum, invalid, groups = 0, True, 0\n            for num in nums:\n                if num > mid:\n                    inalid = False\n                    break\n                if num + curr_sum > mid:\n                    groups += 1\n                    curr_sum = 0\n                curr_sum += num\n            if invalid and groups < m:\n                right = mid\n            else:\n                left = mid + 1\n        return left\n ",
        "output": "struct Solution;\n\nimpl Solution {\n    fn split_array(nums: Vec<i32>, m: i32) -> i32 {\n        let mut lo = *nums.iter().max().unwrap();\n        let mut hi = nums.iter().sum();\n        let n = nums.len();\n        while lo <= hi {\n            let mid = (lo + hi) / 2;\n            if Self::split(&nums, mid, n) <= m {\n                hi = mid - 1;\n            } else {\n                lo = mid + 1;\n            }\n        }\n        lo\n    }\n\n    fn split(nums: &[i32], max: i32, n: usize) -> i32 {\n        let mut sum = 0;\n        let mut res = 1;\n        for i in 0..n {\n            if nums[i] + sum > max {\n                sum = nums[i];\n                res += 1;\n            } else {\n                sum += nums[i];\n            }\n        }\n        res\n    }\n}\n\n#[test]\nfn test() {\n    let nums = vec![7, 2, 5, 10, 8];\n    let m = 2;\n    let res = 18;\n    assert_eq!(Solution::split_array(nums, m), res);\n    let nums = vec![1, 2, 3, 4, 5];\n    let m = 2;\n    let res = 9;\n    assert_eq!(Solution::split_array(nums, m), res);\n    let nums = vec![1, 4, 4];\n    let m = 3;\n    let res = 4;\n    assert_eq!(Solution::split_array(nums, m), res);\n    let nums = vec![2, 3, 1, 2, 4, 3];\n    let m = 5;\n    let res = 4;\n    assert_eq!(Solution::split_array(nums, m), res);\n}\n"
    },
    {
        "input": "\n\nclass Solution(object):\n    def findDisappearedNumbers(self, nums):\n        \n        if not nums:\n            return []\n        result = []\n        for num in nums:\n            index = abs(num)-1\n            if nums[index] > 0:\n                nums[index]*=-1\n        for index, num in enumerate(nums):\n            if num >0:\n                result.append(index+1)\n        return result\n",
        "output": "struct Solution;\n\nimpl Solution {\n    fn find_disappeared_numbers(mut nums: Vec<i32>) -> Vec<i32> {\n        let n = nums.len();\n        for i in 0..n {\n            let index: usize = (nums[i].abs() as usize) - 1;\n            nums[index] = -nums[index].abs();\n        }\n        let mut res: Vec<i32> = vec![];\n        for i in 1..=n {\n            let index = i - 1;\n            if nums[index] > 0 {\n                res.push(i as i32);\n            }\n        }\n        res\n    }\n}\n\n#[test]\nfn test() {\n    let nums = vec![4, 3, 2, 7, 8, 2, 3, 1];\n    assert_eq!(Solution::find_disappeared_numbers(nums), vec![5, 6]);\n}\n"
    },
    {
        "input": "\n\nclass Solution(object):\n    def licenseKeyFormatting(self, S, K):\n        \n        S = S.replace('-','').upper()\n        result = \"\"\n        \n        if len(S)%K == 0:\n            for index in range(0, len(S), K):\n                result += S[index:index+K] + \"-\"\n        else:\n            result = S[:len(S)%K] + \"-\"\n            for index in range(len(S)%K, len(S), K):\n                result += S[index:index+K] + \"-\"\n        return result[:-1]\n",
        "output": "struct Solution;\n\nimpl Solution {\n    fn license_key_formatting(s: String, k: i32) -> String {\n        let mut res: Vec<char> = vec![];\n        let mut i = 0;\n        for c in s.chars().rev() {\n            if c != '-' {\n                res.push(c);\n                i += 1;\n                if i == k {\n                    i = 0;\n                    res.push('-');\n                }\n            }\n        }\n        if let Some(&'-') = res.last() {\n            res.pop();\n        }\n        res.iter().rev().collect::<String>().to_ascii_uppercase()\n    }\n}\n\n#[test]\nfn test() {\n    let s = \"5F3Z-2e-9-w\".to_string();\n    let k = 4;\n    let o = \"5F3Z-2E9W\".to_string();\n    assert_eq!(Solution::license_key_formatting(s, k), o);\n\n    let s = \"2-5g-3-J\".to_string();\n    let k = 2;\n    let o = \"2-5G-3J\".to_string();\n    assert_eq!(Solution::license_key_formatting(s, k), o);\n}\n"
    },
    {
        "input": "class Solution(object):\n    def fourSumCount(self, A, B, C, D):\n        \n        hashTable ={}\n        \n        for a in A:\n            for b in B:\n                if a+b in hashTable:\n                    hashTable[a+b] += 1\n                else:\n                    hashTable[a+b] = 1\n                    \n        result = 0\n        for c in C:\n            for d in D:\n                if -(c+d) in hashTable:\n                    result += hashTable[-(c+d)]\n        return result\n        ",
        "output": "struct Solution;\nuse std::collections::HashMap;\n\nimpl Solution {\n    fn four_sum_count(a: Vec<i32>, b: Vec<i32>, c: Vec<i32>, d: Vec<i32>) -> i32 {\n        let mut hm: HashMap<i32, usize> = HashMap::new();\n        for &i in &a {\n            for &j in &b {\n                *hm.entry(i + j).or_default() += 1;\n            }\n        }\n        let mut res = 0;\n        for &i in &c {\n            for &j in &d {\n                if let Some(v) = hm.get(&(-i - j)) {\n                    res += v;\n                }\n            }\n        }\n        res as i32\n    }\n}\n\n#[test]\nfn test() {\n    let a = vec![1, 2];\n    let b = vec![-2, -1];\n    let c = vec![-1, 2];\n    let d = vec![0, 2];\n    let res = 2;\n    assert_eq!(Solution::four_sum_count(a, b, c, d), res);\n}\n"
    },
    {
        "input": "\n\nclass Solution(object):\n    def findDuplicates(self, nums):\n        \n        if not nums:\n            return []\n        \n        result = []\n        for _, num in enumerate(nums):\n            index = abs(num)-1\n            if nums[index] < 0:\n                result.append(index+1)\n            nums[index]*=-1\n        return result\n",
        "output": "struct Solution;\n\nimpl Solution {\n    fn find_duplicates(mut nums: Vec<i32>) -> Vec<i32> {\n        let mut res: Vec<i32> = vec![];\n        let n = nums.len();\n        for i in 0..n {\n            let x = nums[i];\n            let index = (x.abs() - 1) as usize;\n            if nums[index] < 0 {\n                res.push(x.abs());\n            } else {\n                nums[index] *= -1;\n            }\n        }\n        res\n    }\n}\n\n#[test]\nfn test() {\n    let nums = vec![4, 3, 2, 7, 8, 2, 3, 1];\n    let res = vec![2, 3];\n    assert_eq!(Solution::find_duplicates(nums), res);\n}\n"
    },
    {
        "input": "\n\nclass Solution(object):\n\tdef wordsTyping(self, sentences, rows, cols):\n\t\t\n\t\tsentence = '-'.join(sentences)\n\t\tsentence += '-'\n\n\t\tindex_in_sentence = 0\n\t\tfor row in range(rows):\n\t\t\tindex_in_sentence += cols\n\t\t\tif sentence[(index_in_sentence%len(sentence))] == '-':\n\t\t\t\tindex_in_sentence += 1\n\t\t\telse:\n\t\t\t\twhile index_in_sentence > 0 and sentence[((index_in_sentence - 1)%len(sentence))] != '-':\n\t\t\t\t\tindex_in_sentence -= 1\n\n\t\treturn index_in_sentence/len(sentence)\n\nsolution = Solution()\nrow, col = 3, 6\nsentences = [\"a\", \"bcd\", \"e\"]\nprint solution.wordsTyping(sentences=sentences, rows=row, cols=col)\n",
        "output": "struct Solution;\n\nimpl Solution {\n    fn words_typing(sentence: Vec<String>, rows: i32, cols: i32) -> i32 {\n        let size: Vec<usize> = sentence.into_iter().map(|s| s.len()).collect();\n        let n = size.len();\n        let sum: usize = size.iter().sum::<usize>() + n;\n        let mut i = 0;\n        let rows = rows as usize;\n        let cols = cols as usize;\n        let mut res = 0;\n        for _ in 0..rows {\n            if size[i] <= cols {\n                let m = cols / sum;\n                res += m;\n                let mut start = m * sum;\n                if start + size[i] <= cols {\n                    start += size[i];\n                    i += 1;\n                    if i == n {\n                        i = 0;\n                        res += 1;\n                    }\n                } else {\n                    continue;\n                }\n                while start + size[i] < cols {\n                    start += size[i] + 1;\n                    i += 1;\n                    if i == n {\n                        i = 0;\n                        res += 1;\n                    }\n                }\n            } else {\n                break;\n            }\n        }\n        res as i32\n    }\n}\n\n#[test]\nfn test() {\n    let rows = 2;\n    let cols = 8;\n    let sentence = vec_string![\"hello\", \"world\"];\n    let res = 1;\n    assert_eq!(Solution::words_typing(sentence, rows, cols), res);\n    let rows = 3;\n    let cols = 6;\n    let sentence = vec_string![\"a\", \"bcd\", \"e\"];\n    let res = 2;\n    assert_eq!(Solution::words_typing(sentence, rows, cols), res);\n    let rows = 4;\n    let cols = 5;\n    let sentence = vec_string![\"I\", \"had\", \"apple\", \"pie\"];\n    let res = 1;\n    assert_eq!(Solution::words_typing(sentence, rows, cols), res);\n}\n"
    },
    {
        "input": "\n\nclass Solution(object):\n    def maximumSum(self, arr):\n        \n        forward = [0] * len(arr)\n        backward = [0] * len(arr)\n        \n        curr_max, max_so_far = arr[0], arr[0]\n        forward[0] = arr[0]\n        for index in range(1, len(arr)):\n            curr_max = max(arr[index], curr_max + arr[index])\n            max_so_far = max(max_so_far, curr_max)\n            \n            forward[index] = curr_max\n            \n        curr_max = arr[len(arr) - 1]\n        max_so_far = arr[len(arr) - 1]\n        backward[len(arr) - 1] = arr[len(arr) - 1]\n        \n        index = len(arr) - 2\n        while index >= 0:\n            curr_max = max(arr[index], curr_max + arr[index])\n            max_so_far = max(max_so_far, curr_max)\n            \n            backward[index] = curr_max\n            index -= 1\n            \n        result = max_so_far\n        for index in range(1, len(arr)-1):\n            result = max(result, forward[index-1] + backward[index + 1])\n        return result\n",
        "output": "struct Solution;\n\nimpl Solution {\n    fn maximum_sum(arr: Vec<i32>) -> i32 {\n        let n = arr.len();\n        let mut left_sum = 0;\n        let mut left_max = vec![0; n];\n        let mut left_min = 0;\n        let mut right_sum = 0;\n        let mut right_max = vec![0; n];\n        let mut right_min = 0;\n        for i in 0..n {\n            left_sum += arr[i];\n            left_max[i] = left_sum - left_min;\n            left_min = left_min.min(left_sum);\n        }\n        for i in (0..n).rev() {\n            right_sum += arr[i];\n            right_max[i] = right_sum - right_min;\n            right_min = right_min.min(right_sum);\n        }\n        let mut res = std::i32::MIN;\n        for i in 0..n {\n            res = res.max(left_max[i]);\n            res = res.max(right_max[i]);\n            if i > 0 && i + 1 < n {\n                res = res.max(left_max[i - 1] + right_max[i + 1]);\n            }\n        }\n        res\n    }\n}\n\n#[test]\nfn test() {\n    let arr = vec![1, -2, 0, 3];\n    let res = 4;\n    assert_eq!(Solution::maximum_sum(arr), res);\n    let arr = vec![1, -2, -2, 3];\n    let res = 3;\n    assert_eq!(Solution::maximum_sum(arr), res);\n    let arr = vec![-1, -1, -1, -1];\n    let res = -1;\n    assert_eq!(Solution::maximum_sum(arr), res);\n    let arr = vec![0, -5, -6, 5, 0, -5];\n    let res = 5;\n    assert_eq!(Solution::maximum_sum(arr), res);\n}\n"
    },
    {
        "input": "\n\nclass Solution(object):\n    def distanceBetweenBusStops(self, distance, start, destination):\n        \n        start, destination = min(start, destination), max(start, destination)\n        clock_dist = sum(distance[start:destination])\n        anti_clock_dist = sum(distance[:start]) + sum(distance[destination:])\n        return min(clock_dist, anti_clock_dist)\n",
        "output": "struct Solution;\n\nimpl Solution {\n    fn distance_between_bus_stops(distance: Vec<i32>, mut start: i32, mut destination: i32) -> i32 {\n        let n: usize = distance.len();\n        let mut left = 0;\n        let mut right = 0;\n        if destination < start {\n            std::mem::swap(&mut start, &mut destination);\n        }\n        for i in 0..n {\n            let j = start as usize + i;\n            if j < destination as usize {\n                left += distance[j % n];\n            } else {\n                right += distance[j % n];\n            }\n        }\n        i32::min(left, right)\n    }\n}\n\n#[test]\nfn test() {\n    let distance = vec![1, 2, 3, 4];\n    let start = 0;\n    let destination = 1;\n    let res = 1;\n    assert_eq!(\n        Solution::distance_between_bus_stops(distance, start, destination),\n        res\n    );\n    let distance = vec![1, 2, 3, 4];\n    let start = 0;\n    let destination = 1;\n    let res = 1;\n    assert_eq!(\n        Solution::distance_between_bus_stops(distance, start, destination),\n        res\n    );\n    let distance = vec![1, 2, 3, 4];\n    let start = 0;\n    let destination = 2;\n    let res = 3;\n    assert_eq!(\n        Solution::distance_between_bus_stops(distance, start, destination),\n        res\n    );\n    let distance = vec![1, 2, 3, 4];\n    let start = 0;\n    let destination = 3;\n    let res = 4;\n    assert_eq!(\n        Solution::distance_between_bus_stops(distance, start, destination),\n        res\n    );\n    let distance = vec![3, 6, 7, 2, 9, 10, 7, 16, 11];\n    let start = 6;\n    let destination = 2;\n    let res = 28;\n    assert_eq!(\n        Solution::distance_between_bus_stops(distance, start, destination),\n        res\n    );\n}\n"
    },
    {
        "input": "\nclass Solution(object):\n    def kConcatenationMaxSum(self, arr, k):\n        \n        def kadane(arr):\n            curr_sum, max_sum = arr[0], arr[0]\n            for index in range(1, len(arr)):\n                curr_sum = max(arr[index], curr_sum + arr[index])\n                max_sum = max(max_sum, curr_sum)\n            return max_sum\n\n        def prefix(arr):\n            curr_sum, max_val = 0, float('-inf')\n            for index, val in enumerate(arr):\n                curr_sum += val\n                max_val = max(max_val, curr_sum)\n            return max_val\n        \n        def suffix(arr):\n            curr_sum, max_val = 0, float('-inf')\n            for index in range(len(arr)-1, -1, -1):\n                curr_sum += arr[index]\n                max_val = max(max_val, curr_sum)\n            return max_val\n        \n        if not arr:\n            return 0\n        if k == 1:\n            return max(0, kadane(arr)) % (10 ** 9 + 7)\n        else:\n            return max(0, max((prefix(arr) + suffix(arr) + (k-2)*max(sum(arr), 0), kadane(arr)))) % (10 ** 9 + 7)\n",
        "output": "struct Solution;\n\nconst MOD: i32 = 1_000_000_007;\n\nimpl Solution {\n    fn k_concatenation_max_sum(arr: Vec<i32>, k: i32) -> i32 {\n        let sum: i32 = arr.iter().sum();\n        let mut prev = 0;\n        let mut res = 0;\n        let mut k = k as usize;\n        let n = arr.len();\n        for i in 0..n * k.min(2) {\n            prev = arr[i % n].max(prev + arr[i % n]);\n            res = res.max(prev);\n        }\n        while sum > 0 && k > 2 {\n            res += sum;\n            res %= MOD;\n            k -= 1\n        }\n        res\n    }\n}\n\n#[test]\nfn test() {\n    let arr = vec![1, 2];\n    let k = 3;\n    let res = 9;\n    assert_eq!(Solution::k_concatenation_max_sum(arr, k), res);\n    let arr = vec![1, -2, 1];\n    let k = 5;\n    let res = 2;\n    assert_eq!(Solution::k_concatenation_max_sum(arr, k), res);\n    let arr = vec![-1, -2];\n    let k = 7;\n    let res = 0;\n    assert_eq!(Solution::k_concatenation_max_sum(arr, k), res);\n}\n"
    },
    {
        "input": "\n\nclass Solution(object):\n    def reverseParentheses(self, s):\n        \n        if not s:\n            return ''\n        \n        stack = []\n        for char in s:\n            if char == ')':\n                combine_str = ''\n                while stack and stack[-1] != '(':\n                    elem = stack.pop()[::-1]\n                    combine_str += elem\n                stack.pop()\n                stack.append(combine_str)\n            else:\n                stack.append(char)\n        return \"\".join(stack)\n",
        "output": "struct Solution;\n\nuse std::collections::VecDeque;\n\nimpl Solution {\n    fn reverse_parentheses(s: String) -> String {\n        let mut stack: Vec<char> = vec![];\n        let mut queue: VecDeque<char> = VecDeque::new();\n        for c in s.chars() {\n            if c == ')' {\n                while let Some(top) = stack.pop() {\n                    if top == '(' {\n                        while let Some(front) = queue.pop_front() {\n                            stack.push(front);\n                        }\n                        break;\n                    } else {\n                        queue.push_back(top);\n                    }\n                }\n            } else {\n                stack.push(c);\n            }\n        }\n        stack.iter().collect()\n    }\n}\n\n#[test]\nfn test() {\n    let s = \"(abcd)\".to_string();\n    let res = \"dcba\".to_string();\n    assert_eq!(Solution::reverse_parentheses(s), res);\n    let s = \"(u(love)i)\".to_string();\n    let res = \"iloveu\".to_string();\n    assert_eq!(Solution::reverse_parentheses(s), res);\n    let s = \"(ed(et(oc))el)\".to_string();\n    let res = \"leetcode\".to_string();\n    assert_eq!(Solution::reverse_parentheses(s), res);\n    let s = \"a(bcdefghijkl(mno)p)q\".to_string();\n    let res = \"apmnolkjihgfedcbq\".to_string();\n    assert_eq!(Solution::reverse_parentheses(s), res);\n}\n"
    },
    {
        "input": "\n\nclass Solution(object):\n    def maxNumberOfBalloons(self, text):\n        \n        if not text:\n            return 0\n        \n        import collections\n        cnt = collections.Counter(text)\n        cnt_ballon = collections.Counter('balloon')\n        \n        return min([cnt[c]//cnt_ballon[c] for c in cnt_ballon])\n",
        "output": "struct Solution;\n\nuse std::collections::HashMap;\n\nimpl Solution {\n    fn max_number_of_balloons(text: String) -> i32 {\n        let mut text_count: HashMap<char, usize> = HashMap::new();\n        let mut ballon_count: HashMap<char, usize> = HashMap::new();\n        for c in \"balloon\".chars() {\n            *ballon_count.entry(c).or_default() += 1;\n        }\n        for c in text.chars() {\n            *text_count.entry(c).or_default() += 1;\n        }\n\n        let mut min = text.len();\n        for (c, v) in ballon_count {\n            min = usize::min(text_count.get(&c).unwrap_or(&0) / v, min);\n        }\n        min as i32\n    }\n}\n\n#[test]\nfn test() {\n    let text = \"nlaebolko\".to_string();\n    assert_eq!(Solution::max_number_of_balloons(text), 1);\n    let text = \"loonbalxballpoon\".to_string();\n    assert_eq!(Solution::max_number_of_balloons(text), 2);\n    let text = \"leetcode\".to_string();\n    assert_eq!(Solution::max_number_of_balloons(text), 0);\n}\n"
    },
    {
        "input": "\nclass Solution(object):\n    def dayOfTheWeek(self, day, month, year):\n        \n        day_of_week_map = [\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"]\n        t = [ 0, 3, 2, 5, 0, 3, 5, 1, 4, 6, 2, 4 ] \n        year -= month < 3\n        return day_of_week_map[((year  + int(year / 4) - int(year / 100) + int(year / 400) + t[month - 1] + day) % 7)]\n",
        "output": "struct Solution;\n\nimpl Solution {\n    fn day_of_the_week(day: i32, mut month: i32, mut year: i32) -> String {\n        let days = [\n            \"Sunday\",\n            \"Monday\",\n            \"Tuesday\",\n            \"Wednesday\",\n            \"Thursday\",\n            \"Friday\",\n            \"Saturday\",\n        ];\n        if month < 3 {\n            month += 12;\n            year -= 1;\n        }\n        let week =\n            (day + ((month + 1) * 26) / 10 + year + year / 4 + 6 * (year / 100) + year / 400 + 5)\n                % 7\n                + 1;\n        days[week as usize % 7].to_string()\n    }\n}\n\n#[test]\nfn test() {\n    let day = 31;\n    let month = 8;\n    let year = 2019;\n    let res = \"Saturday\".to_string();\n    assert_eq!(Solution::day_of_the_week(day, month, year), res);\n    let day = 18;\n    let month = 7;\n    let year = 1999;\n    let res = \"Sunday\".to_string();\n    assert_eq!(Solution::day_of_the_week(day, month, year), res);\n    let day = 15;\n    let month = 8;\n    let year = 1993;\n    let res = \"Sunday\".to_string();\n    assert_eq!(Solution::day_of_the_week(day, month, year), res);\n}\n"
    }
]